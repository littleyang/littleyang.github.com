<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
    <meta charset="UTF-8" />
    <meta name="application-name" content="Looking-Glass" />
    <meta name="author" content="LittleYang" />
    <meta name="generator" content="Jekyll 0.12.0" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <meta itemprop="name" content="【译文】Z：一种基于Z-表达式的新语言">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="" />

    <title>【译文】Z：一种基于Z-表达式的新语言</title>

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" />
    <link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico" sizes="57x57" />

    <link rel="author" type="text/html" href="https://plus.google.com/100974147585154622588/about" />
    <link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/3.0/" />

    <!-- Google Web Fonts (not in use) -->
    <!-- link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Droid+Sans' / -->

    <link rel="stylesheet" type="text/css" href="/~css/main.css" media="all" />
    <link rel="stylesheet" type="text/css" href="/~css/mobile.css" media="all and (max-width:1023px)" />

    <!-- Pygments -->
    <link rel="stylesheet" type="text/css" href="/~css/pygments.css" media="all" />

    <!-- Highlight.js -->
    <link rel="stylesheet" href="/~css/tomorrow-night.min.css">
    <script src="/~js/highlight.pack.js"></script>
    <!-- script>hljs.initHighlightingOnLoad();</script -->

    <!-- jQuery & Galleria -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script>
    <script src="/~plugins/galleria/galleria-1.2.8.min.js"></script>

    <!-- MathJax (not in use) -->
    <!-- script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script -->

    <!-- ShareThis (not in use) -->
    <!-- script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">stLight.options({publisher: "9aabed9c-ac3f-4f96-8f5a-8e7a27307543"}); </script -->

    <!-- Google Analytics -->
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-27086900-1']);
        _gaq.push(['_setDomainName', '.soimort.org']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    <script type="text/javascript" src="/~js/main.js"></script>

</head>

<body>
    <!-- load background image (must be put in body) -->
    <script type="text/javascript">
        document.body.style.backgroundImage = "url('http://i.imgur.com/0eQ5v.jpg')";
    </script>

    <nav id="navBarTop">
        <ul class="navBarListLeft">
            <li><a href="/"><img src="/~images/home.png" alt="home" title="Home" class="navDock" height="24" /></a></li>
            <li><a href="/atom.xml" target="_blank"><img src="/~images/feed.png" alt="feed" title="Feed" class="navDock" height="24" /></a></li>
        </ul>

        <ul class="navBarListRight">
            <li style="position: relative; top: -5px"><b>LittleYang</b> on </li>
            <!-- Google+ --><li><a href="https://plus.google.com/107586052733788098083/" target="_blank"><img src="https://ssl.gstatic.com/images/icons/gplus-32.png" alt="gplus" title="Google+" class="navDock" height="24" /></a></li>
            <!-- Twitter --><li><a href="https://twitter.com/soimort" target="_blank"><img src="/~images/twitter.png" alt="twitter" title="Twitter" class="navDock" height="24" /></a></li>
            <!-- Facebook --><!-- li><a href="https://www.facebook.com/soimort" target="_blank"><img src="/~images/facebook.png" alt="facebook" title="Facebook" class="navDock" height="24" /></a></li -->
            <!-- deviantArt --><li><a href="http://soimort.deviantart.com" target="_blank"><img src="/~images/deviantart.png" alt="deviantart" title="deviantART" class="navDock" height="24" /></a></li>
            <!-- GitHub --><li><a href="http://github.com/soimort" target="_blank"><img src="/~images/github.png" alt="github" title="GitHub" class="navDock" height="24" /></a></li>
        </ul>
    </nav>

    <nav id="navBarBottom">
        <div class="navBarListLeft">
            <div style="position: relative; top: 4px; width: 60%">
                © 2013 <a href="http://www.google.com" target="_blank"><b>Little Yang</b></a>. Under the <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank"><b>CC BY-SA 3.0 License</b></a>.
            </div>
        </div>

        <div class="navBarListRight">
            <div style="position: relative; top: 4px; right: 0">
                 |Powered by <a href="http://jekyllrb.com/" target="_blank"><b>Jekyll</b></a>
            </div>
        </div>
    </nav>

    <div id="divTitle">
    <h1>【译文】Z：一种基于Z-表达式的新语言</h1>
    <p><div class="g-plusone" data-size="medium" data-annotation="none"></div></p>
    <p><b>03 Jan 2013</b>, by <b>Mort</b></p>
    <p></p>
    <div id="divTitleNav">
        <a href="/"><img src="/~images/left-arrow.png" class="navDock" /></a>
    </div>
</div>

<div id="divPost">
    <article id="articlePost">
        <p>Original Article: <a href="http://chrisdone.com/z/">A tiny language called Z</a> by <a href="http://chrisdone.com/">Chris Done</a><br>
(Chinese Translation by <a href="http://www.soimort.org/">Mort Yao</a>)</p>

<hr>

<h2>翻译君的话</h2>

<p>为了给了解一些Lisp的人节省时间：<strong>你可以把Z看成是Scheme在另一个平行宇宙里的镜像</strong>——Scheme程序由<a href="http://en.wikipedia.org/wiki/S-expression">S-表达式（S-expression）</a>构成，而Z的基本元素则是<strong>Z-表达式（Z-expression）</strong>。Z-表达式与S-表达式的不同之处在于，它通过<strong>缩进</strong>而不是<strong>括号嵌套</strong>来表示其语义。如果你知道了这些，就可以直接去hack它了：</p>

<p><a href="https://github.com/chrisdone/z">https://github.com/chrisdone/z</a></p>

<p>（注意：该项目虽然名字叫Z，但是和由Zermelo集合论衍生而来的<a href="http://en.wikipedia.org/wiki/Z_notation">Z符号语言</a>似乎并无直接联系。）</p>

<p>以前有个笑话：据说某俄国特工经过九死一生偷到了NASA的太空火箭发射程序的源代码的最后一页，代码是</p>
<div class="highlight"><pre><code class="text">)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
</code></pre></div>
<p>现在，如果你厌倦了Lisp里面太多的括号，不妨去尝试一下Z！</p>

<p>这个由Chris Done发起的项目比较新（2013年1月1日，也就是前几天刚发布）。查了一下Scheme的历史，发现采用缩进来代替括号的想法早在十年前（2003年）就有人在<a href="http://en.wikipedia.org/wiki/Scheme_Requests_for_Implementation">SRFI（Scheme Request For Implementation）</a>上面提出过了（<a href="http://srfi.schemers.org/srfi-49/srfi-49.html">SRFI-49: Indentation-sensitive syntax</a>）。当时用的名称叫做<a href="http://en.wikipedia.org/wiki/M-expression#Variants">I-表达式（I-expression）</a>。不过这个想法并没有被Scheme社区广泛接受。不知道这次新出现的Z前景如何，拭目以待。</p>

<p>此外，如果你做过传说中的<a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">48小时写一个Scheme解释器（Write Yourself a Scheme in 48 Hours）</a>的话，你会发现这个<a href="https://github.com/chrisdone/z">Z解释器的实现</a>基本上是与它平行的。把以前实现的Scheme解释器改写成Z解释器应该也不是什么难事。玩的只是概念而已。</p>

<p>以下为原文内容。</p>

<hr>

<h2>一种叫做Z的小型语言</h2>

<p>一种小型的、严格的、非纯函数式的、<a href="http://www.haskell.org/haskellwiki/Currying">柯里式的（curried）</a>、动态类型的（尽管这可能会在将来改变）、<a href="http://en.wikipedia.org/wiki/Partial_application">分步代入的（partially applied）</a>且有着相当奇特语法的语言。</p>

<p><em>它的基本思想看起来很聪明，甚至聪明得有些过头了。 — 摘自reddit的评论</em></p>

<h3>从Markdown得到的启发</h3>

<p>首先，让我们回顾一下Markdown。即使你没有亲自写过Markdown，你应该也已经见到过一些。你应该知道在Markdown的语法中有一个特别之处，即它嵌入代码的方式。它极其简单；不过是：<strong>你只需缩进4个空格，然后就可以随心所欲地在后面书写任何代码了！</strong></p>
<div class="highlight"><pre><code class="text">Hello world! Here comes some code!

    Here is some arbitrary code! f.x()/f23(); // Zaha!

And now we&#39;re back to normal text...
</code></pre></div>
<p>这个想法的特别之处，就是你事实上可以把任何东西都放到这个缩进的后面，而且，它们不会影响到外围的代码！这是个非常牛逼的想法，让我来告诉你为什么。</p>

<h3>Z-表达式（Z-expression）</h3>

<p>我将在此介绍一个极其微型的语言，称之为“Z”，用来展示我的这一想法。</p>

<p>Z有着极其、极其简单的语法。古怪，却简单。这里是它如何工作的一个例子，函数的调用采取如下形式：</p>
<div class="highlight"><pre><code class="text">name argument
</code></pre></div>
<p>更深入些的话，下面这段代码：</p>
<div class="highlight"><pre><code class="text">foo bar mu zot
</code></pre></div>
<p>实际上是被分组后依次解析的：</p>
<div class="highlight"><pre><code class="text">foo (bar (mu zot))
</code></pre></div>
<p>（注意：在Z源码里实际上并没有括号。Z即Zero。）</p>

<p>如果仔细想一想前面给出的<code>name argument</code>形式的话，这其实是一个非常自然的分组方式。</p>

<p>为了向某个函数传递多个参数，额外的参数需要被放置在下一行，并且被统一缩进到与第一个参数所在的同一列。</p>
<div class="highlight"><pre><code class="text">foo bar
    mu
    zot
</code></pre></div>
<p>这表明<code>foo</code>函数有三个参数。该规则适用于<strong>任何场合</strong>，因此，我们也可以写：</p>
<div class="highlight"><pre><code class="text">foo bar mu
        zot
    bob
</code></pre></div>
<p>这表明<code>foo</code>函数有两个参数，而<code>bar</code>函数有两个参数。</p>

<p>我管这种形式叫做“Z-表达式（Z-expression）”。Lisp语言是括弧状的（curly），卷曲的（curvy），它有它的S-表达式（S-expressions）。而Z则是锯齿状的（jagged），犀利的（sharp）。以及，古怪的。</p>

<p>特殊算符遵循一套相同的规则。下面我将介绍其中的一些特殊算符。</p>

<h3>Z的内置算符</h3>

<p><code>defun</code>特殊算符需要两个参数：一个名称的列表，其中第一个表示函数的名称；以及一个函数体。这里是一个用来<strong><em>连接</em></strong>两个列表的函数：</p>

<pre><code><span class="kr">defun</span> ap x y
      ++ x
         y
</code></pre>

<p>所有的Z函数都是柯里式的（curried）和<a href="http://en.wikipedia.org/wiki/Partial_application">分步代入（partially applied）</a>的，如同在Haskell中一样。故上述代码等效于：</p>

<pre><code><span class="kr">def</span> ap
    <span class="kr">fn</span> x
       <span class="kr">fn</span> y
          ++ x
             y
</code></pre>

<p>在本介绍中暂时不对此加以赘述。我们同样有<code>if</code>和<code>do</code>：</p>

<pre><code><span class="kr">if</span> foo
   bar
   mu

<span class="kr">do</span> this
   that
   those
</code></pre>

<p>如果你感兴趣的话，注意下，这些特殊算符采取一种非函数的<a href="http://en.wikipedia.org/wiki/Normal_order_evaluation#Normal_order">常序式求值策略（Normal-order evaluation）</a>。它们只是单纯从语法上来解释自身的参数！</p>

<p>我们同样有一些用于表示数字的诸如<code>123</code>、用于表示字符串的诸如<code>&quot;strings&quot;</code>和<code>unit</code>之类的符号，就和nothing、null、empty、voidness、niente一样稀松平常<em>（翻译君：这些是各种用来表示“空”的词汇）</em>。</p>

<h3>定义宏</h3>

<p>啊哈！La pièce de résistance（法语：主盘大菜上桌，即全套大餐的精华）！现在，我们将拥有一个<code>defmacro</code>算符，它的任务是允许我们自行定义新的符号。看好了……</p>

<pre><code><span class="kr">defmacro</span> -- _
         <span class="s">"unit"</span>
</code></pre>

<p>Voilà（法语：瞧这）！我们定义了一个名称<code>--</code>，它取得一个我们并不关心其内容的参数<code>_</code><em>（翻译君：在这里下划线的含义与许多语言中相同，表示无名变量）</em>，并且总是返回字符串<code>&quot;unit&quot;</code>。</p>

<p>所有的宏都读取一个字符串，这个字符串是源码中所有可以成为它参数的部分，而我们知道，这部分将由缩进来决定。所有的宏都将会产生一个新的字符串，被用来置换到调用宏的原位置，然后将会被解释器<strong><em>重新解析</em></strong>。</p>

<p>在我们的这个<code>--</code>宏的例子当中，我们仅仅返回了一个<code>unit</code>，一个<a href="http://en.wikipedia.org/wiki/NOP">非操作符（no-op）</a>。这样，我们就<strong>已经定义了属于我们自己的注释符号</strong>：</p>

<pre><code><span class="c">-- A simple function, that is used inside the macro below.</span>
<span class="kr">defmacro</span> ap x y
         ++ x
            y
</code></pre>

<p>挞哒（Tada）！这是一个带注释的函数定义！用到了我们刚才自创的注释语法，不是吗！我们同样也可以把这个函数<code>ap</code>用在其它的宏的<strong><em>内部</em></strong>，这在Lisp语言中是非常典型的用法。所以现在，就让我们基于它来定义一个稍微复杂一些的宏吧：</p>

<h3><code>when</code>宏</h3>

<pre><code><span class="c">-- A messy macro (because it uses string manipulation),
   but demonstrates the idea well enough.</span>
<span class="kr">defmacro</span> when input
         <span class="kr">fn</span> blocks
            ap <span class="s">"if"</span>
               ++ <span class="kt">z:indent-before</span> 3
                                  car blocks
                  ++ <span class="s">"\n"</span>
                     ++ <span class="kt">z:indent</span> 3
                                 car cdr blocks
                        ++ <span class="s">"\n"</span>
                           <span class="kt">z:indent</span> 3
                                    <span class="s">"unit"</span>
            <span class="kt">z:blocks</span> input
</code></pre>

<p>这里可以看到，我们提供了一些辅助函数，用以获取“blocks”——也就是一次函数代入中的全部参数——并将它们传递给从<code>fn blocks</code>开始的匿名函数，然后构造出一个用于返回的字符串。</p>

<p>你能看出这个宏的目的吗？有了它，我们就可以写出：</p>

<pre><code>when = 1
       1
     print ++ <span class="s">"The number is: "</span>
              when true
                   show 123
</code></pre>

<p>看看这是多么自然？在宏当中嵌套宏什么的完全不是问题！</p>

<h3>字符串的宏</h3>

<p>在编程时经常会遇到的问题是，如何尽可能避免麻烦地书写字符串。通常情况下，我们得遵循一套字符转义的特殊规则。但在Z中，你完全不需要这么做！</p>

<p>以前字符串的使用方式都弱爆了：</p>

<pre><code>print <span class="s">"Hai, guys!"</span>
</code></pre>

<p>我们将要定义一个新的宏来方便我们书写字符串，那就是<code>:</code>符号。它旨在让字符串同正常人类语言一样直接可读，并且允许你在缩进后的文本列范围内不受任何限制地书写任意文本。</p>

<pre><code><span class="kr">defmacro</span> : input
         <span class="kt">z:string</span> input
</code></pre>

<p>以上，我提供了一种将一个<code>string</code>转换成一个<code>&quot;string&quot;</code>的方法，因此不管把任何东西作为<code>input</code>传递到宏，都将被逐字返回，并且是以字符串的形式。准备好了吗？请看！</p>

<pre><code><span class="c">-- Example with print:</span>
print : Hello, World!
        What's going on in here? 
</code></pre>

<p>果然碉堡了不是么？它看起来就像是一段常见的脚本程序！而<strong><em>这</em></strong>，也正是从Markdown那里得到的启发。它同样也适用于在其他函数中的代入：</p>

<pre><code><span class="kr">defun</span> message msg
      <span class="kr">do</span> print : Here's a message
         print msg
         print : End of message. 
</code></pre>

<p>可以如此使用上述定义的函数：</p>

<pre><code>message ap : Hello,
           ++ <span class="s">" World! "</span>
              : Love ya! 
</code></pre>

<p>只要你愿意，当然也可以直接这么写：</p>

<pre><code>message : <span class="s">Everybody dance now!</span>
</code></pre>

<h3>一些函数定义的示例</h3>

<p>到目前为止已经足够给力了。让我们从兴奋中暂时缓口气，来看一些枯燥的纯函数。这些就是Z代码真实的样子。</p>

<pre><code><span class="c">-- Map function.</span>
<span class="kr">defun</span> map f xs
      <span class="kr">if</span> unit? xs
         unit
         cons f car xs
              map f
                  cdr xs

<span class="c">-- ["foo","bar"] → foo\nbar\n</span>
<span class="kr">defun</span> unlines xs
      <span class="kr">if</span> unit? xs
         <span class="s">""</span>
         ++ car xs
            ++ <span class="s">"\n"</span>
               unlines cdr xs

<span class="c">-- Take the first n elements of list xs.</span>
<span class="kr">defun</span> take n xs
      <span class="kr">if</span> = n
           0
         unit
         <span class="kr">if</span> unit? xs
            unit
            cons car xs
                 take - n
                        1
                      cdr xs

<span class="c">-- Take all but the last element of a list.</span>
<span class="kr">defun</span> init xs
      <span class="kr">if</span> unit? xs
         unit
         <span class="kr">if</span> unit? cdr xs
            unit
            cons car xs
                 init cdr xs

<span class="c">-- Take the last element of a list, or return a default.</span>
<span class="kr">defun</span> last def xs
      <span class="kr">if</span> unit? xs
         def
         <span class="kr">if</span> unit? cdr xs
            car xs
            last def
                 cdr xs
</code></pre>

<p>话说，没有模式匹配（pattern matching）的编程不是很蛋疼吗！？不幸的是，今天我们暂时不会在这里用Z去定义一套模式匹配符，因为要实现一个像模像样的模式匹配并非轻易之举，而做一个过于简陋的会让我感觉很囧。<em>（翻译君：囧rz）</em></p>

<p>我们可以开始使用这些函数了，正如所期望的那样：</p>

<pre><code><span class="c">-- Print the blocks of foo and bar with ! on the end.</span>
print unlines map <span class="kr">fn</span> x
                     ++ x
                        <span class="s">"!"</span>
                  <span class="kt">z:blocks</span> : foo
                             bar

<span class="c">-- Use of take function.</span>
print unlines take 3
                   <span class="kt">z:blocks</span> : foo
                              bar
                              mu
                              zot
</code></pre>

<h3>正则表达式</h3>

<p>这是另外一个简单的宏的实际用途：正则表达式！让我们来亲身体验一下。</p>

<p>我们的标准库中最基本的正则函数是<code>regex:match</code>和<code>regex:new</code>。<code>regex:match</code>返回一个所有匹配正则表达式<code>(foo)</code>的列表（list）。</p>

<pre><code>print regex:match regex:new <span class="s">"(abc)"</span>
                  <span class="s">"abc"</span>
</code></pre>

<p>到目前为止我们已经算得上是宏的<strong><em>高玩</em></strong>了，所以，来看看更漂亮的写法是什么样的：</p>

<pre><code><span class="kr">defun</span> ~~ regex string
      regex:match regex
                  string

print ~~ regex:new <span class="s">"(def)"</span>
         <span class="s">"defghi"</span>
</code></pre>

<p>元芳，你怎么看？还不错吧？至少要做一个字符串匹配所需的代码变得更短了。不过构造正则表达式的语法仍然显得有些笨重。让我们来创建一个宏！</p>

<pre><code><span class="kr">defmacro</span> rx input
         ++ <span class="s">"regex:new "</span>
            <span class="kt">z:string</span> input

print ~~ rx <span class="s">Age: (.*)</span>
         <span class="s">"Age: 123"</span>
</code></pre>

<p>稍微美观了些，但是还算不上<strong><em>碉堡</em></strong>。</p>

<p>我们或许可以跳过整个构造正则表达式的部分，把它与匹配的部分合并：</p>

<pre><code><span class="kr">defmacro</span> ~ input
         <span class="kr">fn</span> blocks
            ++ <span class="s">"~~ rx"</span>
               ++ <span class="kt">z:indent-before</span> 6
                                  unlines init blocks
                  ++ <span class="s">"\n"</span>
                     <span class="kt">z:indent</span> 3
                              last <span class="s">""</span>
                                   blocks
            <span class="kt">z:blocks</span> input

print ~ <span class="s">Age: (.*)</span>
        <span class="s">"Age: 666"</span>
</code></pre>

<p><strong><em>现在</em></strong>我们才算是真正完成了屌丝的逆袭！这语法看起来就像是从矮穷挫瞬间变成了高富帅有木有！</p>

<pre><code>print ~ <span class="s">Age: (.*)</span>
        <span class="s">([a-z]+)</span>
        <span class="s">"Age: 777\nlalala"</span>
</code></pre>

<p>更加高能的是，你甚至可以把正则表达式分开在多行写。卧槽，既然这么给力，再来和正则战个痛又如何？</p>

<pre><code>print ~ <span class="s">Age: (.*)</span>
        <span class="s">([a-z]+)</span>
        : <span class="s">Age: 999</span>
          <span class="s">beep!</span>
</code></pre>

<p>当然，它也可以与其它的宏在一起搭配使用。<del>管他后面这句话是什么意思反正翻译君是不想翻了。</del></p>

<h3>代码编辑</h3>

<p>Z-表达式的另外一个撸点是，对它进行文本编辑几乎毫无鸭梨。试问：你如何才能在Lisp或者其他类似语言中找到当前语义节点的起始和终止位置？</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="nf">lorem</span> <span class="nv">ipsum-lorem-ipsum</span> <span class="p">()</span>
  <span class="p">(</span><span class="nf">foo-bar</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">zot</span> <span class="p">(</span><span class="nf">biff-pop</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">zar-zar</span> <span class="p">(</span><span class="nf">beep</span> <span class="s">&quot;%s.bill&quot;</span> <span class="nv">bob</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">ben-bill-bocky</span> <span class="nv">doo-dar</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">let*|</span> <span class="p">((</span><span class="nf">foo</span> <span class="p">(</span><span class="nf">foo-bar-mu-zot</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">bar</span> <span class="p">(</span><span class="nf">ipsum-lorem</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">ipsum</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;cakes</span> <span class="nv">lorem</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">lorem</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;potato</span> <span class="nv">lorem</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">ipsum</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;ipsum</span> <span class="nv">lorem</span><span class="p">)))</span>
               <span class="p">(</span><span class="nf">lorem</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assoc </span><span class="ss">&#39;lorem</span> <span class="nv">lorem</span><span class="p">))))</span>
          <span class="p">(</span><span class="k">if </span><span class="nv">bob</span>
              <span class="p">(</span><span class="nf">progn</span>
                <span class="p">(</span><span class="nf">bill</span> <span class="nv">ben</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">the</span> <span class="nv">cake</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">lie</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">the</span> <span class="nv">game</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Structural integrity is not secured.&quot;</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Data, because it&#39;s polite.&quot;</span> <span class="nv">cakes</span><span class="p">))))</span>
</code></pre></div>

<p>如果你的光标刚好处在<code>let</code>之后，你会怎样做？老套路。你开始搜寻一个标志着起始的左括号。你找到了它。然后你开始向后移，搜寻一个标志结束的右括号。每次当遇到一个左括号，你把它压入栈中。每次当遇到一个右括号，你把它从栈中弹出。一旦遇到了一个字符串的开始，或者是转义字符序列，你将需要等待再次遇到下一个非转义字符，然后继续……呃，你开始感到乏味了吗？其实我也这么想。我以为我能轻易地办到这件事情，但事实上并非如此。<em>（翻译君：Emacs下难道没有方便定位Lisp代码的插件吗？我什么都不知道……）</em></p>

<p>在Z中，一切都变得如此简单。你只需找到起始的列，根据第一个非空格字符的位置。然后上下移动光标，找到与其缩进的起始列位置不同的行，那就是当前语义块起始或终止之处。你将拥有整个Z-表达式。想要移动它？小菜一碟，只需要剪切和粘贴、之后根据偏移增添或删减前置空格即可。担心缩进风格？在Z中它算不上什么问题。就像不存在缩进风格这回事一样。Z自始至终只有一种缩进方式。</p>

<h3>未来的工作</h3>

<h4>反引号（Quasiquotations）</h4>

<p>若不借鉴前人的历史，我们必将一事无成。Lisp有着悠久的历史，它教给了我们引号和反引号，以及借助于它们来处理字符串是多么便捷。我同意这一点。这就是为什么在下一步，我打算实现这样的语法：</p>

<pre><code><span class="kr">defmacro</span> when cond body
         <span class="kr">`</span> if <span class="kr">,</span> cond
              <span class="kr">,</span> body
              unit
</code></pre>

<p>当然，它遵从与所有Z-表达式相同的语法模式，但却与Lisp具有相同的语义。无论如何，这仅仅只是一个语法糖而已。Z的真正威力体现在它通过缩进来划分代码的语义区域上。</p>

<h4>“数学”宏</h4>

<p>在Z中，你使用多参数函数时需要用到缩进。这在做某些数学计算的时候多少有些蛋疼，因为数学表达式的参数通常只是一些简单的、同序的子表达式。考虑到这一点，拥有一套数学宏是完全必要的。例如，<code>#</code>：</p>

<pre><code><span class="kr">def</span> x # x²-y²×(2xy+x²-y²×(2xy+c))
</code></pre>

<p>为什么不呢？<em>（翻译君数死早，没看出来这个式子是要干啥= =）</em></p>

<hr>

<h2>安装入门</h2>

<h3>实现</h3>

<p><a href="https://github.com/chrisdone/z">这里</a>是Z的官方解释器。</p>

<h4>安装</h4>

<p>Z解释器当前使用Haskell实现。你可以在<a href="http://www.haskell.org/platform/">这里</a>下载Haskell。</p>

<p>Haskell安装完成后，编译Z的解释器：<em>（翻译君：你可能需要自行用包管理器安装<a href="http://hackage.haskell.org/package/text">text</a>和<a href="http://hackage.haskell.org/package/parsec">parsec</a>）</em></p>
<div class="highlight"><pre><code class="text">$ cd &lt;path/to/z/dir&gt;
$ ghc Setup.hs
$ ./Setup configure
$ ./Setup build
</code></pre></div>
<p>生成的二进制文件位于<code>dist/build/z/z</code>。</p>

<p>运行它，可以交互式地对Z语句进行求值。</p>

<p>若要执行一个完整的Z源文件，可以通过管道：</p>
<div class="highlight"><pre><code class="text">$ ./dist/build/z/z &lt; examples.zz
</code></pre></div>
    </article>
    
    
    <article id="articlePost" style="padding-bottom: 0">
        <div id="divDisqus">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_shortname = 'soimort';
                
                var disqus_url = 'http://www.soimort.org/posts/132/index.html';
                
                
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
    </article>
    
</div>


</body>
</html>
