<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Mort Yao</title>
    <link href="http://www.soimort.org/atom.xml" rel="self" />
    <link href="http://www.soimort.org" />
    <updated>2013-02-26T23:09:14+08:00</updated>
    <id>http://www.soimort.org</id>
    <author>
        <name>Mort Yao</name>
        <email>mort.yao@soimort.org</email>
    </author>
    
    
    <entry>
        <title>【译文】Ruby 2.0来啦！</title>
        <link href="http://www.soimort.org/posts/140" />
        <updated>2013-02-23T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/140/ruby2</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;https://speakerdeck.com/shyouhei/whats-new-in-ruby-2-dot-0&quot;&gt;What&amp;#39;s New in Ruby 2.0&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/shyouhei&quot;&gt;Urabe Shyouhei&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;strong&gt;Mort Yao&lt;/strong&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;本月24日（也就是明天）Ruby 2.0终于就要发布了。&lt;/p&gt;

&lt;p&gt;Ruby核心团队的卜部昌平桑昨天在&lt;a href=&quot;https://twitter.com/hidek/status/304882370690023425&quot;&gt;一个内部学习会上的presentation&lt;/a&gt;，介绍了Ruby 2.0所包含的一些新特性。&lt;/p&gt;

&lt;p&gt;（本文内容选译自该幻灯片。）&lt;/p&gt;

&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;298bdc605efb013056301231381ff75d&quot; data-ratio=&quot;1.78086956521739&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;

&lt;hr&gt;

&lt;h2&gt;为什么有Ruby 2.0？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为我们在改变事物。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们渴望让自己变得越来越快乐、健康、以及高产。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不必畏惧。“拥抱变化。”&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ruby 2.0有什么新鲜的？&lt;/h2&gt;

&lt;h3&gt;什么&lt;u&gt;不是&lt;/u&gt;Ruby 2中的新鲜货&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;几乎所有的东西。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“100%后向兼容”，matz如是说。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在现实中……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（举个例子来说）Rails仍然能完好运行如初。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;也就是说，&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新的东西被加进来了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;许多内部的东西得到了改进。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ruby 2.0的新句法&lt;/h2&gt;

&lt;h3&gt;关键字参数（Keyword arguments）&lt;/h3&gt;

&lt;p&gt;下面的代码在1.x中能够正常工作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:lots&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;of&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;ss&quot;&gt;:args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;in&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;ss&quot;&gt;:hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;form&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，问题出在哪呢？&lt;/p&gt;

&lt;p&gt;问题是在定义该方法的时候：
&lt;strong&gt;&lt;em&gt;（Mort注：在Ruby 1.x中，只能将多个带符号名称的参数作为一个Hash来传递给方法。要为参数指定默认值，实现起来就很累赘，参见如下代码）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lots&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:lots&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;another&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;hand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;annoying&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到代码中错误的&lt;code&gt;Hash[:by hand]&lt;/code&gt;——&lt;strong&gt;手写代码是错误产生的根源！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从2.0开始，Ruby将引入&lt;strong&gt;关键字参数&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;a&lt;/code&gt;为固定参数，&lt;code&gt;b&lt;/code&gt;为可选参数，&lt;code&gt;c&lt;/code&gt;、&lt;code&gt;d&lt;/code&gt;则为关键字参数。这样，局部变量&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;都将被恰当地赋值。&lt;/p&gt;

&lt;p&gt;在调用函数时，原有的调用方式无需更改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mort注：虽然幻灯片里没有写，传统的基于Hash参数的调用方法是这个样子的&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;现在Ruby 2.0同时也支持直接采用关键字参数的调用方法：（Python程序员一定会觉得这种语法更亲切）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;更详细的示例，可以参考这里：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://brainspec.com/blog/2012/10/08/keyword-arguments-ruby-2-0/&quot;&gt;http://brainspec.com/blog/2012/10/08/keyword-arguments-ruby-2-0/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;其他细微的句法改进&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;引入了符号数组字面值&lt;code&gt;%i&lt;/code&gt;和&lt;code&gt;%I&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [:foo, :bar, :baz]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Ruby现在默认把所有的输入都视作UTF-8编码。当然你也可以显式地指定需要的编码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ruby 2.0的核心性能改进&lt;/h2&gt;

&lt;h3&gt;&lt;code&gt;require&lt;/code&gt;的改进&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景：今天，由于我们有了许多gems，启动Ruby有时甚至需要一次require 128+个库——这带来了糟糕的性能问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决：&lt;code&gt;require&lt;/code&gt;变得更快了（从计算复杂度的意义上来说）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若干技术被应用于减少多余的计算上。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Backtrace惰性生成&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;起初，backtraces只是字符串数组而已。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每当抛出异常时，这些字符串就被自上而下地生成出来，即使在它们没有实际用途的情况下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这导致了超乎寻常的低效，尤其是当你有1024+个stack frames时（这在Rails应用中很常见）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Ruby 2.x开始，&lt;code&gt;Thread::Backtrace&lt;/code&gt;被用来取代字符串。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它们非常地轻量级。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当你需要查看backtrace时，只需将它们转换成字符串即可（调用&lt;code&gt;#to_s&lt;/code&gt;）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Flonum类&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在64位平台（如今早就烂大街了）上，指针，整型和浮点型数均是64位宽度的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Ruby中，指针和整型均为C级别的&lt;code&gt;register&lt;/code&gt;寄存器变量。而&lt;code&gt;double&lt;/code&gt;却是存储在内存中的，如果我们能够如操作指针一样操作它们，将如何呢？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题：如何让一个指针和一个double共存于一个union中？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决：一些技巧性的位移。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mort注：图片懒得搬运了……请参见原幻灯片。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;GC（Garbage Collection）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bitmap标志：以前，GC标志位存储于每个对象中，但现在已经被转移到了专用的内存页中，以减少缓存的误查询（同时也更加CoW (Copy-on-Write)友好）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非递归标志：标志函数如今避免了机器栈溢出的风险。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;惰性清理（从1.9.3起）：清理器只有在必须的地方才进行收集（减少了stop时间）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ruby 2.0的新核心特性：#1 调试工具&lt;/h2&gt;

&lt;h3&gt;DTrace支持&lt;/h3&gt;

&lt;h3&gt;TracePoint支持&lt;/h3&gt;

&lt;h3&gt;GC stats&lt;/h3&gt;

&lt;h2&gt;Ruby 2.0的新核心特性：#2 核心库&lt;/h2&gt;

&lt;h3&gt;细粒度的异步中断处理&lt;/h3&gt;

&lt;p&gt;Ruby的执行有时会因为各种原因而中断，例如，超时。&lt;/p&gt;

&lt;p&gt;Ruby 2.0提供了细粒度的异步中断处理方案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_interrupt_timing&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;Timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
      &lt;span class=&quot;no&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async_interrupt_timing&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;Timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:immediate&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ensure&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;teardown&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;模块前插&lt;/h3&gt;

&lt;p&gt;有时候你想要给一个方法添加需要的安装或拆解代码，而相应的部分却定义在别处。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ActiveRecordHelper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;
    &lt;span class=&quot;sc&quot;&gt;??&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该如何去做呢？在Ruby 2.0中，你可以：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:Base&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;prepend&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;AR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:Helper&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AR::Helper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;no&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这避开了Rails中的所谓“别名方法链（alias method chain）”的困扰。AMC什么的已经不再必要了。&lt;/p&gt;

&lt;h3&gt;惰性枚举器&lt;/h3&gt;

&lt;p&gt;Ruby的&lt;code&gt;foo.bar.baz. ...&lt;/code&gt;风格（所谓的“流水作业”）有时会传递许多并不必要的临时对象，而这些理论上都可以通过惰性求值来避免。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 生成了临时数组&lt;/span&gt;
    &lt;span class=&quot;sr&quot;&gt;/regexp/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;each_with_index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 生成了临时数组&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;%d: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 生成了临时数组&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 没有临时数组产生&lt;/span&gt;
    &lt;span class=&quot;sr&quot;&gt;/regexp/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;each_with_index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 没有临时数组产生&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;%d: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 没有临时数组产生&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 甚至在到达EOF之前都不读取数据&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个有趣的应用实例：无穷枚举器。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# Leibniz formula for π&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:INFINITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lazy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65536&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;其他的新方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Kernel.__dir__&lt;/code&gt;：获取&lt;code&gt;__FILE__&lt;/code&gt;所在的目录名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kernel#to_h&lt;/code&gt;：通用的Hash转换方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Random&lt;/code&gt;类（1.9+）：可重复的PRNG。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO#wait_writable&lt;/code&gt;：等待直到可写。&lt;/li&gt;
&lt;li&gt;Refinements: 实验性的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Mort注：更多关于Ruby 2.0核心特性的介绍，参考&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://globaldev.co.uk/2012/11/ruby-2-0-0-preview-features&quot;&gt;http://globaldev.co.uk/2012/11/ruby-2-0-0-preview-features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/news/2012/11/ruby-20-preview1&quot;&gt;http://www.infoq.com/news/2012/11/ruby-20-preview1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Ruby 2.0标准库的改进&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CGI&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;CGI已经为HTML5做好了一切准备。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;net/http&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;支持SNI（Server Name Indication）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zlib绑定&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Zlib如今运行在解释器的进程锁之外。这意味着zlib在多线程的情形下运行速度将更快。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新的stdlibs（标准库）&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Rubygems 2.0.0&lt;/li&gt;
&lt;li&gt;JSON 1.7.7&lt;/li&gt;
&lt;li&gt;Rake 0.9.5&lt;/li&gt;
&lt;li&gt;Rdoc 4.0&lt;/li&gt;
&lt;li&gt;以及其它（REXML，yaml，openssl……）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;h3&gt;什么&lt;u&gt;不是&lt;/u&gt;Ruby 2中的新鲜货&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;几乎所有的东西！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“100%后向兼容”，matz如是说。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（举个例子来说）Rails仍然能完好运行如初。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;不必畏惧！开始使用2.0.0版吧！&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;也就是说，&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新的东西被加进来了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;许多内部的东西得到了改进。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即使你对你当前的环境充分自信，&lt;em&gt;2.0.0仍然值得你拥有。&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;Don&amp;#39;t be afraid. Use Ruby today!&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://jpopsuki.tv/js/embed.js.php?key=eb57d9ad12c4f7a324fc6854f673d40d&amp;amp;amp;app=frontend&amp;amp;amp;env=prod&amp;amp;amp;debug=false&amp;amp;amp;1361590282&quot;&gt;&lt;/script&gt;&lt;noscript&gt;&amp;lt;!-- Version SVN: $Id: &lt;em&gt;playerVideo.php 1267 2013-01-15 11:53:00Z sven.poeche $ --&amp;gt;&lt;div id=&quot;flash&quot;&gt;&lt;div id=&quot;flashcontent&quot;&gt;&amp;lt;object classid=&amp;quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&amp;quot; id=&amp;quot;flvplayer&lt;/em&gt;5128380abf3d4&amp;quot; name=&amp;quot;c6a80378-3eb2-47e7-8415-ba1f7cff037e&amp;quot; width=&amp;quot;720&amp;quot; height=&amp;quot;400&amp;quot; style=&amp;quot;position:relative;top:0;left:0;z-index:9998;&amp;quot;&amp;gt;&lt;param name=&quot;movie&quot; value=&quot;http://jpopsuki.tv/flash/vimp.swf&quot; /&gt;&lt;param name=&quot;flashvars&quot; value=&quot;hosturl=http%3A%2F%2Fjpopsuki.tv%2Fmedia%2Fflashcomm&amp;amp;mediaid=5581&amp;amp;context=embeded&amp;amp;skin=http%3A%2F%2Fjpopsuki.tv%2Fflash%2Fskins%2Fair_black.swf&amp;amp;autohidesidebaronplay=true&quot; /&gt;&lt;param name=&quot;scale&quot; value=&quot;true&quot; /&gt;&lt;param name=&quot;allowfullscreen&quot; value=&quot;true&quot; /&gt;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&lt;param name=&quot;wmode&quot; value=&quot;opaque&quot; /&gt;&amp;lt;!--[if !IE]&amp;gt;--&amp;gt;&lt;object type=&quot;application/x-shockwave-flash&quot; data=&quot;http://jpopsuki.tv/flash/vimp.swf&quot; width=&quot;720&quot; height=&quot;400&quot; wmode=&quot;opaque&quot;&gt;&lt;param name=&quot;flashvars&quot; value=&quot;hosturl=http%3A%2F%2Fjpopsuki.tv%2Fmedia%2Fflashcomm&amp;amp;mediaid=5581&amp;amp;context=embeded&amp;amp;skin=http%3A%2F%2Fjpopsuki.tv%2Fflash%2Fskins%2Fair_black.swf&amp;amp;autohidesidebaronplay=true&quot; /&gt;&lt;param name=&quot;scale&quot; value=&quot;true&quot; /&gt;&lt;param name=&quot;allowfullscreen&quot; value=&quot;true&quot; /&gt;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&lt;param name=&quot;wmode&quot; value=&quot;opaque&quot; /&gt;&amp;lt;!--&amp;lt;![endif]--&amp;gt;&lt;div class=&quot;leanback-player-video&quot;&gt;&lt;span id=&quot;flashcomm-url&quot;&gt;http://jpopsuki.tv/media/flashcomm?action=mediaview&amp;amp;context=embeded&amp;amp;id=5581&lt;/span&gt;&lt;video id=&quot;index_video&quot; width=&quot;720&quot; height=&quot;400&quot; preload=&quot;metadata&quot; controls poster=&quot;http://jpopsuki.tv/cache/1a7aa8c88cad0006b50d216d5f88cb7b.jpg&quot;&gt;&lt;source src=&quot;http://jpopsuki.tv/images/media/eb57d9ad12c4f7a324fc6854f673d40d_1361040059.mp4&quot; type=&quot;video/mp4&quot; /&gt;&lt;p style=&quot;margin: 15px;&quot;&gt;Hint: Unfortunately your browser does not have Flash Player installed or the Flash Player version is outdated. You need Flash Player to view media in this community. &lt;a href=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;Download Flash Player&lt;/a&gt;&lt;/p&gt;&lt;img alt=&quot;AKB48 - Ruby&quot; title=&quot;AKB48 - Ruby&quot; src=&quot;http://jpopsuki.tv/cache/1a7aa8c88cad0006b50d216d5f88cb7b.jpg&quot; /&gt;      &amp;lt;!--[if !IE]&amp;gt;--&amp;gt;&lt;/object&gt;&amp;lt;!--&amp;lt;![endif]--&amp;gt;&lt;/object&gt;&lt;/div&gt;&lt;/div&gt;&lt;/noscript&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3.2 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3.2" />
        <updated>2013-02-22T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3.2/0.3.2</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3.2&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3.2&quot;&gt;http://pypi.python.org/pypi/you-get/0.3.2&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Add support for JPopsuki (&lt;a href=&quot;http://jpopsuki.tv&quot;&gt;http://jpopsuki.tv&lt;/a&gt;)&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/92&quot;&gt;#92&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;J-Pop好き＼(^o^)／&lt;/p&gt;

&lt;h2&gt;Fix issue for Xiami&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/radaiming&quot;&gt;@radaiming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3.1 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3.1" />
        <updated>2013-02-15T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3.1/0.3.1</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3.1&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3.1&quot;&gt;http://pypi.python.org/pypi/you-get/0.3.1&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Fix issues for Google+&lt;/h2&gt;

&lt;p&gt;This release mainly fixed some issues related to Google+.
(&lt;a href=&quot;https://github.com/soimort/you-get/issues/103&quot;&gt;#103&lt;/a&gt;,
&lt;a href=&quot;https://github.com/soimort/you-get/issues/104&quot;&gt;#104&lt;/a&gt;,
&lt;a href=&quot;https://github.com/soimort/you-get/issues/106&quot;&gt;#106&lt;/a&gt; and
&lt;a href=&quot;https://github.com/soimort/you-get/issues/107&quot;&gt;#107&lt;/a&gt;)&lt;/p&gt;

&lt;h2&gt;Unit tests and Travis CI&lt;/h2&gt;

&lt;p&gt;If you are interested: You-Get is now employing the fantastic &lt;a href=&quot;http://travis-ci.org/soimort/you-get&quot;&gt;Travis CI&lt;/a&gt; for Continuous Integration. More unit test cases will be added in the future.&lt;/p&gt;

&lt;p&gt;That means, when (unluckily) the support for a video site is broken, I will get notified of it very soon, without anyone reporting an issue.&lt;/p&gt;

&lt;p&gt;Unit tests will be carried out on both Python &lt;strong&gt;3.2&lt;/strong&gt; and &lt;strong&gt;3.3&lt;/strong&gt;, but not on any other earlier versions of Python.&lt;/p&gt;

&lt;p&gt;Here is the current build status, which is hopefully green (nothing is broken and You-Get is scraping all video sites like magic):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/soimort/you-get&quot;&gt;&lt;img src=&quot;https://api.travis-ci.org/soimort/you-get.png&quot; alt=&quot;Build Status&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3.0：Niconico支持</title>
        <link href="http://www.soimort.org/posts/139" />
        <updated>2013-02-08T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/139/you-get</id>
        <content type="html">&lt;p&gt;喜闻&lt;a href=&quot;http://www.nicovideo.jp/&quot;&gt;Niconico站&lt;/a&gt;在墙内解封，为了满足春节期间广大天朝小学生的精♂神文化需求，我在这里高兴地宣布&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; 0.3.0版的发布：实现了对Niconico的支持。&lt;/p&gt;

&lt;p&gt;建议将登录信息保存在用户主目录下的&lt;code&gt;~/.netrc&lt;/code&gt;：（否则必须在每次下载时手动输入用户名和密码）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;machine nicovideo
  login your.email@address.com
  password your_password
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乡民们颤抖吧！！&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get http://www.nicovideo.jp/watch/sm20027310
Logging in...
Video Site: Nicovideo.jp
Title:      中华人民共和国国歌 [义勇军进行曲]
Type:       MPEG-4 video (video/mp4)
Size:       1.46 MB (1534925 Bytes)

Downloading 中华人民共和国国歌 [义勇军进行曲].mp4 ...
100.0% (  1.5/1.5  MB) [========================================] 1/1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3.0 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3.0" />
        <updated>2013-02-08T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3.0/0.3.0</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3.0&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3.0&quot;&gt;http://pypi.python.org/pypi/you-get/0.3.0&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Add support for Niconico&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/23&quot;&gt;#23&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  Downloads  you-get http://www.nicovideo.jp/watch/sm6129233
Logging in...
Video Site: Nicovideo.jp
Title:      【本格的♂ロック】 COLTPLAY - Vima la Vidan ～美マラ美男～ 【COLDPLAY!?】
Type:       MPEG-4 video (video/mp4)
Size:       12.81 MB (13437268 Bytes)

Downloading 【本格的♂ロック】 COLTPLAY - Vima la Vidan ～美マラ美男～ 【COLDPLAY!-】.mp4 ...
100.0% ( 12.8/12.8 MB) [========================================] 1/1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You may store your login and password in &lt;code&gt;~/.netrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;machine nicovideo
  login mort.yao@soimort.org
  password 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can manually input them when prompted.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>在命令行下使用Google Translate</title>
        <link href="http://www.soimort.org/posts/138" />
        <updated>2013-02-05T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/138/google-translate-cli</id>
        <content type="html">&lt;p&gt;所以说我还是发篇中文博介绍一下这个东西好了。貌似对其他人还蛮有用的样子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Translate CLI:&lt;/strong&gt; &lt;a href=&quot;http://www.soimort.org/google-translate-cli/&quot;&gt;http://www.soimort.org/google-translate-cli/&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;学习语言的时候，&lt;a href=&quot;http://translate.google.com/&quot;&gt;Google Translate&lt;/a&gt;是一大神器，可惜要免费的话，只能在浏览器里用。API什么的是要收费的，&lt;a href=&quot;https://developers.google.com/translate/v2/pricing&quot;&gt;每百万字20刀&lt;/a&gt;，当然还需要开发者自己注册API key，而且还有流量限额，真心麻烦……&lt;/p&gt;

&lt;p&gt;个人用户可能只是想在终端下查查单词短语翻译几个句子（尤其是对于我这样的重度命令行用户来说，实在是不想每次都开个浏览器标签去查啊）。如果Google Translate提供了一套命令行接口（或者至少是开放的不需要认证key的API）就会方便很多，显然，这件事情永远都不可能发生。&lt;/p&gt;

&lt;p&gt;还有，在文本编辑器里面翻译&lt;del&gt;&lt;a href=&quot;https://www.google.com/search?q=%E6%96%87%E6%98%A5&quot;&gt;#文春&lt;/a&gt;（误）&lt;/del&gt;文章的时候，每次切换到浏览器里去查效率太低了（何况安心干活的时候可能根本就不想去开浏览器，巨耗资源）。如果能在vim或者emacs里一键查看翻译的话，岂不妙哉？&lt;/p&gt;

&lt;p&gt;简而言之，想法就是在命令行下直接一个HTTP Request调用Google Translate来做翻译，不用浏览器，也不需要去用花钱的API key。&lt;/p&gt;

&lt;p&gt;以上是背景铺垫。&lt;/p&gt;

&lt;p&gt;以前的命令行工具差不多都是基于Google Translate的官方API，鉴于不要钱的API v1已经关闭了，目测它们已经失效（你总不能让用户去自己注册一个API key然后付了钱才能用你的工具吧……）&lt;/p&gt;

&lt;p&gt;写了一个简单的hack，直接裸调与浏览器访问Google Translate时相同的HTTP Request（不用Google提供的API，当然也不需要key），解析出翻译的结果。用不超过100行AWK脚本实现，只要系统上有&lt;a href=&quot;http://www.gnu.org/software/gawk/&quot;&gt;GNU Awk&lt;/a&gt;就能运行。不需要其他任何依赖库。&lt;/p&gt;

&lt;p&gt;什么？为什么要拿AWK来写？解决这种程度的小问题，Perl、Python、Ruby之类的也太重量级了吧&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/sn_0010.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;源码在这里： &lt;a href=&quot;https://github.com/soimort/google-translate-cli&quot;&gt;https://github.com/soimort/google-translate-cli&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/google-translate-cli.git
$ cd google-translate-cli/
$ make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（不想安装的话，直接调用&lt;code&gt;./translate.awk&lt;/code&gt;也可以）&lt;/p&gt;

&lt;p&gt;查看帮助：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;示例&lt;/h2&gt;

&lt;p&gt;翻译短语或句子：（默认任意语言转英文）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate ヘヴィー・ローテーション
Heavy Rotation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译多行句子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate &amp;quot;
&amp;gt; Das ist doch kein Geheimnis
&amp;gt; Nicht für dich und nicht für mich
&amp;gt; Das Leben ist oft hart
&amp;gt; Doch wir kämpfen - verlieren und gewinnen&amp;quot;

It&amp;#39;s no secret
Not for you and not for me
Life is often hard
But we fight - lose and win
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译不知道什么鸟语到中文：&lt;br&gt;
（参数格式：&lt;code&gt;{源语言=目标语言}&lt;/code&gt;，在源语言参数省略的情况下，让系统自动识别）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate {=zh} &amp;#39;UEFI Secure Boot is fun!&amp;#39;
UEFI安全启动是很好玩！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译中文到各国鸟语：&lt;br&gt;
（参数格式：&lt;code&gt;{源语言=目标语言1+目标语言2+...+目标语言n}&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate {zh=en+fr+de+sv+es} 挽尊
Pull the statue
tirez la statue
Ziehen Sie die Statue
dra statyn
Tire de la estatua
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看汉字的正确发音&lt;del&gt;（误）&lt;/del&gt;：&lt;br&gt;
（在语言代码前加上&lt;code&gt;@&lt;/code&gt;即可）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate {=@zh} 夜露死苦
Yèlù sǐ kǔ

$ translate {ja=@ja} 夜露死苦
Yoroshiku
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译一个文本文件：（到标准输出）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ translate {=zh} /usr/share/licenses/common/CCPL/cc-readme.txt
有6种不同的Creative Commons许可，所有这些都包括在内
在这licenses目录：

CC-BY- 3.0.txt - 署名
CC-BY- NC- 3.0.txt - 署名 - 非商业性使用
CC-BY- NC- ND- 3.0.txt - 署名 - 非商业性使用 - NoDerivs
CC-BY- NC- SA- 3.0.txt - 署名 - 非商业性使用 - 相同方式共享
CC-BY- ND- 3.0.txt - 署名 - 禁止演绎“
CC-BY- SA- 3.0.txt - 署名 - 相同方式共享

如果一个软件包使用这些许可证之一，它应该被引用如下：
许可（ CCPL ：BY- NC-SA “ ）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Vim一键翻译&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;.vimrc&lt;/code&gt;里加上一行（假定需要日文转罗马字发音+英文翻译）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;set keywordprg=trs\ {ja=@ja+en}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以在Vim中用&lt;code&gt;Shift-K&lt;/code&gt;召唤Google翻译娘，即时查看光标下对应单词的翻译了。是不是很方便？&lt;br&gt;
（基本上，这东西的便捷程度完全取决于你的网速……）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/OK2UYyn.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;参考链接&lt;/h2&gt;

&lt;p&gt;更多示例请参见：&lt;a href=&quot;http://www.soimort.org/google-translate-cli&quot;&gt;http://www.soimort.org/google-translate-cli&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Google Translate所使用的语言代码（地球人都知道的：&lt;code&gt;en&lt;/code&gt;，&lt;code&gt;fr&lt;/code&gt;，&lt;code&gt;de&lt;/code&gt;，&lt;code&gt;ru&lt;/code&gt;，&lt;code&gt;zh&lt;/code&gt;/&lt;code&gt;zh-CN&lt;/code&gt;，&lt;code&gt;zh-TW&lt;/code&gt;，&lt;code&gt;ja&lt;/code&gt;）&lt;br&gt;
详细列表可以参考这里：&lt;a href=&quot;https://developers.google.com/translate/v2/using_rest#language-params&quot;&gt;https://developers.google.com/translate/v2/using_rest#language-params&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/google-translate-cli&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20130201 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20130201" />
        <updated>2013-02-01T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20130201/0.3dev20130201</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20130201&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20130201&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20130201&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Add support for Mixcloud&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/91&quot;&gt;#91&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  Downloads  you-get -i http://www.mixcloud.com/beatbopz/beat-bopz-disco-mix/
Video Site: Mixcloud.com
Title:      風は吹いている (Beat Bopz Disco Mix)
Type:       MP3 (audio/mpeg)
Size:       10.23 MB (10724305 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Add support for Joy.cn (激动网)&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/86&quot;&gt;#86&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  Downloads  you-get -i http://ent.joy.cn/video/4244060.htm
Video Site: Joy.cn
Title:      非诚勿扰20130126：另类男7秒定终身 甜品师闻香识男人
Type:       Flash video (video/x-flv)
Size:       257.89 MB (270422435 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Add support for Facebook&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/74&quot;&gt;#74&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note: A recent upgrade of Facebook has broken this feature. Use the newest Git version instead.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  you-get git:(master) ✗ ./you-get -i \
&amp;gt; &amp;quot;https://www.facebook.com/photo.php?v=4837510389115&amp;quot;
Video Site: Facebook.com
Title:      20130126 TDC2013 29位：「わるきー」 渡辺美優紀
Type:       MPEG-4 video (video/mp4)
Size:       46.78 MB (49049898 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Python-romkan 0.0.2 Release Notes</title>
        <link href="http://www.soimort.org/projects/python-romkan/0.0.2" />
        <updated>2013-01-29T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/python-romkan/0.0.2/0.0.2</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;Python-romkan&lt;/a&gt; &lt;strong&gt;0.0.2&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/romkan/0.0.2&quot;&gt;http://pypi.python.org/pypi/romkan/0.0.2&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Fixed major conversion bugs&lt;/h2&gt;

&lt;h3&gt;Hepburn Romaji for &amp;quot;しゅ&amp;quot;&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;romkan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_hepburn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;しゅ&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;#39;shu&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Kunrei-shiki Romaji for &amp;quot;っしょ&amp;quot;&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;romkan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_kunrei&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;っしょ&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;#39;ssyo&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/python-romkan/pull/1&quot;&gt;#1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】Qt C++ API速成</title>
        <link href="http://www.soimort.org/posts/137" />
        <updated>2013-01-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/137/qt-api</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;https://plus.google.com/108138837678270193032/posts/PFi1ZC9kmmY&quot;&gt;Quick crash course in Qt C++ API&lt;/a&gt; by &lt;strong&gt;Thiago Macieira&lt;/strong&gt;&lt;br&gt;
(Chinese Translation by &lt;strong&gt;Mort Yao&lt;/strong&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;很长时间没写过Native GUI了（貌似有三年？），估计C++和Qt都忘了不少。正好看到&lt;a href=&quot;https://plus.google.com/108138837678270193032/posts/PFi1ZC9kmmY&quot;&gt;这条G+&lt;/a&gt;，觉得很有用，所以搬运过来。&lt;/p&gt;

&lt;p&gt;主要是帮助回忆起Qt（的C++ API）中一些容易忘记或者混淆的重要细节。&lt;/p&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;信号（signals）&lt;/strong&gt;和&lt;strong&gt;槽（slots）&lt;/strong&gt;：可以把它理解成其他GUI库中的M:N回调机制。（还有，不用在connect调用中写出参数的名称，只写出类型即可）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你需要信号或槽，去派生&lt;code&gt;QObject&lt;/code&gt;类；否则，你不必这么做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不是从&lt;code&gt;QObject&lt;/code&gt;派生而来的Qt类（诸如&lt;code&gt;QString&lt;/code&gt;、&lt;code&gt;QList&lt;/code&gt;和&lt;code&gt;QNetworkProxy&lt;/code&gt;）应该如同使用&lt;code&gt;int&lt;/code&gt;基本类型那样使用它们—— &lt;code&gt;new QString(&amp;quot;Hello&amp;quot;)&lt;/code&gt; =~= &lt;code&gt;new int(42)&lt;/code&gt; （隐式地共享，原子性的&lt;em&gt;写入时复制&lt;/em&gt;机制）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;QString&lt;/code&gt;存储人类语言的文本，而非任意的二进制数据（那是&lt;code&gt;QByteArray&lt;/code&gt;做的事情）；要用它来存储数据，你必须知道你使用的是何种编码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;QString&lt;/code&gt;和&lt;code&gt;QByteArray&lt;/code&gt;自动以空字符&lt;code&gt;&amp;#39;\0&amp;#39;&lt;/code&gt;结尾。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;信号（signal）&lt;/strong&gt;以动词&lt;del&gt;过去式&lt;/del&gt;&lt;u&gt;过去分词&lt;/u&gt;命名，通常指示着某个状态的改变。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;槽（slots）&lt;/strong&gt;以动词&lt;del&gt;现在式&lt;/del&gt;&lt;u&gt;原形&lt;/u&gt;命名，指示着某个将被执行的动作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;以名词或形容词命名；&lt;strong&gt;setter函数&lt;/strong&gt;以“set”作为前缀，&lt;strong&gt;getter函数&lt;/strong&gt;一般没有前缀（除了boolean量有时会以“is”作为前缀之外）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;事件（events）&lt;/strong&gt;并不是信号，它们通常用来指示来自外部的因素（例如键盘或鼠标动作）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何从&lt;code&gt;QWidget&lt;/code&gt;或&lt;code&gt;QWindow&lt;/code&gt;派生而来的可见的东西，只能够在GUI线程当中使用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;控件（widgets）&lt;/strong&gt;通过&lt;strong&gt;布局（layouts）&lt;/strong&gt;被放置在它们的父控件（parent widget）当中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Model-View类较复杂；请自行参考书籍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;QObject&lt;/code&gt;（因此也包含衍生的&lt;code&gt;QWidget&lt;/code&gt;）在析构时删除其所有子对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;QThread&lt;/code&gt;用来管理线程，它自身并不是线程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有的I/O函数（以及&lt;code&gt;QFile&lt;/code&gt;）是非阻塞的，被放在事件循环中执行操作，除了那些名字以“waitFor”打头的以外。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;QSocketNotifier&lt;/code&gt;在Unix上能够通过socket处理任何文件描述符，但在Windows中就只能用于真实的socket；如果你需要在Windows上等待某个事件发生，使用&lt;code&gt;QWinEventNotifier&lt;/code&gt;（Qt 5）或线程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;moc&lt;/code&gt;扩展&lt;code&gt;Q_OBJECT&lt;/code&gt;宏；如果你添加或删除了一个&lt;code&gt;Q_OBJECT&lt;/code&gt;，你也许需要告诉你的构建工具（qmake project）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;uic&lt;/code&gt;解析&lt;code&gt;.ui&lt;/code&gt;文件，创建一个&lt;code&gt;.h&lt;/code&gt;头文件，但这完全是可选的：你也可以自己手写UI。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20130125 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20130125" />
        <updated>2013-01-25T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20130125/0.3dev20130125</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20130125&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20130125&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20130125&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Dailymotion: default to the best quality&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/72&quot;&gt;#72&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;iQIYI (爱奇艺): fix &lt;a href=&quot;https://github.com/soimort/you-get/issues/77&quot;&gt;#77&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/77&quot;&gt;#77&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】反黑客法律是怎样把你变成一个罪犯的</title>
        <link href="http://www.soimort.org/posts/136" />
        <updated>2013-01-19T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/136/criminal</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://www.livescience.com/26383-are-you-looking-at-this-website-you-might-be-breaking-the-law.html&quot;&gt;How Computer-Hacking Laws Make You a Criminal&lt;/a&gt; by &lt;strong&gt;Paul Wagensil&lt;/strong&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;1970年，一个14岁的小男孩拨号连上了一个全国范围的网络，&lt;a href=&quot;http://www.notablebiographies.com/Fi-Gi/Gates-Bill.html&quot;&gt;上传了一个他写的病毒&lt;/a&gt;，并且造成了整个网络的瘫痪。&lt;/p&gt;

&lt;p&gt;那个男孩是Bill Gates。5年之后，他创办了Microsoft。&lt;/p&gt;

&lt;p&gt;几年以后，两个年轻人在加州的各大学宿舍间奔走，贩卖整盒整盒的电缆线，为学生们绕过电话公司的限制、免费拨打长途电话提供便利。&lt;/p&gt;

&lt;p&gt;这两个年轻人是Steve Jobs和Steve Wozniak，他们后来创造的企业，Apple，如今已成为世界上市值最高的公司之一。&lt;/p&gt;

&lt;p&gt;在2010年，另一位已经合伙创办了一个价值数百万的公司的年轻人，&lt;a href=&quot;http://www.technewsdaily.com/6998-aaron-swartz-arrest.html&quot;&gt;闯进了麻省理工学院的一个服务器间&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;他把一台笔记本挂上校园网络，下载了四百万篇学术论文，其中大多数是属于公有领域的，使用了他订阅的一个付费帐号。&lt;/p&gt;

&lt;p&gt;他被逮捕了，以多项欺诈罪名两次遭到指控，在四月份的审判中，即将面临50年的联邦监狱生涯和100万的罚金。&lt;/p&gt;

&lt;p&gt;这个年轻人的名字叫Aaron Swartz，上周他&lt;a href=&quot;http://www.technewsdaily.com/16364-anon-swartz-protest.html&quot;&gt;自己领便当去了&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;更多的计算机——更多的检控&lt;/h2&gt;

&lt;p&gt;导致Gates、Jobs和Wozniak们与Swartz截然相反的命运的直接原因，是&lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_Fraud_and_Abuse_Act&quot;&gt;计算机欺诈和滥用法案（Computer Fraud and Abuse Act）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;CFAA是一项1986年的法案。根据联邦刑法典第1030节，任何未经授权而访问一个受保护的网络或计算机的举动均被定义为联邦犯罪行为，将会导致严厉的处罚。&lt;/p&gt;

&lt;p&gt;但1986年已经是很久以前了。今天，任何Web服务器都可以称得上是一个“受保护的”计算机，几乎任何行为都可以被定义为“非经授权的”访问。&lt;/p&gt;

&lt;p&gt;使用你室友的Netflix帐号在iPad上看电影？你已经违反了CFAA法令。&lt;/p&gt;

&lt;p&gt;截取纽约时报网站上文章的URL，便于自己能够免费阅读它们？那么你就违犯了联邦法案。（译者注：使用&lt;a href=&quot;http://www.soimort.org/you-get/&quot;&gt;这样的工具&lt;/a&gt;去下载视频理所当然也是触犯美帝法律的——不要怪我没有提醒过你们）&lt;/p&gt;

&lt;p&gt;在你的工作时间查看Facebook，在你的雇主禁止这么做的情况下？准备好去找你的律师吧。&lt;/p&gt;

&lt;p&gt;如果以上这些听起来很荒谬，那么这里有一个事实：Andrew &amp;quot;Weev&amp;quot; Auernheimer，一个著名的“&lt;a href=&quot;http://en.wikipedia.org/wiki/Grey_hat&quot;&gt;灰帽黑客&lt;/a&gt;”，&lt;a href=&quot;http://www.technewsdaily.com/15581-hacker-found-guilty-despite-not-hacking-ipad.html&quot;&gt;在十一月份的时候被指控犯有欺诈罪&lt;/a&gt;，原因是从一个公开的服务器中批量抓取数据。他在下个月的审判中可能会面临最高长达10年的监禁。&lt;/p&gt;

&lt;p&gt;那些Auernheimer和他的朋友（后来站在他的反面作证）所下载的数据，事实上是没有任何密码保护的。他们所做的只是修改URL中的数字，按下“回车”而已。但根据CFAA，他们所做的已经构成了犯罪行为。&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;http://www.technewsdaily.com/15610-ipad-hacker-guilty-security-research.html&quot;&gt;安全专家引爆了iPad黑客的“寒蝉”效应&lt;/a&gt;]&lt;/p&gt;

&lt;h2&gt;回到未来&lt;/h2&gt;

&lt;p&gt;“这些犯罪的罚则与所在列的罪行极大地不相称。”Adam Goldstein，Arlington&lt;a href=&quot;http://en.wikipedia.org/wiki/Student_Press_Law_Center&quot;&gt;学生新闻法律中心&lt;/a&gt;的一位律师指出，“这些法律完全是针对20世纪80年代那些危害甚大的&lt;a href=&quot;http://www.technewsdaily.com/2888-hacking-new-breed.html&quot;&gt;恶意入侵网络的情形&lt;/a&gt;而制定的。”&lt;/p&gt;

&lt;p&gt;而Robert Graham，亚特兰大Errata Security公司的CEO认为，CFAA“令人绝望地不合时宜，它几乎可以被用来处罚任何人所做的任何事情。”&lt;/p&gt;

&lt;p&gt;“问题在于‘授权’这个词的含义，”Graham说，“在1986年的时候，任何人想要被显式地授权使用一台电脑，都需要通过一个事先分配的用户名与&lt;a href=&quot;http://www.technewsdaily.com/2347-how-to-create-remember-super-secure-passwords.html&quot;&gt;密码&lt;/a&gt;。”（译者注：无关小知识：Richard Stallman在MIT人工智能实验室工作期间破解了当时MIT所使用的权限系统，然后给所有用户发去信息，建议直接采用回车键作为密码——当时大约有20%的人听从了他的建议。那还是在1977年。）&lt;/p&gt;

&lt;p&gt;“在今天，得益于Web，我们可以访问计算机中的信息而完全无须顾及自己授权与否，”他补充道，“当你点击一个URL时，从技术上讲你就违反了这个法律，正如它当初所设计的那样。”&lt;/p&gt;

&lt;p&gt;Swartz将要面临的牢狱之灾已经远超过了他假如犯下一个物理上更为严重的罪行，诸如殴打、爆窃、严重盗窃或过失杀人罪，所可能面临的最高年数。&lt;/p&gt;

&lt;p&gt;“对于电子形式的犯罪处罚更加严厉，这根本毫无道理，”Chester Wisniewski，一名在英国安全公司Sophos不列颠哥伦比亚温哥华办公室工作的高级安全分析师说，“这些惩罚比起通常的偷窃罪来，简直更接近于谋杀罪。”&lt;/p&gt;

&lt;p&gt;“联邦刑法中存在着一个严重的问题，对使用计算机的犯罪行为的处罚之严厉程度，奇葩地与它们所造成的实际伤害远不成比例。”Hanni Fakhoury，旧金山电子前哨基金会的一位常任律师指出。&lt;/p&gt;

&lt;p&gt;“我们制定法律，本意是要惩治William Gibson（译注：赛博朋克作家，《神经漫游者》作者）小说里出现的那些邪恶的网络魔鬼，”Goldstein说，“我们却在向那些只是下载期刊文章和从冠希老师那里偷偷拷贝艳照的人挥舞着大棒。”&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本故事由TechNewsDaily提供。&lt;/em&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20130118 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20130118" />
        <updated>2013-01-18T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20130118/0.3dev20130118</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20130118&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20130118&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20130118&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;YinYueTai: default to the best quality&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/63&quot;&gt;#63&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get -i http://www.yinyuetai.com/video/585356
Video Site: YinYueTai.com
Title:      キリギリス人 中日字幕版 - No3b
Type:       MPEG-4 video (video/mp4)
Size:       107.19 MB (112394520 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sohu: fix &lt;a href=&quot;https://github.com/soimort/you-get/issues/69&quot;&gt;#69&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/69&quot;&gt;#69&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Horseshit：一个帮助克服拖延症的小工具</title>
        <link href="http://www.soimort.org/posts/134" />
        <updated>2013-01-15T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/134/horseshit</id>
        <content type="html">&lt;p&gt;&lt;em&gt;The real productivity problem people have is procrastination. It’s something of a dirty little secret, but everyone procrastinates — severely. It’s not just you. But that doesn’t mean you shouldn’t try to stop it.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What is procrastination? To the outside observer, it looks like you’re just doing something “fun” (like playing a game or reading the news) instead of doing your actual work.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;—— &lt;a href=&quot;http://www.aaronsw.com/&quot;&gt;Aaron Swartz&lt;/a&gt;, &lt;a href=&quot;http://www.aaronsw.com/weblog/productivity&quot;&gt;HOWTO: Be more productive&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;我们中的许多人多多少少都经历过这样的循环：面对着浏览器，习惯性地&lt;code&gt;Ctrl-T&lt;/code&gt;打开一个新的标签页，敲下常去网址的首字母然后回车，只为了看看有没有啥新鲜事发生。也许什么都没有；没有任何自己感兴趣的新东西出现。好，关掉这个标签页。几分钟后，你再一次重复了上述的动作，这一次，你看到了一条惊人的业界新闻，社交网络上开始各种刷屏，于是你也跟风转发了一条，附上一条充不无机智风趣的评论。过了几分钟，你又一次打开这个页面，只为了看看有没有好友的回复。什么都没有。你失望地关掉标签页，决定不再理会它，去做一些正经事。半个小时后，终于有人回复你了。当然你在此期间也没闲着，因为你已经看完了一个别人分享的恶搞视频，右键了某论坛上的几十张福利图，津津有味地读完了人人网上男默女泪的2012年经典网络语录和豆瓣上如假包换黑木耳文艺女青年写的一篇《教你如何识别好男银》，回复了某技术论坛上一篇题为《C++是最好的语言！》的帖子，最后，你可能还看了一篇教你“&lt;a href=&quot;#&quot;&gt;如何克服拖延症&lt;/a&gt;”的博客，你觉得这文章实在太尼玛有用了；当然更有可能的是，你只是分享了它或者把它收藏了下来，实际上你压根就没有耐性把这篇文章读完。不知不觉，你已经在电脑前坐了两个多小时。却没有干成任何正经事。&lt;/p&gt;

&lt;p&gt;这是一个无解的死循环，除非你认识到，每天我们在网络上所能接触到的信息，99.99%都和我们自身毫无关系，即使是那些“看起来”似乎有用的东西。在你利用它们创造出自己的价值之前，所有的信息都是无用的垃圾。仅此而已。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;废话不多说，几天前，我在Google+上发现有&lt;a href=&quot;https://plus.google.com/113127438179392830442/posts/iGXSXyJbrz1&quot;&gt;菊苣&lt;/a&gt;通过修改&lt;code&gt;hosts&lt;/code&gt;把域名直接定向到&lt;code&gt;127.0.0.1&lt;/code&gt;的小技巧，来控制自己可以访问的网站。当然，手动修改太麻烦了，所以就有人写了这个叫做&lt;a href=&quot;https://github.com/leftnode/get-shit-done&quot;&gt;get-shit-done&lt;/a&gt;的脚本，用来管理自己的&lt;code&gt;hosts&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;原来的代码有Shell、PHP和Python三种语言的版本，其中那个Python的脚本写得很有问题，无法在Arch Linux上正常使用。于是就有了这个我自己的fork：&lt;a href=&quot;http://packages.python.org/horseshit/&quot;&gt;Horseshit&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;通过Pip安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ pip install horseshit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接使用Git版本，不过要自己处理&lt;code&gt;$PATH&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/horseshit.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;/etc/horseshits&lt;/code&gt;（Windows貌似可以放在用户文件夹下的&lt;code&gt;.config/horseshits&lt;/code&gt;——我自己没测试过）来指定在工作时需要封杀的站点列表，举例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;plus.google.com
twitter.com
reader.google.com
reddit.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切换到工作模式：（自动修改系统的&lt;code&gt;hosts&lt;/code&gt;，把&lt;code&gt;horseshits&lt;/code&gt;中指定的站点全部给封杀掉）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo get-shit-done work
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切换回娱乐模式：（返回正常状态的&lt;code&gt;hosts&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo get-shit-done play
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要的话，你可以把上面两条命令放到&lt;code&gt;crontab&lt;/code&gt;里，给自己固定一天中的工作时间段和娱乐时间段。&lt;/p&gt;

&lt;p&gt;稍微详细一点的说明请参考&lt;a href=&quot;http://packages.python.org/horseshit/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;我希望这个东西能有点用。当然，首先它要对我自己起作用才行。&lt;/p&gt;

&lt;p&gt;先试用一段时间。如果还是没有自控能力的话，就只能动用物理断网这种终极手段了咩。&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/baodong/b_0023.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Horseshit&#58; a small script to configure your hosts and help you get shit done</title>
        <link href="http://www.soimort.org/projects/horseshit/0.0.2" />
        <updated>2013-01-14T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/horseshit/0.0.2/0.0.2</id>
        <content type="html">&lt;p&gt;&lt;strong&gt;horseshit&lt;/strong&gt; is an easy-to-use command line program that blocks websites known to distract us from our work, which is forked from &lt;a href=&quot;https://github.com/leftnode/get-shit-done&quot;&gt;leftnode/get-shit-done&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike &lt;strong&gt;get-shit-done&lt;/strong&gt;, &lt;strong&gt;horseshit&lt;/strong&gt; is implemented in Python only, with both 2.x/3.x compatibility. &lt;strong&gt;horseshit&lt;/strong&gt; is also a PyPI package, so that it can be installed and updated via &lt;code&gt;pip&lt;/code&gt; or &lt;code&gt;easy_install&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Project homepage: &lt;a href=&quot;http://www.soimort.org/horseshit&quot;&gt;http://www.soimort.org/horseshit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Fork me on GitHub: &lt;a href=&quot;https://github.com/soimort/horseshit&quot;&gt;https://github.com/soimort/horseshit&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;h3&gt;1. Using the PyPI package:&lt;/h3&gt;

&lt;p&gt;Install the PyPI package:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ pip install horseshit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ easy_install horseshit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. Using Git:&lt;/h3&gt;

&lt;p&gt;Clone the Git repository:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/horseshit.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After cloning this repository, you may want to put it in your &lt;code&gt;$PATH&lt;/code&gt; and ensure it is executable.&lt;/p&gt;

&lt;h2&gt;Usage&lt;/h2&gt;

&lt;h3&gt;1. Setting horseshits&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;horseshits&lt;/code&gt; is a no-brainer plain text file contains a load of horseshits that may distract you from work, line by line.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;plus.google.com
twitter.com
reader.google.com
reddit.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Also there is an example of what &lt;code&gt;horseshits&lt;/code&gt; should be like in: &lt;code&gt;horseshits.example&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On *nix systems, put your &lt;code&gt;horseshits&lt;/code&gt; into:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;/etc/horseshits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can simply use the example I provided if you&amp;#39;d like:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;sudo cp horseshits.example /etc/horseshits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or start writing your own:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;sudo vi /etc/horseshits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On Windows, put it into your own user directory:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;.config/horseshits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. To get-shit-done&lt;/h3&gt;

&lt;p&gt;Execute &lt;code&gt;get-shit-done&lt;/code&gt; as root because it modifies your hosts file and restarts your network daemon.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo get-shit-done work
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. To no longer get-shit-done&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo get-shit-done play
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Additional Tips&lt;/h2&gt;

&lt;p&gt;You can, of course, use &lt;code&gt;get-shit-done&lt;/code&gt; with your &lt;code&gt;crontab&lt;/code&gt;, to control your work time and play time during the day. Whatever, I should say self-control is always the best.&lt;/p&gt;

&lt;h2&gt;Acknowledgement&lt;/h2&gt;

&lt;p&gt;Thanks to Vic Cherubini, the original author of &lt;strong&gt;get-shit-done&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to myself. It finally comes to me that I have to stop my goddamned procrastination and increase focus NOW - for a proper work efficiency.&lt;/p&gt;

&lt;p&gt;Shit kickin&amp;#39; productivity!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/horseshit&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20130111 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20130111" />
        <updated>2013-01-11T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20130111/0.3dev20130111</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20130111&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20130111&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20130111&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Add support for 163.com (网易)&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/59&quot;&gt;#59&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; is now capable of downloading videos from &lt;a href=&quot;http://v.163.com&quot;&gt;v.163.com&lt;/a&gt; &lt;strong&gt;(网易视频)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Specifically, &lt;a href=&quot;http://open.163.com&quot;&gt;open.163.com&lt;/a&gt; &lt;strong&gt;(网易公开课)&lt;/strong&gt; is well supported:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get -i http://v.163.com/movie/2008/7/7/Q/M6SIM7VT5_M6SIQI67Q.html
Video Site: 163.com
Title:      斯坦福大学公开课：抽象编程_抽象编程第1课_网易公开课
Type:       MPEG-4 video (video/mp4)
Size:       85.35 MB (89492265 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;YouTube short URLs&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/62&quot;&gt;#62&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is now possible to download YouTube videos using their short URLs (&lt;a href=&quot;http://youtu.be&quot;&gt;youtu.be&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get -i youtu.be/8PQiaurIiDM
Video Site: YouTube.com
Title:      Chinese War Sword : Cold Steel Swords
Type:       WebM video (video/webm)
Size:       84.13 MB (88215104 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Vimeo: default to the best quality&lt;/h2&gt;

&lt;p&gt;Closed Issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/58&quot;&gt;#58&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>坑爹的课程项目之Arduino合成器</title>
        <link href="http://www.soimort.org/posts/133" />
        <updated>2013-01-09T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/133/arduino-synth</id>
        <content type="html">&lt;p&gt;最近的拖延症愈发严重了。比如电路考试前一天晚上开始通宵预习，比如在线课程总是赶在作业截止时间前一天晚上通宵看完视频，比如实验课前一天晚上通宵补程序，诸如此类的。（喂喂其实从三年前起这毛病就一直没改好么）&lt;/p&gt;

&lt;p&gt;然后是这个圣诞节前就布置下来的Arduino项目，周一要做presentation了居然拖到周日晚上才开始做，&lt;del&gt;真是都不知道自己平时在干嘛。。。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;虽然早就想好了要做一个合成器+MIDI sequencer，实现以下种种功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用USB键盘作为输入（通过一个USB shield）。&lt;/li&gt;
&lt;li&gt;借助MIDI shield合成音频并输出。&lt;/li&gt;
&lt;li&gt;Arduino与计算机进行串口通信，能够输出MIDI序列。&lt;/li&gt;
&lt;li&gt;在计算机上实现MIDI序列的可视化。（Java + Processing或Node.js + Processing.js）&lt;/li&gt;
&lt;li&gt;把“计算机”从笔记本替换成Raspberry Pi。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果因为只剩下一个晚上的时间，根本连一项功能也没实现(´д`;)&lt;/p&gt;

&lt;p&gt;因为这门课程项目的打分只有G（通过）和U（不通过）两个等级，要求很简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有Input / Output。&lt;/li&gt;
&lt;li&gt;有A/D转换。&lt;/li&gt;
&lt;li&gt;有中断。&lt;/li&gt;
&lt;li&gt;（可选）用Processing可视化串口输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再看看自己手头现有的材料，最终决定做的坑爹项目如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用触点传感器做输入，扬声器做输出。I/O有了。&lt;/li&gt;
&lt;li&gt;把传感器的按压位置对应到&lt;a href=&quot;http://www.arduino.cc/en/Tutorial/Melody&quot;&gt;音频的频率&lt;/a&gt;，A/D也有了。&lt;/li&gt;
&lt;li&gt;中断什么的加个按钮，按一下开始播放“两只老虎”。（音符和频率的转换参考了&lt;a href=&quot;http://en.wikipedia.org/wiki/Note&quot;&gt;这里&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Processing可做可不做。于是果断不做。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成的代码在这里：&lt;a href=&quot;https://github.com/soimort/Arduino-Synth&quot;&gt;https://github.com/soimort/Arduino-Synth&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;做展示的时候老师问我做这个东西用了多长时间，我说一个周末。。。&lt;/p&gt;

&lt;p&gt;一个同学说他也告诉老师花了一个周末的时间其实他只花了五六个小时（其中写代码用了半个小时）&lt;/p&gt;

&lt;p&gt;我就不好意思说我花了多长时间了wwwwww&lt;/p&gt;

&lt;p&gt;最后把&lt;a href=&quot;/slides/101&quot;&gt;幻灯片&lt;/a&gt;放上来，为了赶时间做得有点高桥流：（Chrome和Firefox可以&lt;a href=&quot;#&quot; id=&quot;fullScreenButton&quot;&gt;全屏模式观看&lt;/a&gt;）&lt;/p&gt;

&lt;style&gt;
#wrapper {
    width: 100%;
    height: 800px;
    
    background-color: #000;
    background-image: url('http://i.imgur.com/d7hIM.jpg');
    border-radius: 8px;
}

#presentation {
    transform: scale(0.5, 0.5);
    -webkit-transform: scale(0.5, 0.5);
    -moz-transform: scale(0.5, 0.5);
    -o-transform: scale(0.5, 0.5);
    
    transform-origin: top right;
    -webkit-transform-origin: top right;
    -moz-transform-origin: top right;
    -o-transform-origin: top right;
    
    float: right;
    
    border-radius: 8px;
    box-shadow: 0 0 8px 0 #102040;
}
&lt;/style&gt;

&lt;div id=&quot;wrapper&quot;&gt;
    &lt;iframe id=&quot;presentation&quot; src=&quot;/slides/101&quot; width=&quot;200%&quot; height=&quot;800px&quot; webkitAllowFullScreen mozallowfullscreen allowFullScreen &gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;script&gt;
// no mousewheel scrolling - not working in Firefox
$(&quot;#presentation&quot;).on(&quot;mousewheel DOMMouseScroll&quot;, function(e) {
    e.preventDefault();
});

// WebKit
document.addEventListener(&quot;webkitfullscreenchange&quot;, function () {
    if (document.webkitFullscreenElement)
        $('#presentation').css('transform','scale(1, 1)');
    else
        $('#presentation').css('transform','scale(0.5, 0.5)');
}, false);

// Firefox
document.addEventListener(&quot;mozfullscreenchange&quot;, function () {
    if (document.mozFullScreen)
        $('#presentation').css('transform','scale(1, 1)');
    else
        $('#presentation').css('transform','scale(0.5, 0.5)');
}, false);

function toggleFullScreen() {
    var elem = document.getElementById(&quot;presentation&quot;);
    
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    }
};

$(&quot;#fullScreenButton&quot;).click(function() {
    toggleFullScreen();
});

&lt;/script&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20130104 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20130104" />
        <updated>2013-01-04T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20130104/0.3dev20130104</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20130104&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20130104&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20130104&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This release enhanced the support for Sohu.&lt;/p&gt;

&lt;h2&gt;Enhance support for Sohu&lt;/h2&gt;

&lt;p&gt;You-Get now supports downloading from 搜狐视频空间（&lt;a href=&quot;http://my.tv.sohu.com/&quot;&gt;http://my.tv.sohu.com/&lt;/a&gt;）.&lt;/p&gt;

&lt;h2&gt;Default to download the best quality from Sohu&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/twlz0ne&quot;&gt;@twlz0ne&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】Z：一种基于Z-表达式的新语言</title>
        <link href="http://www.soimort.org/posts/132" />
        <updated>2013-01-03T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/132/z</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://chrisdone.com/z/&quot;&gt;A tiny language called Z&lt;/a&gt; by &lt;a href=&quot;http://chrisdone.com/&quot;&gt;Chris Done&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;翻译君的话&lt;/h2&gt;

&lt;p&gt;为了给了解一些Lisp的人节省时间：&lt;strong&gt;你可以把Z看成是Scheme在另一个平行宇宙里的镜像&lt;/strong&gt;——Scheme程序由&lt;a href=&quot;http://en.wikipedia.org/wiki/S-expression&quot;&gt;S-表达式（S-expression）&lt;/a&gt;构成，而Z的基本元素则是&lt;strong&gt;Z-表达式（Z-expression）&lt;/strong&gt;。Z-表达式与S-表达式的不同之处在于，它通过&lt;strong&gt;缩进&lt;/strong&gt;而不是&lt;strong&gt;括号嵌套&lt;/strong&gt;来表示其语义。如果你知道了这些，就可以直接去hack它了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chrisdone/z&quot;&gt;https://github.com/chrisdone/z&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（注意：该项目虽然名字叫Z，但是和由Zermelo集合论衍生而来的&lt;a href=&quot;http://en.wikipedia.org/wiki/Z_notation&quot;&gt;Z符号语言&lt;/a&gt;似乎并无直接联系。）&lt;/p&gt;

&lt;p&gt;以前有个笑话：据说某俄国特工经过九死一生偷到了NASA的太空火箭发射程序的源代码的最后一页，代码是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，如果你厌倦了Lisp里面太多的括号，不妨去尝试一下Z！&lt;/p&gt;

&lt;p&gt;这个由Chris Done发起的项目比较新（2013年1月1日，也就是前几天刚发布）。查了一下Scheme的历史，发现采用缩进来代替括号的想法早在十年前（2003年）就有人在&lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_Requests_for_Implementation&quot;&gt;SRFI（Scheme Request For Implementation）&lt;/a&gt;上面提出过了（&lt;a href=&quot;http://srfi.schemers.org/srfi-49/srfi-49.html&quot;&gt;SRFI-49: Indentation-sensitive syntax&lt;/a&gt;）。当时用的名称叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/M-expression#Variants&quot;&gt;I-表达式（I-expression）&lt;/a&gt;。不过这个想法并没有被Scheme社区广泛接受。不知道这次新出现的Z前景如何，拭目以待。&lt;/p&gt;

&lt;p&gt;此外，如果你做过传说中的&lt;a href=&quot;http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours&quot;&gt;48小时写一个Scheme解释器（Write Yourself a Scheme in 48 Hours）&lt;/a&gt;的话，你会发现这个&lt;a href=&quot;https://github.com/chrisdone/z&quot;&gt;Z解释器的实现&lt;/a&gt;基本上是与它平行的。把以前实现的Scheme解释器改写成Z解释器应该也不是什么难事。玩的只是概念而已。&lt;/p&gt;

&lt;p&gt;以下为原文内容。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;一种叫做Z的小型语言&lt;/h2&gt;

&lt;p&gt;一种小型的、严格的、非纯函数式的、&lt;a href=&quot;http://www.haskell.org/haskellwiki/Currying&quot;&gt;柯里式的（curried）&lt;/a&gt;、动态类型的（尽管这可能会在将来改变）、&lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_application&quot;&gt;分步代入的（partially applied）&lt;/a&gt;且有着相当奇特语法的语言。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;它的基本思想看起来很聪明，甚至聪明得有些过头了。 — 摘自reddit的评论&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;从Markdown得到的启发&lt;/h3&gt;

&lt;p&gt;首先，让我们回顾一下Markdown。即使你没有亲自写过Markdown，你应该也已经见到过一些。你应该知道在Markdown的语法中有一个特别之处，即它嵌入代码的方式。它极其简单；不过是：&lt;strong&gt;你只需缩进4个空格，然后就可以随心所欲地在后面书写任何代码了！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Hello world! Here comes some code!

    Here is some arbitrary code! f.x()/f23(); // Zaha!

And now we&amp;#39;re back to normal text...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个想法的特别之处，就是你事实上可以把任何东西都放到这个缩进的后面，而且，它们不会影响到外围的代码！这是个非常牛逼的想法，让我来告诉你为什么。&lt;/p&gt;

&lt;h3&gt;Z-表达式（Z-expression）&lt;/h3&gt;

&lt;p&gt;我将在此介绍一个极其微型的语言，称之为“Z”，用来展示我的这一想法。&lt;/p&gt;

&lt;p&gt;Z有着极其、极其简单的语法。古怪，却简单。这里是它如何工作的一个例子，函数的调用采取如下形式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;name argument
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更深入些的话，下面这段代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;foo bar mu zot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上是被分组后依次解析的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;foo (bar (mu zot))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意：在Z源码里实际上并没有括号。Z即Zero。）&lt;/p&gt;

&lt;p&gt;如果仔细想一想前面给出的&lt;code&gt;name argument&lt;/code&gt;形式的话，这其实是一个非常自然的分组方式。&lt;/p&gt;

&lt;p&gt;为了向某个函数传递多个参数，额外的参数需要被放置在下一行，并且被统一缩进到与第一个参数所在的同一列。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;foo bar
    mu
    zot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表明&lt;code&gt;foo&lt;/code&gt;函数有三个参数。该规则适用于&lt;strong&gt;任何场合&lt;/strong&gt;，因此，我们也可以写：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;foo bar mu
        zot
    bob
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表明&lt;code&gt;foo&lt;/code&gt;函数有两个参数，而&lt;code&gt;bar&lt;/code&gt;函数有两个参数。&lt;/p&gt;

&lt;p&gt;我管这种形式叫做“Z-表达式（Z-expression）”。Lisp语言是括弧状的（curly），卷曲的（curvy），它有它的S-表达式（S-expressions）。而Z则是锯齿状的（jagged），犀利的（sharp）。以及，古怪的。&lt;/p&gt;

&lt;p&gt;特殊算符遵循一套相同的规则。下面我将介绍其中的一些特殊算符。&lt;/p&gt;

&lt;h3&gt;Z的内置算符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;defun&lt;/code&gt;特殊算符需要两个参数：一个名称的列表，其中第一个表示函数的名称；以及一个函数体。这里是一个用来&lt;strong&gt;&lt;em&gt;连接&lt;/em&gt;&lt;/strong&gt;两个列表的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; ap x y
      ++ x
         y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的Z函数都是柯里式的（curried）和&lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_application&quot;&gt;分步代入（partially applied）&lt;/a&gt;的，如同在Haskell中一样。故上述代码等效于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;def&lt;/span&gt; ap
    &lt;span class=&quot;kr&quot;&gt;fn&lt;/span&gt; x
       &lt;span class=&quot;kr&quot;&gt;fn&lt;/span&gt; y
          ++ x
             y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在本介绍中暂时不对此加以赘述。我们同样有&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;do&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; foo
   bar
   mu

&lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; this
   that
   those
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你感兴趣的话，注意下，这些特殊算符采取一种非函数的&lt;a href=&quot;http://en.wikipedia.org/wiki/Normal_order_evaluation#Normal_order&quot;&gt;常序式求值策略（Normal-order evaluation）&lt;/a&gt;。它们只是单纯从语法上来解释自身的参数！&lt;/p&gt;

&lt;p&gt;我们同样有一些用于表示数字的诸如&lt;code&gt;123&lt;/code&gt;、用于表示字符串的诸如&lt;code&gt;&amp;quot;strings&amp;quot;&lt;/code&gt;和&lt;code&gt;unit&lt;/code&gt;之类的符号，就和nothing、null、empty、voidness、niente一样稀松平常&lt;em&gt;（翻译君：这些是各种用来表示“空”的词汇）&lt;/em&gt;。&lt;/p&gt;

&lt;h3&gt;定义宏&lt;/h3&gt;

&lt;p&gt;啊哈！La pièce de résistance（法语：主盘大菜上桌，即全套大餐的精华）！现在，我们将拥有一个&lt;code&gt;defmacro&lt;/code&gt;算符，它的任务是允许我们自行定义新的符号。看好了……&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; -- _
         &lt;span class=&quot;s&quot;&gt;&quot;unit&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voilà（法语：瞧这）！我们定义了一个名称&lt;code&gt;--&lt;/code&gt;，它取得一个我们并不关心其内容的参数&lt;code&gt;_&lt;/code&gt;&lt;em&gt;（翻译君：在这里下划线的含义与许多语言中相同，表示无名变量）&lt;/em&gt;，并且总是返回字符串&lt;code&gt;&amp;quot;unit&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所有的宏都读取一个字符串，这个字符串是源码中所有可以成为它参数的部分，而我们知道，这部分将由缩进来决定。所有的宏都将会产生一个新的字符串，被用来置换到调用宏的原位置，然后将会被解释器&lt;strong&gt;&lt;em&gt;重新解析&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在我们的这个&lt;code&gt;--&lt;/code&gt;宏的例子当中，我们仅仅返回了一个&lt;code&gt;unit&lt;/code&gt;，一个&lt;a href=&quot;http://en.wikipedia.org/wiki/NOP&quot;&gt;非操作符（no-op）&lt;/a&gt;。这样，我们就&lt;strong&gt;已经定义了属于我们自己的注释符号&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;-- A simple function, that is used inside the macro below.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; ap x y
         ++ x
            y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挞哒（Tada）！这是一个带注释的函数定义！用到了我们刚才自创的注释语法，不是吗！我们同样也可以把这个函数&lt;code&gt;ap&lt;/code&gt;用在其它的宏的&lt;strong&gt;&lt;em&gt;内部&lt;/em&gt;&lt;/strong&gt;，这在Lisp语言中是非常典型的用法。所以现在，就让我们基于它来定义一个稍微复杂一些的宏吧：&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;when&lt;/code&gt;宏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;-- A messy macro (because it uses string manipulation),
   but demonstrates the idea well enough.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; when input
         &lt;span class=&quot;kr&quot;&gt;fn&lt;/span&gt; blocks
            ap &lt;span class=&quot;s&quot;&gt;&quot;if&quot;&lt;/span&gt;
               ++ &lt;span class=&quot;kt&quot;&gt;z:indent-before&lt;/span&gt; 3
                                  car blocks
                  ++ &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;
                     ++ &lt;span class=&quot;kt&quot;&gt;z:indent&lt;/span&gt; 3
                                 car cdr blocks
                        ++ &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;
                           &lt;span class=&quot;kt&quot;&gt;z:indent&lt;/span&gt; 3
                                    &lt;span class=&quot;s&quot;&gt;&quot;unit&quot;&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;z:blocks&lt;/span&gt; input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里可以看到，我们提供了一些辅助函数，用以获取“blocks”——也就是一次函数代入中的全部参数——并将它们传递给从&lt;code&gt;fn blocks&lt;/code&gt;开始的匿名函数，然后构造出一个用于返回的字符串。&lt;/p&gt;

&lt;p&gt;你能看出这个宏的目的吗？有了它，我们就可以写出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when = 1
       1
     print ++ &lt;span class=&quot;s&quot;&gt;&quot;The number is: &quot;&lt;/span&gt;
              when true
                   show 123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看这是多么自然？在宏当中嵌套宏什么的完全不是问题！&lt;/p&gt;

&lt;h3&gt;字符串的宏&lt;/h3&gt;

&lt;p&gt;在编程时经常会遇到的问题是，如何尽可能避免麻烦地书写字符串。通常情况下，我们得遵循一套字符转义的特殊规则。但在Z中，你完全不需要这么做！&lt;/p&gt;

&lt;p&gt;以前字符串的使用方式都弱爆了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &lt;span class=&quot;s&quot;&gt;&quot;Hai, guys!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将要定义一个新的宏来方便我们书写字符串，那就是&lt;code&gt;:&lt;/code&gt;符号。它旨在让字符串同正常人类语言一样直接可读，并且允许你在缩进后的文本列范围内不受任何限制地书写任意文本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; : input
         &lt;span class=&quot;kt&quot;&gt;z:string&lt;/span&gt; input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上，我提供了一种将一个&lt;code&gt;string&lt;/code&gt;转换成一个&lt;code&gt;&amp;quot;string&amp;quot;&lt;/code&gt;的方法，因此不管把任何东西作为&lt;code&gt;input&lt;/code&gt;传递到宏，都将被逐字返回，并且是以字符串的形式。准备好了吗？请看！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;-- Example with print:&lt;/span&gt;
print : Hello, World!
        What's going on in here? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然碉堡了不是么？它看起来就像是一段常见的脚本程序！而&lt;strong&gt;&lt;em&gt;这&lt;/em&gt;&lt;/strong&gt;，也正是从Markdown那里得到的启发。它同样也适用于在其他函数中的代入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; message msg
      &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt; print : Here's a message
         print msg
         print : End of message. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以如此使用上述定义的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message ap : Hello,
           ++ &lt;span class=&quot;s&quot;&gt;&quot; World! &quot;&lt;/span&gt;
              : Love ya! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要你愿意，当然也可以直接这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message : &lt;span class=&quot;s&quot;&gt;Everybody dance now!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;一些函数定义的示例&lt;/h3&gt;

&lt;p&gt;到目前为止已经足够给力了。让我们从兴奋中暂时缓口气，来看一些枯燥的纯函数。这些就是Z代码真实的样子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;-- Map function.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; map f xs
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? xs
         unit
         cons f car xs
              map f
                  cdr xs

&lt;span class=&quot;c&quot;&gt;-- [&quot;foo&quot;,&quot;bar&quot;] → foo\nbar\n&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; unlines xs
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? xs
         &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
         ++ car xs
            ++ &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;
               unlines cdr xs

&lt;span class=&quot;c&quot;&gt;-- Take the first n elements of list xs.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; take n xs
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; = n
           0
         unit
         &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? xs
            unit
            cons car xs
                 take - n
                        1
                      cdr xs

&lt;span class=&quot;c&quot;&gt;-- Take all but the last element of a list.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; init xs
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? xs
         unit
         &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? cdr xs
            unit
            cons car xs
                 init cdr xs

&lt;span class=&quot;c&quot;&gt;-- Take the last element of a list, or return a default.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; last def xs
      &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? xs
         def
         &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; unit? cdr xs
            car xs
            last def
                 cdr xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;话说，没有模式匹配（pattern matching）的编程不是很蛋疼吗！？不幸的是，今天我们暂时不会在这里用Z去定义一套模式匹配符，因为要实现一个像模像样的模式匹配并非轻易之举，而做一个过于简陋的会让我感觉很囧。&lt;em&gt;（翻译君：囧rz）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们可以开始使用这些函数了，正如所期望的那样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;-- Print the blocks of foo and bar with ! on the end.&lt;/span&gt;
print unlines map &lt;span class=&quot;kr&quot;&gt;fn&lt;/span&gt; x
                     ++ x
                        &lt;span class=&quot;s&quot;&gt;&quot;!&quot;&lt;/span&gt;
                  &lt;span class=&quot;kt&quot;&gt;z:blocks&lt;/span&gt; : foo
                             bar

&lt;span class=&quot;c&quot;&gt;-- Use of take function.&lt;/span&gt;
print unlines take 3
                   &lt;span class=&quot;kt&quot;&gt;z:blocks&lt;/span&gt; : foo
                              bar
                              mu
                              zot
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;这是另外一个简单的宏的实际用途：正则表达式！让我们来亲身体验一下。&lt;/p&gt;

&lt;p&gt;我们的标准库中最基本的正则函数是&lt;code&gt;regex:match&lt;/code&gt;和&lt;code&gt;regex:new&lt;/code&gt;。&lt;code&gt;regex:match&lt;/code&gt;返回一个所有匹配正则表达式&lt;code&gt;(foo)&lt;/code&gt;的列表（list）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print regex:match regex:new &lt;span class=&quot;s&quot;&gt;&quot;(abc)&quot;&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止我们已经算得上是宏的&lt;strong&gt;&lt;em&gt;高玩&lt;/em&gt;&lt;/strong&gt;了，所以，来看看更漂亮的写法是什么样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defun&lt;/span&gt; ~~ regex string
      regex:match regex
                  string

print ~~ regex:new &lt;span class=&quot;s&quot;&gt;&quot;(def)&quot;&lt;/span&gt;
         &lt;span class=&quot;s&quot;&gt;&quot;defghi&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元芳，你怎么看？还不错吧？至少要做一个字符串匹配所需的代码变得更短了。不过构造正则表达式的语法仍然显得有些笨重。让我们来创建一个宏！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; rx input
         ++ &lt;span class=&quot;s&quot;&gt;&quot;regex:new &quot;&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;z:string&lt;/span&gt; input

print ~~ rx &lt;span class=&quot;s&quot;&gt;Age: (.*)&lt;/span&gt;
         &lt;span class=&quot;s&quot;&gt;&quot;Age: 123&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微美观了些，但是还算不上&lt;strong&gt;&lt;em&gt;碉堡&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们或许可以跳过整个构造正则表达式的部分，把它与匹配的部分合并：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; ~ input
         &lt;span class=&quot;kr&quot;&gt;fn&lt;/span&gt; blocks
            ++ &lt;span class=&quot;s&quot;&gt;&quot;~~ rx&quot;&lt;/span&gt;
               ++ &lt;span class=&quot;kt&quot;&gt;z:indent-before&lt;/span&gt; 6
                                  unlines init blocks
                  ++ &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;
                     &lt;span class=&quot;kt&quot;&gt;z:indent&lt;/span&gt; 3
                              last &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
                                   blocks
            &lt;span class=&quot;kt&quot;&gt;z:blocks&lt;/span&gt; input

print ~ &lt;span class=&quot;s&quot;&gt;Age: (.*)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Age: 666&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;现在&lt;/em&gt;&lt;/strong&gt;我们才算是真正完成了屌丝的逆袭！这语法看起来就像是从矮穷挫瞬间变成了高富帅有木有！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print ~ &lt;span class=&quot;s&quot;&gt;Age: (.*)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;([a-z]+)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Age: 777\nlalala&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更加高能的是，你甚至可以把正则表达式分开在多行写。卧槽，既然这么给力，再来和正则战个痛又如何？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print ~ &lt;span class=&quot;s&quot;&gt;Age: (.*)&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;([a-z]+)&lt;/span&gt;
        : &lt;span class=&quot;s&quot;&gt;Age: 999&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;beep!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，它也可以与其它的宏在一起搭配使用。&lt;del&gt;管他后面这句话是什么意思反正翻译君是不想翻了。&lt;/del&gt;&lt;/p&gt;

&lt;h3&gt;代码编辑&lt;/h3&gt;

&lt;p&gt;Z-表达式的另外一个撸点是，对它进行文本编辑几乎毫无鸭梨。试问：你如何才能在Lisp或者其他类似语言中找到当前语义节点的起始和终止位置？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;scheme&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lorem&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ipsum-lorem-ipsum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo-bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let* &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;biff-pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zar-zar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;%s.bill&amp;quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ben-bill-bocky&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;doo-dar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let*|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo-bar-mu-zot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ipsum-lorem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ipsum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;assoc &lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;#39;cakes&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lorem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lorem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;assoc &lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;#39;potato&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lorem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ipsum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;assoc &lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;#39;ipsum&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lorem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lorem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cdr &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;assoc &lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;&amp;#39;lorem&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lorem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;bob&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;progn&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bill&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ben&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cake&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Structural integrity is not secured.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Data, because it&amp;#39;s polite.&amp;quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cakes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你的光标刚好处在&lt;code&gt;let&lt;/code&gt;之后，你会怎样做？老套路。你开始搜寻一个标志着起始的左括号。你找到了它。然后你开始向后移，搜寻一个标志结束的右括号。每次当遇到一个左括号，你把它压入栈中。每次当遇到一个右括号，你把它从栈中弹出。一旦遇到了一个字符串的开始，或者是转义字符序列，你将需要等待再次遇到下一个非转义字符，然后继续……呃，你开始感到乏味了吗？其实我也这么想。我以为我能轻易地办到这件事情，但事实上并非如此。&lt;em&gt;（翻译君：Emacs下难道没有方便定位Lisp代码的插件吗？我什么都不知道……）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在Z中，一切都变得如此简单。你只需找到起始的列，根据第一个非空格字符的位置。然后上下移动光标，找到与其缩进的起始列位置不同的行，那就是当前语义块起始或终止之处。你将拥有整个Z-表达式。想要移动它？小菜一碟，只需要剪切和粘贴、之后根据偏移增添或删减前置空格即可。担心缩进风格？在Z中它算不上什么问题。就像不存在缩进风格这回事一样。Z自始至终只有一种缩进方式。&lt;/p&gt;

&lt;h3&gt;未来的工作&lt;/h3&gt;

&lt;h4&gt;反引号（Quasiquotations）&lt;/h4&gt;

&lt;p&gt;若不借鉴前人的历史，我们必将一事无成。Lisp有着悠久的历史，它教给了我们引号和反引号，以及借助于它们来处理字符串是多么便捷。我同意这一点。这就是为什么在下一步，我打算实现这样的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;defmacro&lt;/span&gt; when cond body
         &lt;span class=&quot;kr&quot;&gt;`&lt;/span&gt; if &lt;span class=&quot;kr&quot;&gt;,&lt;/span&gt; cond
              &lt;span class=&quot;kr&quot;&gt;,&lt;/span&gt; body
              unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，它遵从与所有Z-表达式相同的语法模式，但却与Lisp具有相同的语义。无论如何，这仅仅只是一个语法糖而已。Z的真正威力体现在它通过缩进来划分代码的语义区域上。&lt;/p&gt;

&lt;h4&gt;“数学”宏&lt;/h4&gt;

&lt;p&gt;在Z中，你使用多参数函数时需要用到缩进。这在做某些数学计算的时候多少有些蛋疼，因为数学表达式的参数通常只是一些简单的、同序的子表达式。考虑到这一点，拥有一套数学宏是完全必要的。例如，&lt;code&gt;#&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;def&lt;/span&gt; x # x²-y²×(2xy+x²-y²×(2xy+c))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么不呢？&lt;em&gt;（翻译君数死早，没看出来这个式子是要干啥= =）&lt;/em&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;安装入门&lt;/h2&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chrisdone/z&quot;&gt;这里&lt;/a&gt;是Z的官方解释器。&lt;/p&gt;

&lt;h4&gt;安装&lt;/h4&gt;

&lt;p&gt;Z解释器当前使用Haskell实现。你可以在&lt;a href=&quot;http://www.haskell.org/platform/&quot;&gt;这里&lt;/a&gt;下载Haskell。&lt;/p&gt;

&lt;p&gt;Haskell安装完成后，编译Z的解释器：&lt;em&gt;（翻译君：你可能需要自行用包管理器安装&lt;a href=&quot;http://hackage.haskell.org/package/text&quot;&gt;text&lt;/a&gt;和&lt;a href=&quot;http://hackage.haskell.org/package/parsec&quot;&gt;parsec&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ cd &amp;lt;path/to/z/dir&amp;gt;
$ ghc Setup.hs
$ ./Setup configure
$ ./Setup build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的二进制文件位于&lt;code&gt;dist/build/z/z&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;运行它，可以交互式地对Z语句进行求值。&lt;/p&gt;

&lt;p&gt;若要执行一个完整的Z源文件，可以通过管道：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./dist/build/z/z &amp;lt; examples.zz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </entry>
    
    
    
    <entry>
        <title>Pygments与highlight.js的对比测试</title>
        <link href="http://www.soimort.org/posts/131" />
        <updated>2012-12-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/131/pygments</id>
        <content type="html">&lt;script&gt;
$(document).ready(function() {$('article &gt; pre code').each(function(i, e) {hljs.highlightBlock(e)}); });
&lt;/script&gt;

&lt;p&gt;请&lt;a href=&quot;https://raw.github.com/soimort/soimort.github.com/master/_posts/posts/131/2012-12-28-pygments.md&quot;&gt;猛击此处&lt;/a&gt;查看本文的Markdown源文件。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;在Markdown中嵌入代码的方式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/posts/130/&quot;&gt;Jekyll 0.12.0发布&lt;/a&gt;之后，如果你原来还在用&lt;a href=&quot;http://softwaremaniacs.org/soft/highlight/en/&quot;&gt;highlight.js&lt;/a&gt;渲染高亮代码的话，也许现在可以考虑回到&lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt;上了。&lt;/p&gt;

&lt;p&gt;不仅仅是因为pygments.rb大大提升了调用Pygments渲染效率的关系，它当然还有其他一些便利之处！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Jekyll 0.11.2（使用&lt;a href=&quot;https://github.com/github/albino&quot;&gt;Albino&lt;/a&gt;来调用Pygments）上，在Markdown中嵌入一段高亮Ruby代码需要用到预定义的Liquid标签：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;no-highlight&quot;&gt;{&amp;#37; highlight ruby &amp;#37;}
def ackermann(m, n)
    if m == 0
        n + 1
    elsif n == 0
        ackermann(m - 1, 1)
    else
        ackermann(m - 1, ackermann(m, n - 1))
    end
end
{&amp;#37; endhighlight &amp;#37;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用Jekyll + highlight.js，在Markdown中嵌入一段高亮Ruby代码需要手写&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;之类的HTML标签：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;no-highlight&quot;&gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;ruby&quot;&amp;gt;def ackermann(m, n)
    if m == 0
        n + 1
    elsif n == 0
        ackermann(m - 1, 1)
    else
        ackermann(m - 1, ackermann(m, n - 1))
    end
end
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种写法多少都显得有些臃肿。如今&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Jekyll 0.12.0（使用&lt;a href=&quot;https://github.com/tmm1/pygments.rb&quot;&gt;pygments.rb&lt;/a&gt;来调用Pygments）上，可以直接使用GitHub Flavored Markdown所支持的“围栏式代码块”方式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;no-highlight&quot;&gt;```ruby
def ackermann(m, n)
    if m == 0
        n + 1
    elsif n == 0
        ackermann(m - 1, 1)
    else
        ackermann(m - 1, ackermann(m, n - 1))
    end
end
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在需要大量引用代码的场合，这种写法显然更加简洁。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;实际代码渲染效果&lt;/h2&gt;

&lt;p&gt;以下是若干种语言的代码在highlight.js和Pygments中的实际渲染效果比较。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;highlight.js&lt;/strong&gt;：7.3版本（全语言支持pack），使用tomorrow-night主题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pygments&lt;/strong&gt;：pygments.rb 0.3.3版本，使用和tomorrow-night相同的暗色系背景。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3&gt;Ruby&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;对函数定义中的参数列表&lt;code&gt;(m, n)&lt;/code&gt;进行高亮，略显怪异。&lt;/li&gt;
&lt;li&gt;没有把&lt;code&gt;puts&lt;/code&gt;函数高亮出来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;ruby&quot;&gt;def ackermann(m, n)
    if m == 0
        n + 1
    elsif n == 0
        ackermann(m - 1, 1)
    else
        ackermann(m - 1, ackermann(m, n - 1))
    end
end

puts ackermann(3, 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;puts&lt;/code&gt;进行了高亮。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h3&gt;Haskell&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;这后面两行最右边的括号是怎么一回事……连括号匹配都处理不对么？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;haskell&quot;&gt;ackermann :: (Int, Int) -&gt; Int
ackermann (0, n) = n + 1
ackermann (m, 0) = ackermann (m - 1, 1)
ackermann (m, n) = ackermann (m - 1, ackermann (m, n - 1))

main = print (ackermann (4, 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;定义部分的函数名称使用醒目的亮色渲染出来，一目了然。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h3&gt;Standard ML&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;highlight.js尚不支持ML语言，所以这高亮效果几乎等于是没有。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;sml&quot;&gt;fun ackermann (0, n) = n + 1
    | ackermann (m, 0) = ackermann (m - 1, 1)
    | ackermann (m, n) = ackermann (m - 1, ackermann (m, n - 1))

val _ = print (Int.toString (ackermann (4, 1)) ^ &quot;\n&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;语言关键字正确高亮。&lt;/li&gt;
&lt;li&gt;定义部分的函数名称使用醒目的亮色渲染出来了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sml&quot;&gt;&lt;span class=&quot;kr&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h3&gt;OCaml&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;同上，不支持ML。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;ocaml&quot;&gt;let _ =
    let rec ackermann (m, n) =
        match (m, n) with
        | 0, n -&gt; n + 1
        | m, 0 -&gt; ackermann (m - 1, 1)
        | m, n -&gt; ackermann (m - 1, ackermann (m, n - 1))
    in
    Printf.printf &quot;%d\n&quot; (ackermann (4, 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;语言关键字正确高亮。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;nn&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h3&gt;Scala&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;自定义的object名称和内置类型使用相同的颜色来进行高亮，略奇怪。&lt;/li&gt;
&lt;li&gt;不知为何函数定义的参数列表中的符号要使用和正常符号不同的颜色来表示……&lt;/li&gt;
&lt;li&gt;连&lt;code&gt;match&lt;/code&gt;都没高亮出来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;scala&quot;&gt;object Ackermann {
    def ackermann(m: Int, n: Int): Int = {
        (m, n) match {
            case (0, n) =&gt; n + 1
            case (m, 0) =&gt; ackermann(m - 1, 1)
            case _ =&gt; ackermann(m - 1, ackermann(m, n - 1))
        }
    }
    
    def main(args: Array[String]) {
        println(ackermann(4, 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;整体效果很完美。&lt;/li&gt;
&lt;li&gt;自定义的object名称使用醒目的亮色渲染。&lt;/li&gt;
&lt;li&gt;模式匹配中的&lt;code&gt;=&amp;gt;&lt;/code&gt;符号也高亮了出来，看着很清晰。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Ackermann&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h3&gt;C&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;highlight.js:

&lt;ul&gt;
&lt;li&gt;highlight.js是前端处理，所以嵌入代码中的大于号小于号（以及其他各种必须进行HTML转义的符号）必须在写Markdown的时候进行手动替换。如果不转义直接放在Markdown里的话会被当作HTML解析，无法在浏览器中正确显示：（注意到&lt;code&gt;#include&lt;/code&gt;后面的&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;被浏览器当作HTML标签吞掉了）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code id=&quot;cpp&quot;&gt;#include &lt;stdio.h&gt;

int ackermann(int m, int n)
{
    if (m == 0)
        return n + 1;
    if (n == 0)
        return ackermann(m - 1, 1);
    return ackermann(m - 1, ackermann(m, n - 1));
}

int main()
{
    printf(&quot;%d\n&quot;, ackermann(4, 1));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pygments:

&lt;ul&gt;
&lt;li&gt;Pygments则是对代码块进行预处理之后再输出到HTML，它将负责解决转义字符的问题。所以在写Markdown的时候根本无需考虑进行任何替换，直接把现成的代码块拷贝到“围栏”中就可以：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ackermann&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果需要在JavaScript前端做实时的代码高亮渲染，当然只能用highlight.js（或者类似的google-code-prettify）；&lt;/li&gt;
&lt;li&gt;在其他的应用场合，&lt;strong&gt;Pygments是更好的选择&lt;/strong&gt;。它对于各种语言的高亮支持的确是目前最完善的。&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Jekyll 0.12.0新特性简介</title>
        <link href="http://www.soimort.org/posts/130" />
        <updated>2012-12-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/130/jekyll-0.12.0</id>
        <content type="html">&lt;p&gt;GitHub的静态博客系统&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;最近终于发布&lt;a href=&quot;http://rubygems.org/gems/jekyll/versions/0.12.0&quot;&gt;新版本（0.12.0）&lt;/a&gt;了！&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/tsj/t_0035.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;（这个项目已经不知道多久没有更新，我差点都以为GitHub不打算把它继续维护下去了……）&lt;/p&gt;

&lt;p&gt;所以，现在就来尝尝鲜，看看0.12.0版到底增加了哪些新东西。＼(^o^)／&lt;/p&gt;

&lt;h2&gt;1. 支持Redcarpet 2渲染引擎&lt;/h2&gt;

&lt;p&gt;Jekyll 0.12.0现在支持使用&lt;a href=&quot;https://github.com/vmg/redcarpet&quot;&gt;Redcarpet&lt;/a&gt;，来作为替代RDiscount或Maruku的Markdown渲染引擎。&lt;/p&gt;

&lt;p&gt;Redcarpet是由GitHub自己人开发的（我就不说质量有保证之类的话了），一直以来它被用于在GitHub上渲染Markdown格式文本（也就是&lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;GitHub Flavored Markdown&lt;/a&gt;）。由于API兼容性的原因，Jekyll以前的版本并不支持Redcarpet（所以以前写博客也不能用GitHub Flavored Markdown &amp;gt;_&amp;lt;）。现在，Jekyll 0.12.0终于增加了对Redcarpet 2引擎的支持，只需安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install redcarpet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把&lt;code&gt;_config.yml&lt;/code&gt;中的Markdown引擎设置从：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;markdown: rdiscount
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;markdown: redcarpet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以迁移到Redcarpet上了。&lt;/p&gt;

&lt;p&gt;Redcarpet所支持的GitHub Flavored Markdown比起标准的Markdown语法来增加了不少便利之处，诸如&lt;strong&gt;围栏式代码块（Fenced code blocks）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例如，在文章中嵌入一段Ruby代码块，对应的GitHub Flavored Markdown写法是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;no-highlight&quot;&gt;```ruby
def ackermann(m, n)
    if m == 0
        n + 1
    elsif n == 0
        ackermann(m - 1, 1)
    else
        ackermann(m - 1, ackermann(m, n - 1))
    end
end
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传统的标准Markdown中虽然可以嵌入代码块，但是无法声明所使用的程序语言。以前在Jekyll中，为了让Pygments正确识别并渲染一段高亮代码，需要借助于辅助的Liquid宏：{&amp;#37; highlight ruby &amp;#37;}{&amp;#37; endhighlight &amp;#37;}&lt;/p&gt;

&lt;p&gt;现在，在Jekyll上也可以使用和GitHub Flavored Markdown相同的围栏式代码块了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;del&gt;注意：截止到目前（2012.12.28）为止，GitHub Pages服务器部署的似乎仍然是Jekyll 0.11.0。如果你的博客是托管在GitHub Pages上的，你将仍然无法使用GitHub Flavored Markdown（包括“围栏式代码块”）。&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2013.1.3更新：GitHub Pages已经升级到了Jekyll 0.12.0：&lt;/strong&gt;&lt;a href=&quot;https://github.com/blog/1366-github-pages-updated-to-jekyll-0-12-0&quot;&gt;https://github.com/blog/1366-github-pages-updated-to-jekyll-0-12-0&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2. 用pygments.rb加速代码高亮（Syntax highlighting）&lt;/h2&gt;

&lt;p&gt;Jekyll上用于渲染高亮代码的&lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt;是一个Python库。以前，Jekyll 0.11.2使用&lt;a href=&quot;https://github.com/github/albino&quot;&gt;Albino&lt;/a&gt;，一个Pygments的Ruby wrapper库来调用&lt;code&gt;pygmentize&lt;/code&gt;渲染代码。&lt;/p&gt;

&lt;p&gt;Albino直接从管道调用一个Python程序、等待其输出结果，然后将其返回，理所当然，它的执行速度很慢。事实上，它简直太tm慢了，慢到无法忍受，以至于许多人（包括我在内）后来都放弃了使用Pygments，直接拿&lt;a href=&quot;http://softwaremaniacs.org/soft/highlight/en/&quot;&gt;highlight.js&lt;/a&gt;在前端上做代码高亮了。&lt;/p&gt;

&lt;p&gt;Jekyll 0.12.0使用了&lt;a href=&quot;https://github.com/tmm1/pygments.rb&quot;&gt;pygments.rb&lt;/a&gt;来取代Albino。pygments.rb同样是一个Pygments的Ruby wrapper，不同的是它会同时打开多个独立的Python子进程来分配给Ruby的进程调用（通过管道通信），这些子进程的生命期直到pygments.rb执行完毕才结束，这就避免了Ruby在执行过程中不断地启动和关闭Python解释器造成的不必要时间开销。&lt;em&gt;（这个原理非常有意思，以后如果要写在一种语言中调用另一种脚本语言的wrapper也许用得着）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Arch Linux用户注意：因为pygments.rb里面已经包含了Pygments，所以在新的Jekyll 0.12.0上不需要再依赖额外的python2-pygments包。此外，虽然Pygments有支持Python 3，不过pygments.rb里面打包进去的Pygments是Python 2版本的。需要手动修改&lt;code&gt;lib/pygments/mentos.py&lt;/code&gt;的shebang。&lt;/p&gt;

&lt;p&gt;升级到Jekyll 0.12.0之后，我特地对原来用的highlight.js和Pygments做了一个对比测试，来决定哪一种代码高亮工具更好用。详情请参见&lt;a href=&quot;/posts/131/&quot;&gt;下一篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;3. 其他功能改进&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;增加了&lt;code&gt;include&lt;/code&gt;设置参数，可以显式地指定哪些文件被Jekyll处理或忽略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例如，以前Jekyll默认会忽略掉文件名前缀为下划线的文件，现在可以通过这个参数把它们也包含进来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加了&lt;code&gt;--default-mimetype&lt;/code&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当permalink没有&lt;code&gt;.html&lt;/code&gt;后缀时，让WEBrick server也能正确识别mimetype。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许RedCloth选项的设定&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于Textile用户来说应该会很有用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加了Liquid标签&lt;code&gt;post_url&lt;/code&gt;用来插入内部链接&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个没觉得有太大用处。一般情况下似乎也用不着Liquid来插入链接……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许指定多个plugin文件夹&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于用GitHub pages来托管的站点来说似乎意义不大（&lt;a href=&quot;https://github.com/mojombo/jekyll/issues/325&quot;&gt;基于安全考虑&lt;/a&gt;，GitHub pages不执行任何用户自定义的Jekyll plugins）。&lt;/li&gt;
&lt;li&gt;不过需要用到自己的plugins的时候，一般都会把站点托管在自己的服务器或者Heroku这种地方吧……所以这项功能总的来说还是会比较有用的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持RDiscount的行内目录（TOC）生成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用RDiscount引擎的时候会用到。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加了用于指定分页URL格式的选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要对博客文章进行分页控制的时候也许会有用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改进了Liquid错误的提示信息&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/&quot;&gt;http://tech.nitoyon.com/ja/blog/2012/12/25/jekyll-0-12-0/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/History.txt&quot;&gt;https://github.com/mojombo/jekyll/blob/master/History.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121228 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121228" />
        <updated>2012-12-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121228/0.3dev20121228</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121228&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121228&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121228&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Enhance support for QQ&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/radaiming&quot;&gt;@radaiming&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Add support for &lt;a href=&quot;http://www.xiami.com&quot;&gt;Xiami&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/twlz0ne&quot;&gt;@twlz0ne&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Add support for Tumblr audios&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;Due to legal issues, Tumblr doesn&amp;#39;t want people to download audio files hosted on its servers. Please DON&amp;#39;T OVERUSE this function. (You may use it to download Tumblr audios which are hosted on SoundCloud though)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>关于Unix世界末日的调查报告</title>
        <link href="http://www.soimort.org/posts/129" />
        <updated>2012-12-24T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/129/apocalypse</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3VFJc.png&quot; alt=&quot;tweet&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/asagi_newmoon/status/281783512355442688&quot;&gt;未来的人类：“古代文明人所创造的这台Unix机器、它的历法只到2038年1月19日这一天就为止了，因此我确信那一天必将是地球灭亡之日。”&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;这就是Unix系统的&lt;a href=&quot;http://zh.wikipedia.org/wiki/2038%E5%B9%B4%E9%97%AE%E9%A2%98&quot;&gt;2038年问题&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你是Linux用户还不知道2038年是世界末日这个梗，正好可以趁这个机会逃离Linux滚回去用Windows或者Mac了（Mac OS X&lt;strong&gt;&lt;em&gt;也许&lt;/em&gt;&lt;/strong&gt;是极少数无须用户担心2038年问题的*nix系统之一）。Linux这个操作系统对你来说太危险了。&lt;/p&gt;

&lt;h2&gt;2038年问题&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://unixepoch.com/tshirt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;2038年问题的成因与20世纪90年代曾经名噪一时的&lt;a href=&quot;http://zh.wikipedia.org/wiki/2000%E5%B9%B4%E9%97%AE%E9%A2%98&quot;&gt;千年虫问题&lt;/a&gt;很类似。千年虫问题是因为早期（早在20世纪50年代以前）程序员们使用两位十进制数字来表示年份（为了节约存储空间和书写程序的便利），并且在很长一段时间内，没有意识到这么做可能给后人带来的麻烦；当所有人都习惯这么做时，随着软件系统变得越来越复杂，小问题就逐渐演变成大问题了。&lt;/p&gt;

&lt;p&gt;说起Unix上的2038年问题，时间要追溯到1969年。当&lt;a href=&quot;http://en.wikipedia.org/wiki/Ken_Thompson&quot;&gt;Ken Thompson&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Dennis_Ritchie&quot;&gt;Dennis Ritchie&lt;/a&gt;在贝尔实验室里捣鼓他们的新玩意时，他们肯定没有想到他们的小发明将来会在全世界发挥如此大的影响力。他们决定把他们所创造的这个支持多用户多任务的新操作系统命名为&lt;a href=&quot;http://en.wikipedia.org/wiki/UNIX&quot;&gt;UNIX&lt;/a&gt;，以一个32位二进制数所能表示的有符号整数范围（-2,147,483,648 ~ +2,147,483,647）所代表的秒数作为&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix纪元（Unix epoch）时间&lt;/a&gt;，把西元1970年1月1日0时0分0秒定为Unix纪元的元年。&lt;/p&gt;

&lt;p&gt;在Unix历的约第100,000,000秒（或者，用人类的纪年法，大约在西元1972~1973年之间），一种叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/C_(programming_language)&quot;&gt;C&lt;/a&gt;的高级程序语言被发明出来了。于是，贝尔实验室的这帮人用C语言重写了他们的UNIX系统内核，很自然地，系统库中用于存储时间的&lt;code&gt;time_t&lt;/code&gt;类型的&lt;code&gt;typedef&lt;/code&gt;定义，就采用了C语言中对应的32位有符号整型（&lt;code&gt;signed int32&lt;/code&gt;）来实现。&lt;/p&gt;

&lt;p&gt;起初，一切都很好。UNIX走出了贝尔实验室中少数研究人员的小圈子，得到了工业界的青睐，好几家商业公司都发行了自己的Unix变体，其中包括最早的商业版&lt;a href=&quot;http://en.wikipedia.org/wiki/UNIX_System_V&quot;&gt;UNIX System V&lt;/a&gt;以及后来的&lt;a href=&quot;http://en.wikipedia.org/wiki/IBM_AIX&quot;&gt;IBM AIX&lt;/a&gt;、&lt;a href=&quot;http://en.wikipedia.org/wiki/HP-UX&quot;&gt;HP-UX&lt;/a&gt;、SGI的&lt;a href=&quot;http://en.wikipedia.org/wiki/IRIX&quot;&gt;IRIX&lt;/a&gt;和微软的&lt;a href=&quot;http://en.wikipedia.org/wiki/Xenix&quot;&gt;Xenix&lt;/a&gt;，它们被广泛用在各式大中小型主机和服务器上。到了80年代初，当时在麻省理工大学&lt;a href=&quot;https://plus.google.com/photos/100974147585154622588/albums/5537441647015301921/5537448790573594514&quot;&gt;人工智能实验室&lt;/a&gt;工作的一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Richard_Stallman&quot;&gt;大胡子黑客&lt;/a&gt;不满于Unix这种专有软件的闭源开发模式，他决定重写一个完全自由的仿Unix操作系统，但又不是Unix，这就是后来的&lt;a href=&quot;http://en.wikipedia.org/wiki/GNU_Project&quot;&gt;GNU (GNU is Not Unix) Project&lt;/a&gt;；与此同时，在西海岸，UC Berkeley的&lt;a href=&quot;http://en.wikipedia.org/wiki/Bill_Joy&quot;&gt;另一群黑客&lt;/a&gt;获得了一部分来自最初贝尔实验室的Unix原始代码，他们在此基础上开发出属于自己的一套“伯克利软件发行包（Berkeley Software Distribution）”，这演变成了后来的&lt;a href=&quot;http://en.wikipedia.org/wiki/Berkeley_Software_Distribution&quot;&gt;BSD家族&lt;/a&gt;。很快，时间已经到了Unix纪元的第31年，在大洋彼岸的北欧国家芬兰，一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Linus_Torvalds&quot;&gt;年轻大学生&lt;/a&gt;自己写了一个仿Unix内核，受到当时GNU发起的自由软件运动的影响，他决定把这个内核以GPL协议发放出来，让全世界的黑客们来共同使用、参与开发。恰好那时GNU操作系统还没有自己的成熟内核，这个后来被命名为“&lt;a href=&quot;http://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;”的仿Unix内核借着与GNU Project的结合获得了广泛的成功与关注。最终，就有了我们今天所使用的GNU/Linux。在很长一段时间里，不管是真正的Unix和由它直接衍生而来的BSD、Solaris，还是试图“仿造出”Unix的GNU/Linux，抑或是为了统一各种类Unix（*nix）系统而生的POSIX标准，所有的类Unix系统都把&lt;code&gt;time_t&lt;/code&gt;类型理所当然地等价为C语言中的原生数据类型&lt;code&gt;signed int32&lt;/code&gt;，无数的库和工具被基于它写出来，很多网络上的服务与应用也是基于这个事实的标准。&lt;/p&gt;

&lt;p&gt;终于有一天，人们意识到，32 bits整数所能表示的数目大小毕竟是有限的，更何况这个数字是以秒作为单位。对于正在各行各业发挥着越来越重要作用的类Unix系统来说，当初的设定显然也太目光短浅了些。&lt;/p&gt;

&lt;p&gt;32位有符号整型所能表示的最大数是+2,147,483,647。2147483647秒 = 24855天 = 68年。也就是说，自Unix纪元的元年（1970年）起，再过68年，所有现存的32位类Unix系统都将迎来历法上的终结——对+2,147,483,647加1将造成一个算术溢出：在大部分系统上，返回值会变成-2,147,483,648，在少数系统上，返回值可能是0。许多依赖于系统时间的程序将无法正常工作，计算机的时钟也将退回到1901年（或者1970年）。它们将无法正确处理那之后的时间。&lt;/p&gt;

&lt;p&gt;这个准确的时刻是：协调世界时2038年1月19日3时14分7秒（未考虑闰秒）。你可以在维基百科上找到&lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;更多的信息&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/e/e9/Year_2038_problem.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;更多的“xx”年问题&lt;/h2&gt;

&lt;p&gt;除了&lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;2038年问题（Y2K38）&lt;/a&gt;和较为人熟知的&lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2000_problem&quot;&gt;千年虫问题（Y2K）&lt;/a&gt;之外，还有其他更多由于计算机内部年份表示所造成的问题，可以参考&lt;a href=&quot;http://ja.wikipedia.org/wiki/%E5%B9%B4%E5%95%8F%E9%A1%8C#.E3.82.B3.E3.83.B3.E3.83.94.E3.83.A5.E3.83.BC.E3.82.BF.E3.81.AE.E6.99.82.E5.88.BB.E5.87.A6.E7.90.86.E3.81.AB.E9.96.A2.E3.82.8F.E3.82.8B.E5.95.8F.E9.A1.8C&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个与Unix的2038年问题相类似的是NTP协议的&lt;a href=&quot;http://en.wikipedia.org/wiki/Network_Time_Protocol#NTP_timestamps&quot;&gt;2036年问题&lt;/a&gt;。NTP协议的时间戳采用了和Unix相似的32位整数表示，不同于Unix的1970 ± 68年范围，NTP使用的是无符号整型，并且以1900作为时间的起点，这意味着它的终点将是1900 + 136 = 2036年2月6日。&lt;/p&gt;

&lt;p&gt;和2038年问题直接相关的两个历史事件是&lt;a href=&quot;http://ja.wikipedia.org/wiki/2001%E5%B9%B49%E6%9C%889%E6%97%A5%E5%95%8F%E9%A1%8C&quot;&gt;2001年9月9日问题&lt;/a&gt;和&lt;a href=&quot;http://itpro.nikkeibp.co.jp/free/NC/NEWS/20040202/139212/&quot;&gt;2004年日本银行ATM机故障&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ja.wikipedia.org/wiki/2001%E5%B9%B49%E6%9C%889%E6%97%A5%E5%95%8F%E9%A1%8C&quot;&gt;2001年9月9日问题&lt;/a&gt;又被称作S1G（Second 1 Giga，一吉秒）或者S1B（Second 1 Billion）问题。在那一天，Unix纪元时间迎来了第1,000,000,000秒，由于某些软件中使用了字符串来存储时间戳，当字符串变成&lt;code&gt;&amp;quot;1000000000&amp;quot;&lt;/code&gt;时，字典排序的结果会产生&lt;code&gt;&amp;quot;999999999&amp;quot; ＞ &amp;quot;1000000000&amp;quot;&lt;/code&gt;，这造成了相当一部分程序不能正常判断时间差，影响到正常工作。（我一直以为只有不上路子的2B程序员才会这么去做判断，没想到还真不少，&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time#Notable_events_in_Unix_time&quot;&gt;包括KDE在内&lt;/a&gt;。。。）&lt;/p&gt;

&lt;p&gt;2004年1月10日恰好是1970年到2038年时间轴上的中点——显然，如果你在程序中出于某种目的将Unix时间乘以了2，那么它将不能正常工作。这在日本某些银行使用了IBM软件的ATM机上&lt;a href=&quot;http://itpro.nikkeibp.co.jp/free/NC/NEWS/20040202/139212/&quot;&gt;确实发生了&lt;/a&gt;。（至于究竟为什么要把时间乘以2，我只能表示不明觉厉。）&lt;/p&gt;

&lt;p&gt;你可能除了千年虫问题之外还听说过&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%B0%91%E5%9C%8B%E7%99%BE%E5%B9%B4%E8%9F%B2&quot;&gt;民国百年虫&lt;/a&gt;和&lt;a href=&quot;http://ja.wikipedia.org/wiki/%E6%98%AD%E5%92%8C100%E5%B9%B4%E5%95%8F%E9%A1%8C&quot;&gt;昭和100年&lt;/a&gt;、&lt;a href=&quot;http://ja.wikipedia.org/wiki/%E5%B9%B3%E6%88%90100%E5%B9%B4%E5%95%8F%E9%A1%8C&quot;&gt;平成100年问题&lt;/a&gt;。（台湾和日本的程序员，为什么你们要在程序内部拿年号纪元来存储时间……）&lt;/p&gt;

&lt;p&gt;可以肯定地说，全世界的程序员都是一群爱偷懒的货。&lt;/p&gt;

&lt;h2&gt;轻松一刻&lt;/h2&gt;

&lt;p&gt;在2001年S1B问题发生之前的4月19日，恰好迎来了Unix纪元的第987,654,321秒。虽然没什么实质意义（估计没有哪个程序会无聊到去计算时间戳中不同数字的个数），但这还是在&lt;a href=&quot;http://tech.slashdot.org/story/01/04/17/1915221/the-quickly-descending-unix-timestamp&quot;&gt;Slashdot&lt;/a&gt;上激起了不少讨论。&lt;/p&gt;

&lt;p&gt;有人写了这么个段子：（高端黑。。。）&lt;/p&gt;

&lt;p&gt;&lt;em&gt;我已经等不及在MSNBC频道上看到这样的新闻了：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Redmond WA.&lt;/em&gt;&lt;br&gt;
&lt;em&gt;今天，Bill Gates友情提醒大家，所有的*nix系统将会遭遇即将到来的9月9日所导致的S1B问题。MSNBC推荐所有的&lt;em&gt;nix用户立即尽可能早地迁移到Windows XP。据报道，Steve Balmer表示他“惊讶于\&lt;/em&gt;nix的设计竟是如此地目光短浅”。XP从最初起就被设计成完全免除于S1B问题，只要在9月份的某个时候安装了我们发布的SP8之后。所有你们这些Windows用户将会是保证安全的，你们根本无需去考虑使用那些流氓操作系统。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;2009年2月13日11:31:30，是Unix纪元的第1,234,567,890秒。这天刚好是星期五，又是一个13号，也就是西方文化中所谓的&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%BB%91%E8%89%B2%E6%98%9F%E6%9C%9F%E4%BA%94&quot;&gt;黑色星期五&lt;/a&gt;。世界各地不少Unix社区都在举办活动庆祝此事，包括Google的hackers们。他们甚至还做了一个Doodle：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.google.com/logos/unix1234567890.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.google.com/logos/unix1234567890.gif&quot;&gt;http://www.google.com/logos/unix1234567890.gif&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（Doodle这东西真是今非昔比。三年前还是如此简陋，再看看现在的……）&lt;/p&gt;

&lt;p&gt;我以为国内基本上不会有人对这种过于geek的事情感兴趣，不过终于还是在酷壳上面&lt;a href=&quot;http://coolshell.cn/articles/19.html&quot;&gt;发现了一篇&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;话说国内的技术社区真是缺乏娱乐精神啊。（还是说真正的Unix用户不多呢？虽然只是为了新奇玩玩Linux桌面的人倒是不在少数）&lt;/p&gt;

&lt;h2&gt;从32位到64位&lt;/h2&gt;

&lt;p&gt;解决2038年问题的办法看似很简单：因为&lt;code&gt;time_t&lt;/code&gt;类型本来就是依赖于C POSIX库的具体实现的，并没有哪个规范规定它必须是32位，直接把它改成64位不就行了吗？&lt;/p&gt;

&lt;p&gt;问题是，直接这么改，会破坏很多现有程序（工具、服务……）的兼容性。几乎所有的32位系统都自然而然地采用了32位的&lt;code&gt;time_t&lt;/code&gt;，这其中包括了现在绝大多数基于ARM处理器的电子产品（只要它们的底层系统是基于类Unix的——这包括iPad、iPhone、所有Android手机、PS Vita还有Raspberry Pi等等）。&lt;/p&gt;

&lt;p&gt;当然你大可不必担心你的手机会遭遇2038年问题，因为你现在的手机大概不会一直用到2038年（也许再过几个月你就会淘汰掉旧的去换新的了！）。剩下来的，就是桌面和服务器所要面临的问题了。&lt;/p&gt;

&lt;p&gt;所幸的是，摆脱了嵌入式设备的局限性，我们在桌面和服务器上已经有了众多的64位体系架构可供选择。而且，目前绝大多数的64位操作系统，也都自然而然地采用了64位&lt;code&gt;time_t&lt;/code&gt;类型（相当于&lt;code&gt;long long int&lt;/code&gt;或者&lt;code&gt;int64&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;问题解决了。只要我们可以预期现有的计算机都能在2038年之前迁移到64位系统（准确地说，是采用了64位&lt;code&gt;time_t&lt;/code&gt;的系统），Unix纪元就不会迎来末日。到了那一天，所有的计算机系统仍然能正常工作，人类文明完好如初。&lt;/p&gt;

&lt;p&gt;传统的32位Unix纪元时间会在2038年发生算术溢出，然后迎接末日。64位纪元当然也是会有这一天的，那将是在：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15:30:08 UTC on Sun, 4 December 292,277,026,596&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个时间已经远远超过了预计太阳扩张成红巨星并吞噬地球的时间。所以，在此之前，已经没有什么好担心的了。我确信，要么人类文明要么根本都熬不到那一天，要么等到那一天，我们早就达到了拥有任意操纵时间和空间的能力的技术奇点，人类文明将获得永生（跑题了。。。）；要么就是，所有的电脑都已经迁移到了128位。（这当然是最简单的解决办法）&lt;/p&gt;

&lt;h2&gt;你的系统如何？&lt;/h2&gt;

&lt;p&gt;想知道自己的Unix系统是否会在2038年1月19日这一天迎来末日，只要看系统能否正确显示Unix纪元第2,147,483,648秒的日期即可。&lt;/p&gt;

&lt;p&gt;在GNU/Linux上，执行：（GNU date）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ date -ud @2147483648
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在BSD上，执行：（BSD date）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ date -u -r 2147483648
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果系统使用了64位时间，结果应该是正常的：（后文中假定时区一律设为&lt;code&gt;export TZ=&amp;quot;UTC&amp;quot;&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Tue Jan 19 03:14:08 UTC 2038
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么恭喜，你的系统可以平安无恙地度过2038年末日。如果出现1901年或者其他神马奇怪结果的话，自己看着办吧。&lt;/p&gt;

&lt;p&gt;另：Unix是否会发生2038年问题并不绝对取决于是32位系统还是64位系统。这由具体系统中对&lt;code&gt;time_t&lt;/code&gt;类型的实现决定。NetBSD和OpenBSD的早期版本在amd64平台上仍然使用了32位&lt;code&gt;time_t&lt;/code&gt;，因此&lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!msg/comp.unix.bsd.freebsd.misc/uDyi9y3l0SE/JWV-hdsJ6ZcJ&quot;&gt;仍然会发生2038年问题&lt;/a&gt;。如今也有一些32位系统开始使用64位的&lt;code&gt;time_t&lt;/code&gt;类型（典型的例子：今年10月份发布的NetBSD 6.0，在32位和64位平台上一律改成了64位&lt;code&gt;time_t&lt;/code&gt;）。64位Linux上已经在使用64位的&lt;code&gt;time_t&lt;/code&gt;了，而32位Linux上则似乎仍然是32位。这是我所能知道的。&lt;/p&gt;

&lt;h2&gt;你的编程语言呢？&lt;/h2&gt;

&lt;p&gt;绝大多数从Unix/Linux平台上发展起来的编程语言都采取了和Unix纪元相同的时间点（1970年1月1日）&lt;a href=&quot;http://en.wikipedia.org/wiki/Epoch_(computing)#Computing&quot;&gt;作为时间的起点&lt;/a&gt;：C/C++，Perl，PHP，Python，Java，JavaScript，等等。&lt;/p&gt;

&lt;p&gt;C语言的情况比较特殊，因为&lt;code&gt;time_t&lt;/code&gt;的大小是直接与系统平台上C POSIX库的实现相关的，所以在没有2038年问题的64位系统上，&lt;code&gt;time_t&lt;/code&gt;也是64位；在存在2038年问题的Unix系统上，&lt;code&gt;time_t&lt;/code&gt;则是32位（这不废话么。。。）。（这也是为什么从原则上说你无法在AVR/Arduino上使用&lt;code&gt;time_t&lt;/code&gt;类型的原因，因为嵌入式设备如果没有操作系统自然也就不存在这些C POSIX库的说法，更不会受到2038年问题的影响）&lt;/p&gt;

&lt;p&gt;Perl和CPython的标准实现是高度依赖于C POSIX库的，这意味着它们也许在32位系统上同样存在2038年问题。（我没有32位系统，没试过所以不知道……）&lt;/p&gt;

&lt;p&gt;Java是一个真正意义上的&lt;strong&gt;跨平台&lt;/strong&gt;语言，它所提供的虚拟机环境不像Python或者其他语言那样大量依赖系统平台的native API库，这意味着它的时间表示在任何平台上都统一采用了64位（即使一开始不是这样设计的，至少也是从某个语言版本开始改成了64位实现），这将不受具体系统对&lt;code&gt;time_t&lt;/code&gt;类型实现的约束（在非Unix平台的Windows上亦是如此）。&lt;/p&gt;

&lt;h2&gt;模拟Unix纪元的末日&lt;/h2&gt;

&lt;p&gt;前面已经有过一个GIF动画来模拟Unix系统时钟溢出的场景了。如果想在自己的Unix/Linux上亲眼看一看末日是怎样降临的话，这里是一个C语言的演示程序：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/4360400.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;在32位Linux上可以直接编译：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gcc -o goodbye_world goodbye_world.c -lcurses
$ ./goodbye_world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在64位Linux上，需要预先安装相应的GCC 32位库支持（gcc-multilib）和lib32-ncurses，然后指定用32位来编译：（直接拿64位库编译的话世界末日是不会降临的哦）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gcc -m32 -o goodbye_world goodbye_world.c -lcurses
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（本来是想用bash写个更轻量级的演示的，无奈Shell的及早求值实在是太坑爹了，折腾半天也没弄出来。。。囧rt）&lt;/p&gt;

&lt;h2&gt;文件系统的时间戳（Timestamp）&lt;/h2&gt;

&lt;p&gt;世界末日模拟完，娱乐一把，本来就该到此结束了。忽然又想到这个问题，稍微研究了一下，觉得值得写一写。&lt;/p&gt;

&lt;p&gt;把操作系统的&lt;code&gt;time_t&lt;/code&gt;从32位迁移到64位，看似完美地解决了系统时钟的2038年问题，但是事情远没有这么简单。以下这段话原封不动摘自Wikipedia：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;While this solves the problem for executing programs, it does not, however, solve the problem of storing date values within binary data files, many of which employ rigid storage formats.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;前面所提到的2038年问题的解决方案仅仅是针对Unix本身的操作系统时间而言。你也许已经知道，在Unix的大多数典型的文件系统上，文件inode的元数据（包括文件的用户、组、权限和时间戳这些附加信息）被存储在一个特殊的叫做inode table的附加区域上，而这个元数据域的宽度对于每种特定的文件系统来说显然是固定不变的，也就是说，即使你把操作系统从32位升级到了64位，现有文件系统上时间戳的数据宽度限制也不会改变。换言之，除非你升级了文件系统或者把数据迁移到新的分区上，否则，这些文件的时间戳仍然会受到旧时代文件系统的32 bits限制。&lt;/p&gt;

&lt;p&gt;下面的内容略技术硬核。欢迎熟悉Linux的文件系统这部分实现的童鞋围观指正……&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ja.wikipedia.org/wiki/2038%E5%B9%B4%E5%95%8F%E9%A1%8C#.E7.B5.8C.E7.B7.AF&quot;&gt;Wikipedia上面&lt;/a&gt;已经清清楚楚地写着ext2、ext3、ReiserFS都会受到2038年问题的影响。这几个都是比较老的文件系统，很容易推测它们的inode时间戳都采用了和早期32位Unix相同的32位&lt;code&gt;signed int&lt;/code&gt;来存储。正好我的硬盘上也没有这些文件系统，于是就不用去考虑它们了。&lt;/p&gt;

&lt;p&gt;我所要研究的对象是ext4，Linux上用来接替ext3的新一代文件系统，也是我硬盘分区所使用的主要文件系统。&lt;/p&gt;

&lt;p&gt;再次引用&lt;a href=&quot;http://en.wikipedia.org/wiki/Ext4#Features&quot;&gt;维基娘&lt;/a&gt;的一段话：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As computers become faster in general and as Linux becomes used more for mission-critical applications, the granularity of second-based timestamps becomes insufficient. To solve this, ext4 provides timestamps measured in nanoseconds. In addition, 2 bits of the expanded timestamp field are added to the most significant bits of the seconds field of the timestamps to defer the year 2038 problem for an additional 204 years.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;根据我查到的信息，ext4在inode时间戳上的改进体现在两处：一、加入了用以表示纳秒的位，记录时间戳能够精确到以纳秒为单位，以应对现代计算机日益增长的速度和时间精确度需求（尤其是在NFS上面），而Unix本身的系统时间单位只精确到秒；二、加入了两个额外的用以表示秒的位，将2038年问题推迟了额外的204年。&lt;/p&gt;

&lt;p&gt;204年这个结果看似相当合理。增加了2个二进制位，68 x 2^2 = 272年，再减去已经过去的68年，ext4到了2038年之后还能再继续撑204年，大约到2242年为止。然而，维基百科的“Date range”一栏，却写着一项与上面204年的说法相矛盾的数据：&lt;strong&gt;14 December 1901 - 25 April 2514&lt;/strong&gt;，此外，&lt;a href=&quot;https://heiher.info/291.html#1.12.&quot;&gt;这篇博客&lt;/a&gt;上的说法也是“把2038问题的发生推迟了大约500年”。&lt;/p&gt;

&lt;p&gt;到底孰真孰假，只有自己试了才知道。首先，设置环境时区一律为UTC，这是为了计算和比较的便利（本人在CET区，一年中的日期有时是UTC+1有时是UTC+2，坑爹的夏令时啊&amp;gt;_&amp;lt;）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ export TZ=&amp;quot;UTC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个任意内容的新文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ echo Bazinga! &amp;gt; Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用&lt;code&gt;touch&lt;/code&gt;命令把文件的mtime时间戳改到2080年（这个日期在2038年世界末日之后……至于为什么是2080年你懂的。但愿Sheldon他老人家能活到那个时候）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -m -t 208010171017.50 Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把atime时间戳改到2106年2月7日的某个时候（后面会解释这样做的原因）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 210602070628.16 Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;准备就绪。用&lt;code&gt;ls -i&lt;/code&gt;查看文件的inode号：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ls -i Sheldon
4089151 Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用&lt;code&gt;ls -lu&lt;/code&gt;、&lt;code&gt;ls -l&lt;/code&gt;和&lt;code&gt;ls -lu&lt;/code&gt;这几个命令可以分别查看文件的atime、mtime和ctime时间戳。在当前系统下，它们一切显示正常：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ls -lu Sheldon
-rw-r--r-- 1 soimort users 9 Feb  7  2106 Sheldon

$ ls -l Sheldon
-rw-r--r-- 1 soimort users 9 Oct 17  2080 Sheldon

$ ls -lc Sheldon
-rw-r--r-- 1 soimort users 9 Dec 23 00:50 Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以用系统的&lt;code&gt;stat&lt;/code&gt;命令来查看详细的inode信息（包括了所有三个时间戳在内）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ stat Sheldon
  File: ‘Sheldon’
  Size: 9           Blocks: 8          IO Block: 4096   regular file
Device: 809h/2057d  Inode: 4089151     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/ soimort)   Gid: (  100/   users)
Access: 2106-02-07 06:28:16.000000000 +0000
Modify: 2080-10-17 10:17:50.000000000 +0000
Change: 2012-12-23 00:50:05.746118609 +0000
 Birth: -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有&lt;a href=&quot;http://www.sleuthkit.org/sleuthkit/&quot;&gt;Sleuth Kit&lt;/a&gt;工具包，可以试着用它的&lt;code&gt;istat&lt;/code&gt;来查看一下inode信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo istat /dev/sda9 `ls -i Sheldon | cut -d&amp;quot; &amp;quot; -f1`
inode: 4089151
Allocated
Group: 499
Generation Id: 1058790298
uid / gid: 1000 / 100
mode: rrw-r--r--
Flags: 
size: 9
num of links: 1

Inode Times:
Accessed:       Thu Jan  1 00:00:00 1970
File Modified:  Thu Oct 17 10:17:50 2080
Inode Modified: Sun Dec 23 00:50:05 2012

Direct Blocks:
127754
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，则是&lt;code&gt;debugfs&lt;/code&gt;工具的输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ echo &amp;quot;stat /soimort/Sheldon&amp;quot; | sudo debugfs /dev/sda9
debugfs 1.42.3 (14-May-2012)
debugfs:  stat /soimort/Sheldon
Inode: 4089151   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 1058790298    Version: 0x00000000:00000001
User:  1000   Group:   100   Size: 9
File ACL: 0    Directory ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x50d6553d:b1e37744 -- Sun Dec 23 00:50:05 2012
 atime: 0x00000000:00000001 -- Thu Jan  1 00:00:00 1970
 mtime: 0xd0669d4e:00000000 -- Thu Oct 17 10:17:50 2080
crtime: 0x50d6549a:0a32e390 -- Sun Dec 23 00:47:22 2012
Size of extra inode fields: 28
EXTENTS:
(0):16287283
debugfs:  %
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是发现，&lt;code&gt;istat&lt;/code&gt;和&lt;code&gt;debugfs&lt;/code&gt;在ext4文件系统上能够解释出2080年（在2038年后）的时间戳，但是仅仅到了2106年2月7日06:28.15（UTC）就为止了！从该时间以后（2106年2月7日06:28.16），这些诊断工具显示的时间戳将倒回1970年。&lt;/p&gt;

&lt;p&gt;ext4为inode table中的每个时间戳分配了额外的2 bits，因此它所能表示的年份范围，怎么看都不会只到2106年为止（每增加1个bit就得把原来的范围乘以2么）。Linux系统本身的&lt;code&gt;stat&lt;/code&gt;能够正确地解释这些2106年以后的时间戳，而&lt;code&gt;istat&lt;/code&gt;和&lt;code&gt;debugfs&lt;/code&gt;却不能，这个，只能说是这些诊断工具没能完全兼容ext4标准导致的错误了。比较一下&lt;code&gt;debugfs&lt;/code&gt;在atime时间戳溢出前后的两次输出：（信息量略大）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 210602070628.15 Sheldon
$ echo &amp;quot;stat /soimort/Sheldon&amp;quot; | sudo debugfs /dev/sda9
 atime: 0xffffffff:00000000 -- Sun Feb  7 06:28:15 2106

$ touch -a -t 210602070628.16 Sheldon
$ echo &amp;quot;stat /soimort/Sheldon&amp;quot; | sudo debugfs /dev/sda9
 atime: 0x00000000:00000001 -- Thu Jan  1 00:00:00 1970
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前32位是Unix时间的秒，后32位是ext4中新增加的用于表达纳秒的位——准确地说，是30位：只有前30位被真正地用来存储纳秒值，低端的2位则被用来扩展秒的存储位数。也就是说，2106年2月7日06:28.16这个时刻真正的秒数值是0x0100000000（实际占用33位，超过了ext3传统的标准32位），纳秒数值则为0。而&lt;code&gt;debugfs&lt;/code&gt;（和&lt;code&gt;istat&lt;/code&gt;）直接无视ext4扩充的2位，直接把这个秒数当作32位数0x00000000来识别处理，自然也就回到了Unix纪元的原点——1970年1月1日0时0分0秒。&lt;/p&gt;

&lt;p&gt;0xffffffff本来似乎是一个有符号整型（转换成十进制的话是-1），应该被解释成1969年12月31日23时59分59秒才对——但是估计考虑到不会有人特地去创建时间戳在那个时候的文件，看起来也不大可能有1970年之前创建的文件被流传下来，&lt;code&gt;debugfs&lt;/code&gt;就把它自动当作一个无符号整型来识别了。所以，即使是在存在2038年问题的32位系统上，&lt;code&gt;debugfs&lt;/code&gt;仍然会显示出2106年2月7日这样的时间戳日期，因为&lt;code&gt;debugfs&lt;/code&gt;这类工具把32位有符号整型当作无符号整型来用了——不过2106年2月8日之后当然肯定是不行滴。&lt;/p&gt;

&lt;p&gt;接下来要做的事情，就是看一下这些元数据是怎样在inode table中实际存储的。首先通过&lt;code&gt;debugfs&lt;/code&gt;的imap定位出文件的inode table所在的block（注意不是inode指针所指向的direct或indirect block位置，而是&lt;strong&gt;inode table信息自身所在&lt;/strong&gt;的block位置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ echo &amp;quot;imap /soimort/Sheldon&amp;quot; | sudo debugfs /dev/sda9
debugfs 1.42.3 (14-May-2012)
debugfs:  imap /soimort/Sheldon
Inode 4089151 is part of block group 499
    located at block 16254579, offset 0x0e00
debugfs:  % 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到相应的inode table在分区的第16254579个block，偏移量0x0e00（十进制数3584）。用&lt;code&gt;dd&lt;/code&gt;可以把这部分数据直接dump成一个文件（大小不多不少正好256字节，这个是由&lt;a href=&quot;https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Extended_Attributes&quot;&gt;ext4中inode结构的实现&lt;/a&gt;所决定的）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo dd if=/dev/sda9 ibs=4096 skip=16254579 count=1 \
&amp;gt; | dd ibs=1 skip=3584 count=256 &amp;gt; Sheldon.inode
1+0 records in
8+0 records out
4096 bytes (4.1 kB) copied, 6.3151e-05 s, 64.9 MB/s
256+0 records in
0+1 records out
256 bytes (256 B) copied, 0.00395504 s, 64.7 kB/s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用GHex查看（注意用颜色框出来的部分）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qMxd3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再拿它与&lt;code&gt;debugfs&lt;/code&gt;的结果作比较（只看3个时间戳的二进制位）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ echo &amp;quot;stat /soimort/Sheldon&amp;quot; | sudo debugfs /dev/sda9
debugfs 1.42.3 (14-May-2012)
debugfs:  stat /soimort/Sheldon
Inode: 4089151   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 1058790298    Version: 0x00000000:00000001
User:  1000   Group:   100   Size: 9
File ACL: 0    Directory ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x50d6566a:5c0fc258 -- Sun Dec 23 00:55:06 2012
 atime: 0xffffffff:00000000 -- Sun Feb  7 06:28:15 2106
 mtime: 0xd0669d4e:00000000 -- Thu Oct 17 10:17:50 2080
crtime: 0x50d6549a:0a32e390 -- Sun Dec 23 00:47:22 2012
Size of extra inode fields: 28
EXTENTS:
(0):16287283
debugfs:  %
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;前一个红色方框是atime的32 bits秒数域，后一个红色方框是ext4中新增加的附加域（包含30 bits纳秒数 + 2 bits秒数）；&lt;/li&gt;
&lt;li&gt;前一个蓝色方框是ctime的32 bits秒数域，后一个蓝色方框是ext4中新增加的附加域（包含30 bits纳秒数 + 2 bits秒数）；&lt;/li&gt;
&lt;li&gt;前一个绿色方框是mtime的32 bits秒数域，后一个绿色方框是ext4中新增加的附加域（包含30 bits纳秒数 + 2 bits秒数）；&lt;/li&gt;
&lt;li&gt;橙色方框中是crtime的秒数域以及附加域。crtime是ext4中新增加的一个域，用来作为文件创建时间的时间戳（你也许已经知道，以前的Linux文件系统上并没有“文件创建时间”的说法，这包括ext2和ext3）。正如&lt;a href=&quot;https://plus.google.com/117091380454742934025/&quot;&gt;Theodore Ts&amp;#39;o&lt;/a&gt;（Linux的核心开发者之一，ext3和ext4的主要设计者）所指出的那样，在ext4设计之时，增加一个额外的crtime域很容易就能办到；然而，要让现有的库（包括Linux的&lt;code&gt;stat()&lt;/code&gt;系统调用）去支持新增加的域并和旧版本保持兼容，却远非一件易事，这需要不同项目之间的协作（我觉得这主要说的是Linux和GNU……）。所以直到目前为止，crtime域对用户程序仍然是不可见的，不仅任何桌面环境的文件管理器中都看不到“文件创建时间”一项，&lt;code&gt;stat&lt;/code&gt;命令也不会显示出crtime域。你只有自己去读文件系统的inode table，或者使用&lt;code&gt;debugfs&lt;/code&gt;这类诊断工具才能看得到它。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到最初的问题上去，ext4的时间戳究竟会在哪一年停摆，或者说，在2038年之后还能再撑多少年？果真是如前面计算的那样（和维基百科的说法一致）是68 x (2^2 - 1) = 204年，还是476年？&lt;/p&gt;

&lt;p&gt;从前面的结果我们看到，在ext4文件系统上，如果一个inode table的atime时间戳值被设为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;atime: 0x00000000:00000001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时间戳代表的真实时间值（0x0100000000 = 1 x 2^32 = 4294967296），显然应该以&lt;code&gt;stat&lt;/code&gt;命令（这个命令依赖于&lt;code&gt;stat()&lt;/code&gt;系统调用）的结果为准：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Sun Feb  7 06:28:16 UTC 2106
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道，ext4上扩充后的时间戳位数是32 + 2 = 34，所能表示的最大整数值应该是0x03FFFFFFFF = 4 x 2^32 - 1 = 17179869183。它所代表的实际时间是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ date -d @17179869183
Wed May 30 01:53:03 UTC 2514
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（按照这个计算，ext4时间戳所能表示的日期范围应该是从1 Jan 1970到30 May 2514——我没能搞明白维基百科上“Date range”一栏的14 December 1901 - 25 April 2514这个数据到底是怎么算出来的，因为34 bits秒数所能表示的年份跨度显然不可能超过544年）&lt;/p&gt;

&lt;p&gt;不妨试着把时间戳改到这个点，再用&lt;code&gt;stat&lt;/code&gt;看看：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 251405300153.03 Sheldon
$ stat Sheldon | grep &amp;quot;Access: [^(]&amp;quot;
Access: 2514-05-30 01:53:03.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你看到了，&lt;strong&gt;看起来&lt;/strong&gt;ext4似乎确实能够存储直到2514年的日期。这可以理解为系统把0x03FFFFFFFF当作了无符号整型来处理，所以1970 + 68 x 8 = 2514——这是它所能表示的最大年份。确实，谁会需要用到一个1970 ± 68 x 4范围的时间戳呢？谁的Unix系统会穿越到19世纪以前去修改文件呢？&lt;/p&gt;

&lt;p&gt;2514 - 2038 = 476，所以，ext4到底在2038年之后还能继续使用多少年，大约476年才是正确答案，而不是204年。&lt;/p&gt;

&lt;p&gt;得到这个结论看似很合理，2514年5月30日，对于现代的我们来说已经足够遥远了。不过，它仍然算不上是一个“正确”的答案——你将会看到为什么。&lt;/p&gt;

&lt;p&gt;虽说64位的Linux已经能够处理直到3千亿年以后的系统时间，但是，由于ext4的inode时间戳的34位限制，它最多也只可能保存到2514年的时间戳信息（btw，除非利用到文件系统上一个额外的叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Extended_file_attributes&quot;&gt;xattr&lt;/a&gt;的区域，这点暂不讨论，因为这和具体的文件有关，文件系统本身并不解释这部分额外的信息）。&lt;/p&gt;

&lt;p&gt;现在，如果你手头正好用的是64位Linux和ext4分区，不妨试着把文件的atime时间戳改到西元9999年的12月31日（因为&lt;code&gt;touch -t&lt;/code&gt;所能识别的格式字符串有长度限制，所以这里没有用10000年以后的时间）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 999912312359.59 Sheldon
$ stat Sheldon | grep &amp;quot;Access: [^(]&amp;quot;
Access: 9999-12-31 23:59:59.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很奇怪不是吗。ext4上inode的34位时间戳绝对没有可能存储得了西元9999年这样的时间，本来你应该期望它退回过去的某个时间点，但是系统的&lt;code&gt;stat()&lt;/code&gt;调用却给了你原来分配的准确时间戳，即使这个时间戳在ext4中已经大大地越界了。问题出在哪里？&lt;/p&gt;

&lt;h2&gt;虚拟文件系统（VFS）的时间戳&lt;/h2&gt;

&lt;p&gt;其实说穿了，也没什么好奇怪的。是因为Linux内核与真实的文件系统驱动之间的通信，基于&lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_file_system&quot;&gt;虚拟文件系统（Virtual File System, VFS）&lt;/a&gt;这样一个中间层。&lt;/p&gt;

&lt;p&gt;当你作为用户态改写一个文件时，它的inode变动并不会立即被写入到ext4分区上去；同样，当你执行系统的&lt;code&gt;stat()&lt;/code&gt;调用时，它也并不总是直接去读取真实的ext4分区上的inode信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stat()&lt;/code&gt;系统调用读取的其实是VFS inode，存在于VFS中的inode cache缓存区域（参考：&lt;a href=&quot;http://www.tldp.org/LDP/tlk/fs/filesystem.html&quot;&gt;http://www.tldp.org/LDP/tlk/fs/filesystem.html&lt;/a&gt;）。类似地，通过系统调用写入文件的inode时，实际上写的也是VFS inode。这一点在BSD中也许能看得更明显，因为Linux kernel中对应的结构实现是&lt;code&gt;struct inode&lt;/code&gt;，而BSD中则被命名为&lt;code&gt;vnode&lt;/code&gt;（v代表virtual file system layer，这有助于将其和真实文件系统的inode相区分）。（参考自：&lt;a href=&quot;http://en.wikipedia.org/wiki/Inode&quot;&gt;http://en.wikipedia.org/wiki/Inode&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;嗯，当然inode是不会一直放在VFS的缓存里的。执行&lt;code&gt;umount&lt;/code&gt;的时候，你告诉系统这个分区的任务已经结束了，然后系统就会自动把未写入实际文件系统上的inode信息给写回去，清理VFS缓存。（这也是为什么你需要在拔掉移动硬盘前先去unmount、以及为什么系统关机的时候会去自动unmount每个分区的原因。如果不这样做，这些VFS中的inode缓存信息就可能会丢失）&lt;/p&gt;

&lt;p&gt;这与实际文件系统的时间戳有什么关系呢？总结起来，一句话：你所看到的时间戳可能并不是真实的存储在ext4文件系统上的时间戳，而是VFS inode cache中临时存储的时间戳。要想知道真实ext4文件系统上的inode时间戳，最简单的办法，就是卸载掉分区之后再重新挂载，这样就可以保证VFS中的inode cache被确实地写到了真实文件系统里。&lt;/p&gt;

&lt;p&gt;这么一来，提醒了我们前面直接修改过时间戳之后用&lt;code&gt;stat&lt;/code&gt;看到的也许不是真实ext4文件系统上存储的时间戳信息。不妨来做一个试验。首先挂载所要用的分区（我用了另外一个单独的ext4分区，毕竟要反复地挂载卸载什么的）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo mount -t ext4 /dev/sda8 /run/media/soimort/sda8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个atime时间戳为2446年5月10日22:38.55（UTC）的文件（暂时先别管这个日期是怎么来的。如果之前关于ext4能在2038年之后继续使用476年的推测是正确的话，那么显然，2446年应该在inode时间戳的“合法”范围之内）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 244605102238.55 /run/media/soimort/sda8/mort/Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新挂载分区，确保inode table已经写入实际文件系统。再查看atime时间戳：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo umount /dev/sda8;\
&amp;gt; sudo mount -t ext4 /dev/sda8 /run/media/soimort/sda8;\
&amp;gt; stat /run/media/soimort/sda8/mort/Sheldon | grep &amp;quot;Access: [^(]&amp;quot;
Access: 2446-05-10 22:38:55.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;时间戳显示正常。&lt;/p&gt;

&lt;p&gt;再把atime时间戳改到下一秒钟的2446年5月10日22:38.56（UTC）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 244605102238.55 /run/media/soimort/sda8/mort/Sheldon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新挂载分区，确保inode table已经写入实际文件系统。再查看atime时间戳：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo umount /dev/sda8;\
&amp;gt; sudo mount -t ext4 /dev/sda8 /run/media/soimort/sda8;\
&amp;gt; stat /run/media/soimort/sda8/mort/Sheldon | grep &amp;quot;Access: [^(]&amp;quot;
Access: 1901-12-13 20:45:52.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;时间跳回1901年了。也就是说，2446年5月10日22:38.55（UTC）这个点存储在ext4文件系统中的时间戳可以被&lt;code&gt;stat&lt;/code&gt;正常解析，但是2446年5月10日22:38.56（UTC）却不能！这推翻了我们之前关于ext4可以正常用到2514年的那个推测。&lt;/p&gt;

&lt;p&gt;事实上，我很快就发现，在时间戳被确实写入ext4文件系统之后，它甚至连2038年1月19日都撑不过去：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ touch -a -t 203801190314.08 /run/media/soimort/sda8/mort/Sheldon
$ sudo umount /dev/sda8;\
&amp;gt; sudo mount -t ext4 /dev/sda8 /run/media/soimort/sda8;\
&amp;gt; stat /run/media/soimort/sda8/mort/Sheldon | grep &amp;quot;Access: [^(]&amp;quot;
Access: 1901-12-13 20:45:52.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，当ext4中的inode时间戳被真正修改之后，尽管它可以保存有34位的数据宽度，但是系统的&lt;code&gt;stat&lt;/code&gt;却只认前面的32位，而且是把它当作有符号整型——即使是在64位Linux上。可以理解这是&lt;code&gt;stat()&lt;/code&gt;系统调用为了同以前的ext2、ext3保持兼容，但这也使得ext4为了解决2038年问题而新增加2位所做的努力变得形同虚设。&lt;/p&gt;

&lt;p&gt;举例来说，在2038年世界末日前一秒的时间戳，inode table的dump结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;atime: 0x7fffffff:00000000 -- Tue Jan 19 03:14:07 2038
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;0x7fffffff作为一个有符号整型，相当于十进制的+2147483647，这是32位时间戳所能表示的最大Unix时钟值。&lt;/p&gt;

&lt;p&gt;下一秒的时间戳：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;atime: 0x80000000:00000000 -- Tue Jan 19 03:14:08 2038
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;0x80000000作为一个有符号整型，相当于十进制的-2147483648，因此，&lt;code&gt;stat()&lt;/code&gt;调用得到的inode时间戳是：（在VFS缓存写入实际文件系统之后）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Access: 1901-12-13 20:45:52.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要想利用ext4中额外增加的2 bits来扩充时间戳的长度，一个必要条件是系统把0x7fffffff的下一秒钟（0x80000000）当作正整数来解析，只有这样才能保证时间戳的连续性。如果这样的话，&lt;code&gt;stat()&lt;/code&gt;调用把0x80000000识别出来的时间应该是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Access: 2038-01-19 03:14:08.000000000 +0000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，这么做就破坏了原有代码（和文件系统）的兼容性！想一想，在原来的旧文件系统上，0x80000000这个时间戳毫无疑问，表示的只能是1901年；而现在，它将被解析成2038年。而且，原来的所有从1901年12月13日到1969年12月31日之间的时间戳都将造成错误——它们将被解释成2038年之后的时间。虽然我不认为保持这样的兼容性很重要（1970年之前甚至都没有Unix系统——为什么Ken Thompson当初会想到用有符号整型而不是直接拿无符号整型来表示时间？），不过显然，现有的代码不可能做出这么轻率的改动，也就是说，在未来可预见的一段时期内，&lt;code&gt;stat()&lt;/code&gt;系统调用的结果还将和原来保持兼容——32位有符号整型，过了0x7fffffff就把一切时间戳都解释为负数，+2147483647的下一个数将是-2147483648。&lt;/p&gt;

&lt;p&gt;所以，回到最初的问题上，ext4这新增加的2 bits到底能把2038年问题推迟多长时间？204年，还是476年？我认为，从现实的角度来说，这个答案是：0。&lt;/p&gt;

&lt;p&gt;说是204年或者476年，从理论上都没有错，这取决于具体的系统（如果有这样的系统的话）怎样去实现，是把这个34位数当作有符号数还是无符号数。但是就现有的GNU/Linux系统而言，只要&lt;code&gt;stat()&lt;/code&gt;与原来的版本保持兼容性一天，它就必须得保持32位有符号时间戳的处理方式一天。如今，几乎你所能见到的绝大多数执行文件操作的用户程序都直接或间接地调用了&lt;code&gt;stat()&lt;/code&gt;（除了一些底层的文件系统处理和诊断工具之外）。因此，虽然Linux的VFS本身能够完美地向ext4的inode table写入34位的时间戳，记录直到500年后的时间，但是，至少对于所有基于现有&lt;code&gt;stat()&lt;/code&gt;系统调用的用户程序而言，ext4这增加的2 bits并没有发挥什么实际的作用。&lt;/p&gt;

&lt;h2&gt;补充：关于stat()和VFS的一些理解&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;系统调用&lt;code&gt;stat()&lt;/code&gt;并不直接从实际文件系统中读取inode信息。它需要经过操作系统提供的VFS这个中间层。VFS实际上可以看成是Linux提供给高阶的用户应用程序（比如，一个执行了&lt;code&gt;stat()&lt;/code&gt;系统调用的C程序）到底层具体文件系统驱动的现成接口。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当&lt;code&gt;stat()&lt;/code&gt;直接与VFS打交道时，它从VFS的inode cache中所获取到的inode时间戳位数直接与系统时间的位数相关，而无关实际文件系统上的时间戳限制（因为VFS是独立于具体文件系统实现的一个&lt;strong&gt;抽象&lt;/strong&gt;接口）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了充分理解上面一点，在64位系统上，你可以试一下这个简单的&lt;code&gt;stat()&lt;/code&gt;调用程序：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://gist.github.com/4366391.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;如果使用默认的64位C库编译，&lt;code&gt;stat()&lt;/code&gt;能够正确返回某个文件VFS inode中的64位时间戳；如果使用32位库编译，它只能够正确输出inode的32位时间戳（这个就是系统&lt;code&gt;time_t&lt;/code&gt;位数而不是具体文件系统所导致的2038年问题了）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从抽象的VFS延伸到实际的文件系统中时，问题就变得复杂许多。以64位Linux为例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你可以向任意一个文件的inode中写入长达64位的时间戳（可以一直延用至太阳系灭亡的时候），你也可以立即调用&lt;code&gt;stat()&lt;/code&gt;查看这个时间戳，因为在64位系统上的VFS inode和&lt;code&gt;stat()&lt;/code&gt;都能够正确地处理64位的时间；但是，这64位时间戳最终将无法被恰当地存储到ext4文件系统中。它的存活期只能是在VFS的inode cache中。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你可以向任意一个文件的inode中写入长达34位的时间戳（可以延用到500年后），理所当然地，64位系统上VFS inode和&lt;code&gt;stat()&lt;/code&gt;处理它自然不成问题；这34位时间戳也&lt;strong&gt;能够&lt;/strong&gt;被正确地保存到ext4文件系统的inode table中。但是，在需要从实际文件系统中读取inode的时间戳时，为了保持最高的双向兼容性（一方面是为了旧的程序和新的ext4时间戳格式兼容；一方面也是为了新的程序和旧的ext3时间戳格式兼容），当前的&lt;code&gt;stat()&lt;/code&gt;系统调用只能读取到时间戳的前32位，并且把它当作有符号整型来看待。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从上一点来看，ext4的inode时间戳与ext3在实用范畴内（所有依赖于&lt;code&gt;stat()&lt;/code&gt;的用户程序）并没有什么区别。当然，如果你使用dump或者e2fsprog之类的底层调试工具，你还是能看到文件系统记录下来的完整34位时间戳。这是ext4的时间戳比起ext3来的唯一好处。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你可以向任意一个文件的inode中写入长达32位的时间戳。它可以从VFS inode cache中被完整地写入实际的ext4分区，也可以被&lt;code&gt;stat()&lt;/code&gt;系统调用正确地读取，可以用&lt;code&gt;stat&lt;/code&gt;命令显示出正确的日期，不会造成溢出。当然，这一切等到32位整数表示时间的终点——2038年1月19日，就会结束了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;其他文件系统的时间戳与2038年问题&lt;/h2&gt;

&lt;p&gt;过时的文件系统（ext2、ext3、ReiserFS）这里就不提了。它们采用了&lt;strong&gt;32位时间戳&lt;/strong&gt;，这决定了它们最晚到2038年之前必将遭遇被淘汰的命运。&lt;/p&gt;

&lt;p&gt;ext4（我目前正在用的文件系统，也许是目前Linux中用得最普遍的文件系统），虽然从理论上它的&lt;strong&gt;32+2位时间戳&lt;/strong&gt;可以一直工作到2514年，但是由于如前所述&lt;code&gt;stat()&lt;/code&gt;系统调用实现上的遗留问题——至少是在我现在的系统上，我不认为它可以在2038年后依然正常工作，因为没有哪个应用软件能够正确处理新的时间戳（虽然直到2514年的时间戳都能够被ext4完完整整地存储在那里，但你就是看不到它，一般的用户程序也看不到它——如果只通过正常的系统调用而不采取dump手段的话）。只要系统的C POSIX库一天不升级，它就会始终受制于32位时间戳长度的兼容性，即使是在64位Linux系统上。&lt;/p&gt;

&lt;h3&gt;Apple HFS+&lt;/h3&gt;

&lt;p&gt;苹果目前所使用的文件系统没有2038年问题。因为它的时间戳终结在&lt;a href=&quot;http://en.wikipedia.org/wiki/HFS%2B&quot;&gt;2040年&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同样基于Unix时间纪元的Mac OS X会去使用一个2040年而非2038年到期的文件系统，我不知道这样设计的理由，我也不太感兴趣苹果打算如何去解决这个问题。你认为一台Macbook最多能用多少年？&lt;/p&gt;

&lt;h3&gt;NTFS&lt;/h3&gt;

&lt;p&gt;与你们这些流氓操作系统做出来的东西有着本质上的不同，微软的文件系统是具有充分的预见性的。几乎濒临淘汰的FAT甚至到&lt;a href=&quot;http://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs#Year_2107&quot;&gt;2107年&lt;/a&gt;才会发生时间戳溢出，比起现在Linux上的大部分文件系统都要晚70年。NTFS更是用到&lt;a href=&quot;http://en.wikipedia.org/wiki/NTFS&quot;&gt;60000年&lt;/a&gt;都不会过时。&lt;/p&gt;

&lt;p&gt;以下内容摘自NTFS-3G driver的注释：（它的说法是到西元57000年）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;/**
  * ntfs2timespec - Convert an NTFS time to Unix time
  * @ntfs_time:  An NTFS time in 100ns units since 1601
  *
  * NTFS stores times as the number of 100ns intervals since January 1st 1601 at
  * 00:00 UTC.  This system will not suffer from Y2K problems until ~57000AD.
  *
  * Return:  A Unix time (number of seconds since 1970, and nanoseconds)
  */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ZFS和UFS2&lt;/h3&gt;

&lt;p&gt;个人推测用在BSD和Solaris上的服务器文件系统，时间戳宽度应该不会太短。不过我没找到关于这两个文件系统实现细节的文档，如果你知道，请告诉我。&lt;/p&gt;

&lt;h3&gt;Reiser4&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reiser4&quot;&gt;Reiser4&lt;/a&gt;的出现无疑是划时代的，它第一次采用了&lt;strong&gt;64位时间戳&lt;/strong&gt;，从而把Linux文件系统的末日彻底推迟到了地球毁灭之后。这曾经被认为是一个前景无限的文件系统，直到&lt;a href=&quot;http://en.wikipedia.org/wiki/Hans_Reiser&quot;&gt;它的作者&lt;/a&gt;把自己的名声连同这个文件系统的光明前途一起亲手毁灭之前。开发停滞是一个方面；此外，它的某些特性因为过于先进，在Linux的VFS层中尚没有对应的API去实现，鉴于作者本人还要继续蹲上n年大牢，估计将来也很难再有人去实现它们。&lt;/p&gt;

&lt;h3&gt;Btrfs&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Btrfs&quot;&gt;Btrfs&lt;/a&gt;被设计成用来取代ext4的下一代Linux文件系统。它从ZFS和Reiser4这些较先进的文件系统中借鉴了许多东西。&lt;/p&gt;

&lt;p&gt;Btrfs的&lt;a href=&quot;https://btrfs.wiki.kernel.org/index.php/On-disk_Format#INODE_ITEM_.2801.29&quot;&gt;INODE_ITEM&lt;/a&gt;包含atime、ctime、mtime和一个保留的otime时间戳。它们的&lt;a href=&quot;https://btrfs.wiki.kernel.org/index.php/On-disk_Format#Basic_Structures&quot;&gt;TIME结构&lt;/a&gt;由用于存储秒的&lt;strong&gt;64位有符号整型&lt;/strong&gt;和用于存储纳秒的&lt;strong&gt;32位无符号整型&lt;/strong&gt;组成。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;ext4被Linux开发者认为只是一个过渡性质的文件系统。如果现有libc（包括GNU libc和其他的POSIX库实现）中的&lt;code&gt;stat()&lt;/code&gt;系统调用与其他应用程序的前向兼容性问题能够在2038年之前彻底消除，那么ext4还可以在2038年之后继续用500年（到2514年为止）。就当前的情况来看（我的系统上是glibc 2.15），ext4的时间戳对于大多数用户态应用程序而言仍然会在32位用完之后发生溢出，而不是当初设计时预想的34位。&lt;/p&gt;

&lt;p&gt;不过我确信到了那时，所有的Unix系统应该都升级到了64位，基于64位时间戳的Btrfs（或者其他什么新的玩意，谁知道呢）也应该早就取代了旧的基于32位时间戳的文件系统（ext2、ext3）和过渡性质的32+2位时间戳文件系统（ext4）。只要C POSIX库的兼容性问题能在那之前解决，2038年1月19日这个日期就变得不再重要，未来人会说：你看，古人还在担心什么2038年世界末日，这真是杞人忧天啊，我们连手机都早换成128位的了。否则，如果兼容性问题迟迟得不到解决，人们就会当初面临千年虫问题那样慌乱。（事实上这问题应该比千年虫严重得多，因为在服务器领域绝对是Unix系统占统治地位）&lt;/p&gt;

&lt;p&gt;做出来新的东西去解决一个问题也许并不困难。但是既要改变底层的实现又要不破坏现有接口与那些legacy code的兼容，这才是解决2038年问题所真正面临的挑战吧。&lt;/p&gt;

&lt;h2&gt;参考资料 / 相关链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关于2038年问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Year_2038_problem&quot;&gt;http://en.wikipedia.org/wiki/Year_2038_problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.y2038.com/&quot;&gt;http://www.y2038.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于计算机纪元法和Unix时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Epoch_(computing)#Computing&quot;&gt;http://en.wikipedia.org/wiki/Epoch_(computing)#Computing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;http://en.wikipedia.org/wiki/Unix_time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于文件系统inode结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inode&quot;&gt;http://en.wikipedia.org/wiki/Inode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inode_pointer_structure&quot;&gt;http://en.wikipedia.org/wiki/Inode_pointer_structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://140.120.7.20/LinuxKernel/LinuxKernel/node17.html&quot;&gt;http://140.120.7.20/LinuxKernel/LinuxKernel/node17.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于GNU libc的&lt;code&gt;stat()&lt;/code&gt;系统调用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Stat_(Unix)&quot;&gt;http://en.wikipedia.org/wiki/Stat_(Unix)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.die.net/man/2/stat&quot;&gt;http://linux.die.net/man/2/stat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Reading-Attributes.html&quot;&gt;http://www.gnu.org/software/libc/manual/html_node/Reading-Attributes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_13.html&quot;&gt;http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_13.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于虚拟文件系统VFS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_file_system&quot;&gt;http://en.wikipedia.org/wiki/Virtual_file_system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/tlk/fs/filesystem.html&quot;&gt;http://www.tldp.org/LDP/tlk/fs/filesystem.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于ext4文件系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Ext4&quot;&gt;http://en.wikipedia.org/wiki/Ext4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linuxsoftware.co.nz/wiki/ext4&quot;&gt;http://linuxsoftware.co.nz/wiki/ext4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ext4的存储结构：&lt;a href=&quot;https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout&quot;&gt;https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解ext4的时间戳（非常好的文章！）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://computer-forensics.sans.org/blog/2011/03/14/digital-forensics-understanding-ext4-part-2-timestamps&quot;&gt;http://computer-forensics.sans.org/blog/2011/03/14/digital-forensics-understanding-ext4-part-2-timestamps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;e2fsprogs工具的使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/E2fsprogs&quot;&gt;http://en.wikipedia.org/wiki/E2fsprogs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.die.net/man/8/dumpe2fs&quot;&gt;http://linux.die.net/man/8/dumpe2fs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.die.net/man/8/debugfs&quot;&gt;http://linux.die.net/man/8/debugfs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于Btrfs文件系统&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Btrfs&quot;&gt;http://en.wikipedia.org/wiki/Btrfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Btrfs的存储结构：&lt;a href=&quot;https://btrfs.wiki.kernel.org/index.php/On-disk_Format&quot;&gt;https://btrfs.wiki.kernel.org/index.php/On-disk_Format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】Scala与Git：“好”的敌人是“足够好”</title>
        <link href="http://www.soimort.org/posts/128" />
        <updated>2012-12-22T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/128/scala-git</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://branchandbound.net/blog/scala/2012/12/scala-is-like-git/&quot;&gt;Scala is like Git&lt;/a&gt; by &lt;a href=&quot;http://branchandbound.net/&quot;&gt;Sander Mak&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://twitter.com/odersky&quot;&gt;Martin Odersky&lt;/a&gt;在&lt;a href=&quot;https://twitter.com/odersky/status/281797316065783808&quot;&gt;推&lt;/a&gt;上分享了&lt;a href=&quot;http://branchandbound.net/blog/scala/2012/12/scala-is-like-git/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;如果你对了解Scala语言有一些兴趣，那么&lt;a href=&quot;http://blog.typesafe.com/recounting-the-functional-programming-princip&quot;&gt;Coursera上有过他开的一门Scala课程&lt;/a&gt;：&lt;a href=&quot;https://class.coursera.org/progfun-2012-001/&quot;&gt;Functional Programming Principles in Scala&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;如果你还不知道&lt;a href=&quot;http://en.wikipedia.org/wiki/Martin_Odersky&quot;&gt;Martin Odersky&lt;/a&gt;是谁：就是他发明了Scala语言。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本文的作者是&lt;a href=&quot;https://twitter.com/Sander_Mak&quot;&gt;Sander Mak&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Scala总是被描绘成一种过于复杂的语言。很多时候，这些关于复杂性的探讨总让我联想起那些类似的关于Git复杂性的争论。我知道，把一个版本控制系统同一门编程语言放到一起来做比较，认真说起来的话多少有些蛋疼。不过，请稍安毋躁，因为我相信这会给关于Scala复杂性的争论带来一个全新的视角。&lt;/p&gt;

&lt;p&gt;Git和Scala都是强有力的工具，它们被创造出来的目的是为了不再囿于现状的大胆突破，而绝非温和式地改进。Git不只是一个更好的CVS/Subversion：它的分布式本质使它有着本质上的不同。Scala亦是如此：它不只是一个更好的Java，而是一次大胆的向FP/OO混搭编程的尝试。 &lt;em&gt;（Mort译注：虽然Git并不是第一个提出来分布式版本管理的概念，Linus写它是为了取代BitKeeper，一个闭源的商业版分布式VCS。Scala甚至也远远算不上是最早结合了FP/OOP的语言）&lt;/em&gt;有趣的是，这些关于复杂性的争论常常是在将Git或Scala同本质上局限性更明显的那些技术作比较的基础上得来的。是的，很明显，不管你在Subversion或Java中做什么事情，可能都会要容易许多。但在这些争论中本不该被忽略的一个事实是，如果使用Git和Scala，你会具备能力去完成更多的任务。这不只是有关（复杂性的）代价，更有关实际的利益。你愿意看好这些强大工具的前景而提前买入吗？ &lt;em&gt;（Mort译注：这句话应该是取自John C. Maxwell的投资名言：People buy into the leader before they buy into the vision.（人们因为看好领导者而买入要远早于看好前景而买入。））&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;强大的工具需要投资&lt;/h2&gt;

&lt;p&gt;我花了结结实实一年的时间，去实际地在一个团队环境中利用Git协作，才真切地领会到它所提供的便利之处。在此前，我只是自娱自乐地做一些简单的个人项目，主要是在GitHub上，Git的很多方面依然会使我产生困惑（为什么我需要一个临时区域（staging area）？为什么做同样一件事情会有三种方法？）通过信任那些走在我前面的人们、以及拥抱Git的团队协作特性，我的生产效率最终达到了一个前所未有的层次。Scala的学习曲线亦是相似的。尽管我在大学期间有过函数式编程方面的知识背景，但Scala仍然有许多需要我去熟悉了解的地方。如同Git一样，只有在度过了你对于这个工具并不充分熟悉的艰难阶段之后，你才能体会到它的优势竟是如此之强悍。&lt;/p&gt;

&lt;p&gt;这种在时间和精力上的投资需要肯定会为初学者带来一些障碍。然而，Git逾越了这条障碍，因为它提供了许多人们渴望已久的独特功能特性：简便的分支（branching）与合并（merging，或&lt;a href=&quot;http://typesafe.com/stack&quot;&gt;rebasing&lt;/a&gt;，我简直爱死它了！）。类似地，Scala的杀手锏是其&lt;a href=&quot;http://lampwww.epfl.ch/%7Ephaller/upmarc/&quot;&gt;无所不在的并行化&lt;/a&gt;和一套高度集成了Scala、Akka和Play的&lt;a href=&quot;http://typesafe.com/stack&quot;&gt;技术框架栈&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;干净整洁的核心&lt;/h2&gt;

&lt;p&gt;我最喜欢的关于Git和Scala的方面是，它们都采取了基于简单的概念来构建干净整洁的核心这种方法学。Git通过它的&lt;a href=&quot;http://eagain.net/articles/git-for-computer-scientists/&quot;&gt;有向无环图&lt;/a&gt;来表示commits、trees和blobs。每一个git操作本质上都是对这个图的变换（和/或图中的refs，更准确地说）。复杂吗？也许是的，而一旦你掌握了它，你就拥有了更强大的法力。Scala也可以作一个相似的类比。尽管概念的数量更加繁多——它毕竟是一门编程语言，而不是一个版本控制系统——对我来说，所有的语言特性不但在小处、更在大处常常有所体现。所有的语言特性可以被嵌套和组合书写，正如你所期望的那样。&lt;/p&gt;

&lt;p&gt;Scala有一个相对小的语言核心，这是由Scala的语言规范仅有Java语言规范的四分之一大小决定的。Scala的语法同样也很轻量级。容许我补充一句，语言规范的大小并不直接标志着语言本身能力上的优势（只要想象一下，&lt;a href=&quot;http://progopedia.com/language/brainfuck/&quot;&gt;Brainfuck语言&lt;/a&gt;）。Martin Odersky有句名言曰：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;吾尝欲赋仓颉之力于Scala言语兮，亦欲穷至简至美之道兮，唯以统合今世之猥杂程式术数义理而求索之。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;(I have always tried to make Scala a very powerful but at the same beautifully simple language, by trying to find unifications of formerly disparate concepts.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种设计哲学激发了我的强烈共鸣&lt;em&gt;（Mort：+1）&lt;/em&gt;。固然Scala没能够完全统一所有它本来应该能统一的一切，但与此同时它也成为了一个非常实用的、考虑到了实用主义式权衡的编程语言，比如和Java的互操作性之类&lt;em&gt;（Mort：说起与Java平台的实用性结合，这确实是Scala比起其他设计哲学相似的语言诸如Oz、Rust，做得更成功的地方）&lt;/em&gt;。C&amp;#39;est la vie.&lt;/p&gt;

&lt;h2&gt;复杂性&lt;/h2&gt;

&lt;p&gt;尽管Git和Scala一样都拥有简洁明了的原始核心，它们外在的复杂性却出奇地高。Git的命令行界面有&lt;a href=&quot;http://stackoverflow.com/questions/7866353/git-list-all-available-commands&quot;&gt;一大箩筐命令&lt;/a&gt;，并且因为其各种标记用法的不一致性而&lt;a href=&quot;http://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/&quot;&gt;臭名远扬&lt;/a&gt; &lt;em&gt;（Mort无责任吐槽：所以说&lt;code&gt;git remote&lt;/code&gt;和&lt;code&gt;git branch&lt;/code&gt;这两个子命令的用法当初是哪个二逼设计的嘛。。。）&lt;/em&gt;。Scala的语法对于初学者来说同样有一些&lt;a href=&quot;http://www.slideshare.net/normation/scala-dreaded&quot;&gt;让他们震精之处&lt;/a&gt;。是的，Scala也许是有那么&lt;a href=&quot;http://programmers.stackexchange.com/questions/179699/whats-the-problem-with-scalas-xml-literals&quot;&gt;一个&lt;/a&gt;或者&lt;a href=&quot;http://stackoverflow.com/questions/13011204/scalas-postfix-ops&quot;&gt;两个&lt;/a&gt;比较过分的特性。然而，一旦你去了解了内在的、联系一切事物的核心模型，这样的问题虽然起初比较困扰，但你终将克服它们。它不过是种&lt;a href=&quot;http://c2.com/cgi/wiki?AccidentalComplexity&quot;&gt;意料之外的复杂性&lt;/a&gt;。我很赞赏Scala团队为&lt;a href=&quot;http://docs.scala-lang.org/sips/pending/modularizing-language-features.html&quot;&gt;模块化语言特性&lt;/a&gt;所作出的努力，它允许了你去渐进地纠正这些问题。&lt;/p&gt;

&lt;p&gt;总而言之，在这些工具优雅的核心模型上工作，对于我来说是件挺值得的事情。当然，在Git和Scala中，你同样会有一些足够用来吊死你自己的绳索。不过你得对自己负责！&lt;/p&gt;

&lt;h2&gt;图形界面&lt;/h2&gt;

&lt;p&gt;但是事情还远没有结束。一种新技术要想被广泛认可，尤其是获得所谓“企业界”的垂青，最重要的一点就是具备良好的GUI支持。Git的GUI和Scala的IDE支持一直以来多少都有些形同鸡肋的赶脚。我甚至不太确定Git的GUI是否真的降低了使用上的复杂性。我&lt;a href=&quot;http://code.google.com/p/gitextensions/&quot;&gt;尝试过&lt;/a&gt;&lt;a href=&quot;http://code.google.com/p/tortoisegit/&quot;&gt;一些&lt;/a&gt;，但是并不喜欢它们。就Scala的那些IDE插件来说，它们简直就像是做给脑残用的一样。定位类型和隐式声明功能对于大型的项目代码库来说可是无价之宝。幸运的是，Scala的Eclipse插件现在正由&lt;a href=&quot;http://typesafe.com/&quot;&gt;Typesafe&lt;/a&gt;支持开发，并且正在快速地推进当中。IntelliJ的Scala插件进展状况也尚良好。我得说Scala在这方面的支持做得比Git要好些，尽管，公正地讲，比起其他的编程语言来还是差了一大截。&lt;/p&gt;

&lt;h2&gt;实际应用&lt;/h2&gt;

&lt;p&gt;就使用Git时来说，一件显然的事情是，它并不遵循某个特定的工作流程。因此，许多截然不同的工作流程都可能被各种倡导起来。有些甚至包括附加的工具支持，诸如&lt;a href=&quot;https://github.com/nvie/gitflow&quot;&gt;git-flow&lt;/a&gt;和&lt;a href=&quot;http://www.git-legit.org/&quot;&gt;Legit&lt;/a&gt;之流。这意味着Git本身存在缺点吗？让Git单独去完成这些任务太复杂了吗？我并不这样认为。这只是人们为了找到一个可以共同工作的起点、而又不想去重复发明轮子所得到的产物。但这也说明一点，没有哪种工作流程和支持工具最终会全面胜出。看起来，多样性才是解决问题的根本法宝。&lt;/p&gt;

&lt;p&gt;对于Scala来说，事情稍微有些不同。语言的认知度在提升，但社区仍然在寻找一个共同的“发言声音”。对于一种编程语言来说这更加关键，尤其是像Scala这种表达能力丰富的语言。说起来，Java语言，已经经过了两个十年的时间来发育成熟、孵化出被广泛认可的习语和相应的代码风格规范。我相信Scala仍然需要经历一个类似的过程。这个过程开始的标志&lt;a href=&quot;http://docs.scala-lang.org/style/&quot;&gt;已经出现&lt;/a&gt;。我们需要一本最终出现的《Effective Scala》之类的书来领路，正如&lt;a href=&quot;http://www.amazon.com/gp/product/0321356683/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321356683&amp;amp;linkCode=as2&amp;amp;tag=branandboun-20&quot;&gt;《Effective Java》&lt;/a&gt;之于Java而言。&lt;/p&gt;

&lt;h2&gt;“好”的敌人是“足够好”（The enemy of good is good enough）&lt;/h2&gt;

&lt;p&gt;为什么人们要从SVN迁移到Git，或者，从Java迁移到Scala？好歹Subversion也已经拥有了合并-跟踪功能，而Java 8最终也将会加入对lambdas的支持。关键点是，这些特性的增加并不能从本质上改变“旧时代”工具的核心模型。如果一定要说改变了什么，它们只是引入了有悖于初衷的、预料之外的复杂性，并没有真正地洗心革面上升到全新的发展阶段。它们对于很多人来说已经“足够好”了，我也知道，迁移自己惯用的版本控制系统或编程语言到一种新的工具上绝非弹指之劳。不过，我鼓励你们仍然应该去探索一些新的可能性、看看“足够好”是否足以成为阻止你迁移到新工具的理由。&lt;/p&gt;

&lt;p&gt;在一些堪称“现代”的技术中也存在着相互之间的竞争。Git的对头是&lt;a href=&quot;http://en.wikipedia.org/wiki/Mercurial&quot;&gt;Mercurial&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Bazaar_(software)&quot;&gt;Bazaar&lt;/a&gt;。Scala潜在的竞争对手则是&lt;a href=&quot;http://www.drdobbs.com/jvm/the-kotlin-programming-language/231500204&quot;&gt;Kotlin&lt;/a&gt;和&lt;a href=&quot;http://ceylon-lang.org/&quot;&gt;Ceylon&lt;/a&gt; &lt;em&gt;（Mort译注：这个竞争估计仅仅是就基于JVM的强/静态类型语言而言。原文的评论中有人指出，这两种语言最近两年都没什么人提了……囧）&lt;/em&gt;。所有这些替代品都把简单（simplicity）和直观性（intuitiveness）作为宣传策略上的卖点。它们起初看来可能是会更加直观些。我有点好奇它们是否必须得在核心模型和内部设计哲学上做出妥协，以达到外部接口的直观性。融合面向对象与函数式两种编程范式的确是一项艰巨的工作。等到这些新的程序语言有了比较体面的发布版本之后，我一定会再回顾一下这个问题。&lt;/p&gt;

&lt;p&gt;归根结底，Git的胜出是因为它提供了看得见摸得着的好处，尽管它表面上看起来可能略复杂。Scala亦是如此。&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121221 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121221" />
        <updated>2012-12-21T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121221/0.3dev20121221</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121221&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121221&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121221&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Fixed issue &lt;a href=&quot;https://github.com/soimort/you-get/issues/45&quot;&gt;#45&lt;/a&gt; on YouTube&lt;/h2&gt;

&lt;p&gt;Enhanced the regex for parsing video URLs.&lt;/p&gt;

&lt;h2&gt;Fixed title parsing issue on Tudou&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/radaiming&quot;&gt;@radaiming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121219 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121219" />
        <updated>2012-12-19T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121219/0.3dev20121219</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121219&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121219&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121219&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Supporting Tumblr&lt;/h2&gt;

&lt;p&gt;This release supports downloading videos hosted natively on &lt;a href=&quot;http://www.tumblr.com&quot;&gt;Tumblr&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Notes: &amp;quot;Tumblr videos&amp;quot; are those which were uploaded directly onto Tumblr. If one video is embeded and hosted on an external site, e.g., YouTube, it is not considered as a &amp;quot;Tumblr video&amp;quot;. For now there is no way to download embedded videos from Tumblr URLs (anyhow you can always get their YouTube links for downloading).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get -i http://torustyle.tumblr.com/post/38204731233
Video Site: Tumblr.com
Title:      Toru Style, 岩佐美咲 - もしも私が空に住んでいたら
Type:       MPEG-4 video (video/mp4)
Size:       99.23 MB (104051976 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Have fun!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>google_plus_archiver&#58; a simple command-line tool to archive Google+ profiles</title>
        <link href="http://www.soimort.org/projects/google_plus_archiver/0.0.1" />
        <updated>2012-12-18T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/google_plus_archiver/0.0.1/0.0.1</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/google_plus_archiver&quot;&gt;google&lt;em&gt;plus&lt;/em&gt;archiver&lt;/a&gt; is a simple command-line tool to archive Google+ profiles and public streams.&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install google_plus_archiver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;You need to acquire your own Google API key &lt;a href=&quot;https://code.google.com/apis/console#access&quot;&gt;here&lt;/a&gt; (if you do not have one).&lt;/p&gt;

&lt;h2&gt;Examples&lt;/h2&gt;

&lt;p&gt;Replace asterisks with your API key:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gplus-get -a *************************************** -u 113075529629418110825
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Options&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gplus-get -a [API_KEY] -u [USER_ID]

    --api-key [API_KEY]          Specify the Google API key
    --user-id [USER_ID]          Specify the ID of the user to be archived
    --delay [SECONDS]            Delay (in seconds) between two requests
                                 (0.2 by default, since Google set a
                                 5 requests/second/user limit)
    --output-path [OUTPUT_PATH]  Output path (the current directory by default)
    --quiet                      Silent mode
    --exclude-posts              Don&amp;#39;t archive posts
    --exclude-attachments        Don&amp;#39;t archive attachments
    --exclude-replies            Don&amp;#39;t archive replies
    --exclude-plusoners          Don&amp;#39;t archive plusoners
    --exclude-resharers          Don&amp;#39;t archive resharers
    --version                    Display current version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Licensing&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;google&lt;em&gt;plus&lt;/em&gt;archiver&lt;/strong&gt; is released under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT license&lt;/a&gt;. See the &lt;code&gt;LICENSE&lt;/code&gt; file for details.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/google_plus_archiver&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121217 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121217" />
        <updated>2012-12-17T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121217/0.3dev20121217</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121217&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121217&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121217&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This release mainly fixes some major issues on downloading Google+ videos.&lt;/p&gt;

&lt;h2&gt;#1 Downloading the highest available quality from Google+&lt;/h2&gt;

&lt;p&gt;You-Get will now download Google+ videos in their highest available quality by default.&lt;/p&gt;

&lt;h2&gt;#2 Supporting more patterns of Google+ URLs&lt;/h2&gt;

&lt;p&gt;Google+ is &lt;a href=&quot;https://plus.google.com/u/0/+googleplus/posts/L2K5K1GzaSh&quot;&gt;supporting custom URLs to verified people and pages&lt;/a&gt; now, which has made more patterns of video URLs possible (Unicode, percent-encoded, original user ID). You-Get now supports all of them.&lt;/p&gt;

&lt;p&gt;E.g.,&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/4315472.js&quot;&gt;&lt;/script&gt;

&lt;h2&gt;#3 Fixed some existing issues on Ku6, Sina and 56&lt;/h2&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://github.com/radaiming&quot;&gt;@radaiming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>PulseAudio的正确打开方式（两则）</title>
        <link href="http://www.soimort.org/posts/127" />
        <updated>2012-12-15T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/127/pulseaudio</id>
        <content type="html">&lt;p&gt;记录在此，以供自己备忘之用。&lt;/p&gt;

&lt;h2&gt;VLC播放器的音轨延迟问题&lt;/h2&gt;

&lt;p&gt;几个月前就在Freedesktop.org的bugzilla上报过这个问题（&lt;a href=&quot;https://bugs.freedesktop.org/show_bug.cgi?id=50024&quot;&gt;Issue 50024&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;这问题是从PulseAudio 2.0版的sound server从过去的由中断驱动改为基于timer-based audio scheduling实现开始引进的。&lt;/p&gt;

&lt;p&gt;我过去的解决方法是&lt;code&gt;git bisect&lt;/code&gt;找到导致问题的这部分commit，自己改回去。为此还专门&lt;a href=&quot;https://github.com/soimort/pulseaudio-vlc-friendly&quot;&gt;fork了一个&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不过最近在邮件列表上有人给出了解决方法，把&lt;code&gt;/etc/pulse/default.pa&lt;/code&gt;里的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;load-module module-udev-detect 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上参数，手动禁用timer-based scheduling：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;load-module module-udev-detect tsched=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启后问题解决。（所以现在即使用官方的PulseAudio 2也可以了）&lt;/p&gt;

&lt;h2&gt;如何避免在播放器音量调节的时候被震聋狗耳&lt;/h2&gt;

&lt;p&gt;VLC默认使用PulseAudio作为音频输出模块时，程序本身的音量控制和显示与GNOME 3的音量控制（和PulseAudio完全集成）不同步。&lt;/p&gt;

&lt;p&gt;输出设备Headphones，系统音量设为33%，属于人耳的舒适阈。打开VLC，应用程序本身的音量显示为100%。如果不做任何调节，播放时音量完全正常，系统最终输出音量为正常的系统设定的 &lt;strong&gt;33%（-29.02dB）&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/nijW8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;一旦在VLC中使用了音量调节柄（比如从100%滚轮滚到94%），系统输出音量立马变成 &lt;strong&gt;94%（-1.68dB）&lt;/strong&gt;，戴入耳式耳机的话估计能直接把耳膜震聋……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/hmREe.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;在VLC下面用滚轮滚进度条的时候经常会手残滚到音量调节柄上去。昨晚听歌的时候不知哪根筋搭错，如是手抽两次，表示再也吃不消了。决定解决之。&lt;/p&gt;

&lt;p&gt;经试验，这问题在VLC和Totem上都存在，GNOME MPlayer上则没有。（不明觉厉）&lt;/p&gt;

&lt;p&gt;最后在一个Gentoo user的wiki上找到了解决方法（感谢+&lt;a href=&quot;http://wiki.gentoo.org/wiki/User:Feystorm&quot;&gt;Feystorm&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wiki.gentoo.org/wiki/User:Feystorm#PulseAudio_per-application_volume_control&quot;&gt;http://wiki.gentoo.org/wiki/User:Feystorm#PulseAudio_per-application_volume_control&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;/etc/pulse/daemon.conf&lt;/code&gt;中设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;flat-volumes = no
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让其对每个应用程序进行独立的音量控制。重启PulseAudio后问题解决。&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>为什么我们应该频繁发布新版本（以及怎样发布）</title>
        <link href="http://www.soimort.org/posts/126" />
        <updated>2012-12-12T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/126/release-often</id>
        <content type="html">&lt;p&gt;敏捷开发中有句常讲的话，叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Release_early,_release_often&quot;&gt;“Release early, release often（及早发布，频繁发布）”&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;什么叫发布呢？简单地讲，就是把东西打包出一个新的版本，让最终用户可以直接拿过来用（无论是通过包管理器升级、下载预构建包手动安装还是下载源码自己去&lt;code&gt;make install&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;我个人理念中的频繁发布应该是，每增加几个小的功能或者修复一个issue，都分配一个新的&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本号&lt;/a&gt;。当然，对于WebKit这种持续集成的庞大代码库来说，因为每个Nightly build都会有一个SVN全局版本号，这种情况暂时不在考虑范围之内。&lt;/p&gt;

&lt;p&gt;基于语义版本的频繁发布有什么好处，我就不从哲学的角度分析了。来说一下最近遇到的一个问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0)&lt;/strong&gt; 系统环境：Arch Linux + Python 3.3.0&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 用pip安装docutils（用来渲染&lt;a href=&quot;http://en.wikipedia.org/wiki/ReStructuredText&quot;&gt;reStructuredText (reST)&lt;/a&gt;格式文本的Python库。reST是一种类似Markdown的文本标记语言，用在&lt;a href=&quot;http://pypi.python.org/pypi&quot;&gt;PyPI&lt;/a&gt;上）到系统位置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo pip-3.3 install docutils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; &lt;a href=&quot;https://github.com/github/markup&quot;&gt;GitHub Markup&lt;/a&gt;可以调用docutils来渲染reST文件。执行其测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/github/markup.git github-markup
$ cd github-markup/
$ rake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果测试在reST这一步失败。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt; GitHub Markup通过一个python的wrapper来调用docutils，试图直接用Python 3.3执行这个python脚本，出错：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ python3.3 lib/github/commands/rest2html &amp;lt;/dev/null
...
ImportError: No module named standalone
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4)&lt;/strong&gt; 但是，换成Python 2就完全没有问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo pip-2.7 install docutils
$ python2 lib/github/commands/rest2html &amp;lt;/dev/null
&amp;lt;div class=&amp;quot;document&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显，这是docutils不兼容Python 3.3导致的后果。&lt;/p&gt;

&lt;p&gt;根据Python的traceback信息，问题出在&lt;code&gt;/usr/lib/python3.3/site-packages/docutils-0.9.1-py3.3.egg/docutils/readers/__init__.py&lt;/code&gt;的109行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;module = __import__(reader_name, globals(), locals())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python解释器抱怨说它找不到standalone这个module。但是standalone.py这个文件又是确实存在的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/python3.3/site-packages/docutils-0.9.1-py3.3.egg/docutils/readers/standalone.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;仔细研究一下&lt;a href=&quot;http://docs.python.org/3/whatsnew/3.3.html#using-importlib-as-the-implementation-of-import&quot;&gt;Python 3.3的变化&lt;/a&gt;就知道，原先的&lt;code&gt;__import__()&lt;/code&gt;函数现在由&lt;code&gt;importlib.__import__()&lt;/code&gt;实现，&lt;strong&gt;破坏了原有代码的后向兼容性&lt;/strong&gt;，必须在调用时显式指定&lt;code&gt;level=1&lt;/code&gt;参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;module = __import__(reader_name, globals(), locals(), level=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5)&lt;/strong&gt; 虽然官方的docutils 0.9.1包不兼容Python 3.3，不过这个问题看起来已经在Arch Linux的包上很好地解决了。参见Arch的patch：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://projects.archlinux.org/svntogit/community.git/tree/trunk/01-python33-relative-import.patch?h=packages/docutils&quot;&gt;https://projects.archlinux.org/svntogit/community.git/tree/trunk/01-python33-relative-import.patch?h=packages/docutils&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于Arch来说，这个patch是必需的，因为Arch的Python早就升级到了 3.3版本。不解决这个bug，现有的docutils就根本没法用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6)&lt;/strong&gt; 所以，在Python 3.3上要使用docutils，解决的方法就是不要用easy_install/pip去安装上游的docutils 0.9.1，而是用pacman安装打过补丁的python-docutils 0.9.1包。（所以说用Arch偶尔也是有点额外好处的嘛）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7)&lt;/strong&gt; 装过Arch的包之后，问题照旧。&lt;/p&gt;

&lt;p&gt;原因是：使用easy_install/pip安装的&lt;a href=&quot;http://mrtopf.de/blog/en/a-small-introduction-to-python-eggs/&quot;&gt;Python Eggs&lt;/a&gt;优先级要高于使用pacman安装的库。也就是说，如果有一个用pacman安装的python库：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/python3.3/site-packages/docutils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同时在系统上又用easy_install或者pip安装了同样是这个包的Python Egg：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/python3.3/site-packages/docutils-0.9.1-py3.3.egg/docutils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么Python优先使用的是这个蛋，而不是pacman给你在标准位置安装的包。卸载掉pip安装的蛋即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo pip-3.3 uninstall docutils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;8)&lt;/strong&gt; 现在就要说到问题的关键了。&lt;/p&gt;

&lt;p&gt;Python 3.3是今年九月发布的，但是官方的docutils 0.9.1对Python 3.3并不兼容。既然Arch都解决了这个问题，为什么上游的docutils至今还没解决呢？&lt;/p&gt;

&lt;p&gt;实际上，这issue早在七月份、Python 3.3正式发布之前就已经有人报到docutils的bug tracker上，而且仅仅三天后就被一个patch修复了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sourceforge.net/tracker/?func=detail&amp;amp;aid=3541369&amp;amp;group_id=38414&amp;amp;atid=422030&quot;&gt;http://sourceforge.net/tracker/?func=detail&amp;amp;aid=3541369&amp;amp;group_id=38414&amp;amp;atid=422030&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，docutils最新的版本还是6月份发布的0.9.1。现在你大概知道问题出在哪了。这个bug实际上早就在svn库中被修复了，但是他们至今还没有在Cheeseshop（以及SourceForge上）发布出新的版本！如果你已经升级到了Python 3.3，你是没法直接把“最新发布”版的docutils 0.9.1拿来用的，你仍然需要一个来自下游（比如发行版，诸如Arch Linux）的补丁，或者干脆直接使用svn上的开发版。&lt;/p&gt;

&lt;p&gt;这不是一种解决问题的优雅方式。&lt;/p&gt;

&lt;h2&gt;我们应该频繁地发布版本——为什么不呢？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;现在已经不是通过CD甚至3.5英寸软盘这种物理介质才能发布一个新版软件的年代了。你所需要的只是构建，然后上传到服务器。这一切几乎是零成本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你用PyPI或者RubyGems来托管你的Python/Ruby项目的话，发布一个新版本甚至可以只是一条命令那么简单。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在也不再是Unix hackers们热衷于用&lt;code&gt;diff&lt;/code&gt;/&lt;code&gt;patch&lt;/code&gt;来解决一切问题的年代了。用户很少愿意去碰源代码，尤其当这些代码属于他们不太关心的底层库时。没有哪个用户喜欢在写他们的程序时，发现依赖的底层库有一堆兼容性的bug；这些底层库虽然在svn或git中已经修复了bug，却没有及时地发布出新版本。结果用户只能给这些依赖自行打上patch重新构建，甚至直接使用开发版本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;就算你通过给依赖库打上自己的补丁的方式解决了问题，依赖关系又该怎么写？&lt;/li&gt;
&lt;li&gt;你会想到把这些修补过的依赖库源码也放进自己的代码库里。问题是，你也许根本就没有必要去维护它们，等到依赖库的下一个版本发布时，这个bug就很可能已经被修复了。&lt;/li&gt;
&lt;li&gt;就编译型语言来说，你完全可以给依赖库打上补丁之后把构建出的链接库放到另外一个地方，假装它们是你的软件包的一部分，所以这问题对于传统的C/C++程序员来说并不严重；&lt;/li&gt;
&lt;li&gt;但是，在Python、Ruby这类语言的生态环境下面，你却很难这么去做。这种“不干净”的做法本身也破坏了这些语言社区鼓励代码重用的原则。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;这也是为什么我们应该使用某种语言的“事实标准”包管理器的原因&lt;/h2&gt;

&lt;p&gt;稍微离题说一下，许多现代的编程语言都存在着自己事实标准（de facto）上的包管理机制。大部分时候，一条命令就可以完成从构建、测试到新版本的安装、发布等一系列任务，很少或者根本不需要你去手写繁琐的&lt;code&gt;Makefile&lt;/code&gt;或者&lt;code&gt;configure.ac&lt;/code&gt;，或者其他元构建系统的配置文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python做这件事情的东西以前是setuptools，现在叫做&lt;a href=&quot;http://packages.python.org/distribute/&quot;&gt;Distribute&lt;/a&gt;（setuptools的fork），针对特定版本的Python环境打出来的软件包叫做一个Python蛋（类似于Java下面的jar）， 然后提供给最终用户安装蛋的工具是EasyInstall或者Pip（用以取代EasyInstall）。&lt;/li&gt;
&lt;li&gt;Ruby的包管理机制比Python要更加统一，这个东西叫做gem，几乎没有哪个Ruby程序员会不去用它（不用setuptools/distribute的Python程序员倒是大有人在……）。&lt;/li&gt;
&lt;li&gt;Perl 6现在的包管理器叫panda。&lt;/li&gt;
&lt;li&gt;Haskell有cabal。&lt;/li&gt;
&lt;li&gt;Node.js有npm。&lt;/li&gt;
&lt;li&gt;Dart有pub。&lt;/li&gt;
&lt;li&gt;Go语言……这个自然就不必多说了吧。&lt;code&gt;go&lt;/code&gt;命令实在是太强大了，连包管理都能顺便解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果用了这些语言特定的包管理器来管理项目的话，你会发现发布新版本并不是一件麻烦事。不过这么做的好处可远不止是为频繁发布版本提供便利而已。&lt;/p&gt;

&lt;p&gt;对于任何一个开源社区来说，高效的协作是必不可少的。这要求以下两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;鼓励代码重用，以库的形式。

&lt;ul&gt;
&lt;li&gt;开发自己的库，让它做好一件事情。明确每部分功能的API接口，让它可以被别的库依赖；&lt;/li&gt;
&lt;li&gt;打包好自己的库，而且仅仅只打包自己的库，让它去依赖别的库；&lt;/li&gt;
&lt;li&gt;不要随意地把依赖库的源码包含到自己的代码当中，尤其当维护者并不理解它的大部分内容时；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依赖关系明确，包括名称和版本号。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;早在现代的包管理机制出现之前的年代，GNU / Savannah、CPAN、CTAN这样的社区就已经为做好第一点付出了巨大的努力，而如今众多现代编程语言的标准包管理器更加鼓励了代码重用。今天，如果你写了一个库，并且想把它开源出去让每个人都能从中获益，你&lt;strong&gt;没有任何理由&lt;/strong&gt;不去使用这些包管理机制提供的标准手段！&lt;/p&gt;

&lt;p&gt;第二点，是为了解决API兼容问题带来的依赖性地狱，所以，我想说的是：&lt;/p&gt;

&lt;h2&gt;我们应该让版本号有实质的意义，而不只是好玩&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本规则（Semantic Versioning）&lt;/a&gt;的提出，正是为了解决这样一个问题：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the world of software management there exists a dread place called &amp;quot;dependency hell.&amp;quot; The bigger your system grows and the more packages you integrate into your software, the more likely you are to find yourself, one day, in this pit of despair.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In systems with many dependencies, releasing new package versions can quickly become a nightmare. If the dependency specifications are too tight, you are in danger of version lock (the inability to upgrade a package without having to release new versions of every dependent package). If dependencies are specified too loosely, you will inevitably be bitten by version promiscuity (assuming compatibility with more future versions than is reasonable). Dependency hell is where you are when version lock and/or version promiscuity prevent you from easily and safely moving your project forward.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;大概不是所有人都能习惯这套版本命名规则（Ruby程序员除外）。但是，你仍然应该让自己的版本号具有实质的含义，命名上具有一致性，至少能恰当地反映出API的变化。而不只是为了好玩或者追求形式。&lt;/p&gt;

&lt;p&gt;这么做是为了给用户提供便利，让他们知道什么时候API的兼容性可能会被破坏，什么时候命令行选项（和相应的CLI wrapper）的兼容性又可能会被破坏。如是，当他们依赖于你的库时，他们看到版本号就能够想到及时去更新自己的依赖关系，升级代码。这也是版本号本来应该起到的作用。&lt;/p&gt;

&lt;p&gt;我能理解很多人喜欢不受拘束，发明自己的东西，游离于体制和规则之外；甚至越是伟大的程序员就越是倾向于这么做。也许你更喜欢拿3.14159这样的数字来做版本号。这意味着你是一个了不起的Geek。但是，从长远看来，我不认为这样的版本号命名对整个社区的协作有什么好处——当然，我承认这很有趣。&lt;/p&gt;

&lt;p&gt;对于最终产品或者纯内部项目来说，版本号可能没那么重要，毕竟，在开发团队的圈子之外，没有人会太care某个库的API接口是什么，前后兼容性如何，因为大部分人只会去关心interface。但是，如果你正在或者将要去维护一个开源的项目——请严肃地对待版本号这件事情。&lt;/p&gt;

&lt;p&gt;我是说认真的。&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121212 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121212" />
        <updated>2012-12-12T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121212/0.3dev20121212</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121212&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121212&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121212&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This release fixes some major issues on parsing YouTube video titles.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Any video title containing double quotation marks should now be parsed correctly:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(&lt;a href=&quot;https://github.com/soimort/you-get/issues/38&quot;&gt;https://github.com/soimort/you-get/issues/38&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  ~  you-get -i http://www.youtube.com/watch\?v\=ytj4zLR8lH8
Video Site: YouTube.com
Title:      &amp;quot;Liebe ist kälter als der Tod&amp;quot; :. [ENG SUB]
Type:       WebM video (video/webm)
Size:       359.57 MB (377041579 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Special file system characters in video titles are now better handled and escaped:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(&lt;a href=&quot;https://github.com/soimort/you-get/issues/39&quot;&gt;https://github.com/soimort/you-get/issues/39&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  ~  you-get -i http://www.youtube.com/watch\?v\=8TGfJp1hNkA 
Video Site: YouTube.com
Title:      2009-8-5 on sale 1st.Single「強き者よ」Music Video
Type:       WebM video (video/webm)
Size:       30.3 MB (31770713 Bytes)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Do not hesitate to upgrade to latest version!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>You-Get 0.3dev-20121210 Release Notes</title>
        <link href="http://www.soimort.org/projects/you-get/0.3dev-20121210" />
        <updated>2012-12-10T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/you-get/0.3dev-20121210/0.3dev20121210</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt; &lt;strong&gt;0.3dev-20121210&lt;/strong&gt; is now released:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/0.3dev-20121210&quot;&gt;http://pypi.python.org/pypi/you-get/0.3dev-20121210&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;#1 Downloading the highest available quality from YouTube&lt;/h2&gt;

&lt;p&gt;YouTube videos are available in a range of quality levels. From now on, You-Get will automatically download YouTube videos in their highest available qualities, e.g., for any video which is available in a 1080p resolution, You-Get will prefer 1080p rather than the default 360p FLV format.&lt;/p&gt;

&lt;p&gt;You-Get will always be looking for the highest available video resolution first, then the highest available audio bitrate. Given any video available in two formats which are encoded in exactly the same resolution and bitrate, the priority sequence of codecs for You-Get will be: &lt;em&gt;WebM &amp;gt; MP4 &amp;gt; FLV &amp;gt; 3GP&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;#2 Supporting SoundCloud&lt;/h2&gt;

&lt;p&gt;You-Get now supports downloading audio files (usually in MP3 format) from &lt;a href=&quot;https://soundcloud.com/&quot;&gt;SoundCloud&lt;/a&gt;, a prevalent online audio distribution site.&lt;/p&gt;

&lt;p&gt;You-Get even supports &amp;quot;not officially downloadable&amp;quot; audios, which you can neither download directly on the website, with &lt;em&gt;youtube-dl&lt;/em&gt; nor via any of the SoundCloud APIs. Use carefully with respect to copyrights.&lt;/p&gt;

&lt;p&gt;Example: &lt;a href=&quot;https://soundcloud.com/sokovo/ann_121020_rap_02&quot;&gt;https://soundcloud.com/sokovo/ann_121020_rap_02&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ you-get -i https://soundcloud.com/sokovo/ann_121020_rap_02
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Future Roadmap&lt;/h2&gt;

&lt;p&gt;There will be a major code refactoring of You-Get in the future.&lt;/p&gt;

&lt;p&gt;At this point, You-Get APIs are not stable yet, thus they are not recommended to use. You-Get APIs are planned to change immensely in the coming 0.3 release. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Python-romkan&#58; a Romaji/Kana conversion library</title>
        <link href="http://www.soimort.org/projects/python-romkan/0.0.1" />
        <updated>2012-12-07T00:00:00+08:00</updated>
        <id>http://www.soimort.org/projects/python-romkan/0.0.1/0.0.1</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;python-romkan&lt;/a&gt; is a Romaji/Kana conversion library for Python, which is used to convert a Japanese Romaji (ローマ字) string to a Japanese Kana (仮名) string or vice versa.&lt;/p&gt;

&lt;p&gt;It is the Pythonic port of &lt;a href=&quot;http://0xcc.net/ruby-romkan/index.html.en&quot;&gt;Ruby/Romkan&lt;/a&gt;, originally authored by Satoru Takabayashi and &lt;a href=&quot;http://lilyx.net/python-romkan/&quot;&gt;ported by Masato Hagiwara&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;python-romkan&lt;/a&gt; works on Python 2 and Python 3. It handles both Katakana (片仮名) and Hiragana (平仮名) with the Hepburn (ヘボン式) romanization system, as well as the modern Kunrei-shiki (訓令式) romanization system.&lt;/p&gt;

&lt;p&gt;Project homepage: &lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;https://github.com/soimort/python-romkan&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Why am I making this?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The original &lt;a href=&quot;http://0xcc.net/ruby-romkan/index.html.en&quot;&gt;Ruby/Romkan&lt;/a&gt; can only handle Hiragana, while the original Python port &lt;a href=&quot;http://lilyx.net/python-romkan/&quot;&gt;Python/Romkan&lt;/a&gt; only handles Katakana. I need a library which can handle both of them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;#39;d like to use the library as a standard Python Package.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I want to use Python 3.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PyPI homepage: &lt;a href=&quot;http://pypi.python.org/pypi/romkan&quot;&gt;http://pypi.python.org/pypi/romkan&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Installation&lt;/h2&gt;

&lt;p&gt;Install via &lt;a href=&quot;http://www.pip-installer.org/&quot;&gt;Pip&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ pip install romkan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install via &lt;a href=&quot;http://pypi.python.org/pypi/setuptools&quot;&gt;EasyInstall&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ easy_install romkan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install from Git:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/python-romkan.git

$ ninja install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Usage&lt;/h2&gt;

&lt;p&gt;Python 3.x:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ python
&amp;gt;&amp;gt;&amp;gt; import romkan
&amp;gt;&amp;gt;&amp;gt; print(romkan.to_roma(&amp;quot;にんじゃ&amp;quot;))
ninja
&amp;gt;&amp;gt;&amp;gt; print(romkan.to_hepburn(&amp;quot;にんじゃ&amp;quot;))
ninja
&amp;gt;&amp;gt;&amp;gt; print(romkan.to_kunrei(&amp;quot;にんじゃ&amp;quot;))
ninzya
&amp;gt;&amp;gt;&amp;gt; print(romkan.to_hiragana(&amp;quot;ninja&amp;quot;))
にんじゃ
&amp;gt;&amp;gt;&amp;gt; print(romkan.to_katakana(&amp;quot;ninja&amp;quot;))
ニンジャ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python 2.x:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ python2
&amp;gt;&amp;gt;&amp;gt; import romkan
&amp;gt;&amp;gt;&amp;gt; print romkan.to_roma(u&amp;quot;にんじゃ&amp;quot;)
ninja
&amp;gt;&amp;gt;&amp;gt; print romkan.to_hepburn(u&amp;quot;にんじゃ&amp;quot;)
ninja
&amp;gt;&amp;gt;&amp;gt; print romkan.to_kunrei(u&amp;quot;にんじゃ&amp;quot;)
ninzya
&amp;gt;&amp;gt;&amp;gt; print romkan.to_hiragana(&amp;quot;ninja&amp;quot;)
にんじゃ
&amp;gt;&amp;gt;&amp;gt; print romkan.to_katakana(&amp;quot;ninja&amp;quot;)
ニンジャ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;API Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_katakana(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Romaji (ローマ字) to a Katakana (片仮名).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_hiragana(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Romaji (ローマ字) to a Hiragana (平仮名).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_kana(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Romaji (ローマ字) to a Katakana (片仮名). (same as &lt;em&gt;to_katakana&lt;/em&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_hepburn(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Kana (仮名) or a Kunrei-shiki Romaji (訓令式ローマ字) to a Hepburn Romaji (ヘボン式ローマ字).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_kunrei(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Kana (仮名) or a Hepburn Romaji (ヘボン式ローマ字) to a Kunrei-shiki Romaji (訓令式ローマ字).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;to_roma(string)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Convert a Kana (仮名) to a Hepburn Romaji (ヘボン式ローマ字).&lt;/p&gt;

&lt;h2&gt;License&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;python-romkan&lt;/a&gt; is licensed under the &lt;a href=&quot;https://raw.github.com/soimort/python-romkan/master/LICENSE&quot;&gt;BSD license&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Acknowledgement&lt;/h2&gt;

&lt;p&gt;高林哲さん（Ruby/Romkan）と、萩原正人さん（Python/Romkan）に感謝申し上げます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/python-romkan&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>依赖性地狱和Arch的哲♂学</title>
        <link href="http://www.soimort.org/posts/125" />
        <updated>2012-11-10T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/125/so-hell</id>
        <content type="html">&lt;p&gt;在.NET之前的时代玩过Windows的一定都知道&lt;a href=&quot;http://en.wikipedia.org/wiki/DLL_Hell&quot;&gt;DLL地狱&lt;/a&gt;是什么。我至今仍然能清晰地记得，自己小学时在Windows 98上用VB 6或者Delphi编出来的程序，总是要打包那么几个神奇的.dll文件才能放到别的机器上运行的情景；以及为了玩上某些游戏，在网上四处寻找特定版本DirectX的.dll文件的情景；当然还有在安全模式下面手动杀毒，删除System文件夹下面有问题的.dll文件，结果把系统搞到启动不能的情景。&lt;/p&gt;

&lt;p&gt;啊，愉快的Windows。愉快的童年ヽ(´▽`)/&lt;/p&gt;

&lt;p&gt;如果以上的这些对你来说都没有意义的话，那么欢迎服下Morpheus手中的&lt;a href=&quot;http://www.viagra.com/&quot;&gt;蓝色药丸&lt;/a&gt;，回到&lt;a href=&quot;http://windows.microsoft.com/en-US/windows/buy&quot;&gt;Windows 8&lt;/a&gt;的精彩世界。这篇文章到此结束。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;背景1：最近，我想写一个FFmpeg的Python wrapper，用来把视频中的特定片段截取成GIF格式的动图。（方便做论坛签名什么的。。。）&lt;/p&gt;

&lt;p&gt;背景2：因为3.4以后的kernel在我的机器上存在着某些我无法解决的regression bug（见&lt;a href=&quot;http://www.soimort.org/posts/115/&quot;&gt;我的Linux/Unix不完全折腾史&lt;/a&gt;），所以我的Arch至今还在用Linux 3.3.7和配套的core库。mirror设定也停留在了&lt;a href=&quot;http://arm.konnichi.com/&quot;&gt;Arch时光机&lt;/a&gt;&lt;a href=&quot;http://ja.wikipedia.org/wiki/AKB48_27th%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E9%81%B8%E6%8A%9C%E7%B7%8F%E9%81%B8%E6%8C%99&quot;&gt;6月的某一天&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Server = http://arm.konnichi.com/2012/06/08/$repo/os/$arch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据我所了解到的，&lt;a href=&quot;http://ffmpeg.org/&quot;&gt;FFmpeg&lt;/a&gt;从受认可程度和开发状况来说都要优于那个不尴不尬的&lt;a href=&quot;http://libav.org/&quot;&gt;AV库&lt;/a&gt;（据某中立开发者的说法，FFmpeg正在积极地从Libav中往回吸收patches，而Libav自从分裂出去以后一直不愿意吸收来自FFmpeg的patches。Libav的fork举动更多的是出于积怨，而不是开源精神），而且就在最近发布了1.0版。总而言之，从Arch的网站上单独下载了&lt;a href=&quot;https://www.archlinux.org/packages/extra/x86_64/ffmpeg/&quot;&gt;FFmpeg 1.0的包&lt;/a&gt;，用pacman安装。升级成功，没有任何依赖错误的提示。&lt;/p&gt;

&lt;p&gt;然后，听会YouTube上拖下来的音乐吧（拖延症又要犯了么混蛋！！），结果点开一个flv文件，VLC没有任何反应，视频元信息也完全解析不出来：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/KYwaq.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;因为我的全部音乐和视频都是放在移动硬盘的NTFS分区上的，所以第一反应是：这移动硬盘每天撸每天撸，终于被我玩坏了么。。。（其实是因为以前也发生过类似的事情）&lt;/p&gt;

&lt;p&gt;（几百G的音乐和MV，这要是没有了还让人怎么活啊）&lt;/p&gt;

&lt;p&gt;之后的重新挂载重启和各种分区查错数据校验过程略过不表。。。&lt;/p&gt;

&lt;p&gt;结果发现数据根本没坏，只是VLC不能解码H.264视频了。打开MP4容器的时候有错误提示（而且AAC音轨可以正常播放），不知道为什么打开FLV容器的时候就没有。所以虚惊一场。&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/mRwip.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;起初以为是最新的ffmpeg 1:1.0-1包与我系统上旧版本的vlc 2.0.1-2不兼容的问题，遂升级到最新的vlc 2.0.4-3。仍然不能播放。&lt;/p&gt;

&lt;p&gt;控制台错误信息：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/0PyPt.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;恩，只好祭出软件包查错的大法了：&lt;a href=&quot;http://en.wikipedia.org/wiki/Code_Bisection&quot;&gt;bisection&lt;/a&gt;。发现问题是从vlc 2.0.2-2这个版本开始引入的，从vlc 2.0.2-2之后（包括vlc 2.0.2-2……直到最新的vlc 2.0.4-3）都不能解码H.264格式的视频。vlc 2.0.2-2之前的版本（vlc 2.0.2-1）则工作正常。&lt;/p&gt;

&lt;p&gt;vlc 2.0.2-1和vlc 2.0.2-2应该是对同一个VLC release的打包，看来问题的引入和上游库没啥关系的说，问题出在Arch Linux的打包上。&lt;/p&gt;

&lt;p&gt;vlc 2.0.2-2到底做了什么改动导致原来能正常工作的vlc 2.0.2-1失效了呢？用&lt;code&gt;git diff&lt;/code&gt;看了一下Arch开发库的前后两个commits，然后我就彻底无语了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc git:(master) ✗ git diff cbf3859920749bc895cfa2eed4f21272c7fca73e
b29dd7ba46f96fcb41bc2fb01bd4207d46197efa
diff --git a/trunk/PKGBUILD b/trunk/PKGBUILD
index dcd87b8..0e31c17 100644
--- a/trunk/PKGBUILD
+++ b/trunk/PKGBUILD
@@ -5,7 +5,7 @@

 pkgname=vlc
 pkgver=2.0.2
-pkgrel=1
+pkgrel=2
 pkgdesc=&amp;quot;A multi-platform MPEG, VCD/DVD, and DivX player&amp;quot;
 arch=(&amp;#39;i686&amp;#39; &amp;#39;x86_64&amp;#39;)
 url=&amp;quot;http://www.videolan.org/vlc/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了打包版本号从1改成2以外，PKGBUILD什么变化都没。&lt;/p&gt;

&lt;p&gt;既然啥都没改，那你还重新打包做什么？而且，既然Arch的PKGBUILD没改，VLC的上游代码也是同一个release，这个问题到底是怎么引入的？&lt;/p&gt;

&lt;p&gt;使人李菊福的&lt;code&gt;git log&lt;/code&gt;信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc git:(master) ✗ git log -1 b29dd7ba46f96fcb41bc2fb01bd4207d46197efa
commit b29dd7ba46f96fcb41bc2fb01bd4207d46197efa
Author: giovanni &amp;lt;giovanni@eb2447ed-0c53-47e4-bac8-5bc4a241df78&amp;gt;
Date:   Sat Jun 30 13:20:52 2012 +0000

    upgpkg: vlc 2.0.2-2

    x264 and ffmpeg rebuild

    git-svn-id: file:///srv/svn-packages@162782 eb2447ed-0c53-47e4-bac8-5bc4a241df78
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到了那句“x264 and ffmpeg rebuild”了没？如果你不看&lt;code&gt;git log&lt;/code&gt;，你打死也不会知道这个包发生了什么变化。。。&lt;/p&gt;

&lt;p&gt;我揣测，打包者在编译完vlc 2.0.2-1之后，意识到自己系统上的x264和ffmpeg并不是当前的最新版本。而x264和ffmpeg在此期间的&lt;a href=&quot;http://en.wikipedia.org/wiki/Soname&quot;&gt;动态链接库soname&lt;/a&gt;发生了升级，破坏了作为VLC依赖库的兼容性。由于打包者忘记在打包之前进行全系统升级，在他编译VLC的时候，configure用的必然是他自己系统中的旧x264库：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  ~  objdump /usr/lib/libx264.so -p | grep SONAME
  SONAME               libx264.so.120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，由于大多数Arch用户们已经把每天&lt;code&gt;sudo pacman -Syu&lt;/code&gt;作为一种嗜好，他们的机器上很可能已经升级到了新版本的x264：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  ~  objdump /usr/lib/libx264.so -p | grep SONAME
  SONAME               libx264.so.124
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是，基于旧版本x264（和ffmpeg）打包出来的vlc就无法在已经升级到了最新版本x264（和ffmpeg）的系统上正常使用。打包者很快意识到了这个错误，迅速升级了自己的x264（和ffmpeg），重新进行makepkg。&lt;/p&gt;

&lt;p&gt;把先后两个包（vlc 2.0.2-1与vlc 2.0.2-2）解压之后进行比较，可以看到编译出来的VLC的&lt;code&gt;.so&lt;/code&gt;库文件存在着差异：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc  diff -r vlc-2.0.2-1-x86_64 vlc-2.0.2-2-x86_64
Binary files vlc-2.0.2-1-x86_64/usr/lib/libvlccore.so
and vlc-2.0.2-2-x86_64/usr/lib/libvlccore.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/libvlccore.so.5
and vlc-2.0.2-2-x86_64/usr/lib/libvlccore.so.5 differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/libvlccore.so.5.1.0
and vlc-2.0.2-2-x86_64/usr/lib/libvlccore.so.5.1.0 differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/access/libaccess_avio_plugin.so
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/access/libaccess_avio_plugin.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/codec/libavcodec_plugin.so
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/codec/libavcodec_plugin.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/codec/libx264_plugin.so
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/codec/libx264_plugin.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/demux/libavformat_plugin.so
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/demux/libavformat_plugin.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/gui/libqt4_plugin.so
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/gui/libqt4_plugin.so differ
Binary files vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/plugins.dat
and vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/plugins.dat differ
Binary files vlc-2.0.2-1-x86_64/usr/share/man/man1/vlc.1.gz
and vlc-2.0.2-2-x86_64/usr/share/man/man1/vlc.1.gz differ
Binary files vlc-2.0.2-1-x86_64/usr/share/man/man1/vlc-wrapper.1.gz
and vlc-2.0.2-2-x86_64/usr/share/man/man1/vlc-wrapper.1.gz differ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查这些存在差异的VLC库文件。再回头看一眼前面控制台下VLC的出错信息，问题出在&lt;code&gt;/usr/lib/vlc/plugins/codec/libavcodec_plugin.so&lt;/code&gt;这个文件上。我的系统和开发者起初打包vlc 2.0.2-1时一样，没有升级过x264和ffmpeg这两个库，所以vlc 2.0.2-1的&lt;code&gt;libavcodec_plugin.so&lt;/code&gt;的依赖库状态如下（所有的&lt;code&gt;.so&lt;/code&gt;都能够找到并且正常binding）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc  ldd vlc-2.0.2-1-x86_64/usr/lib/vlc/plugins/codec/libavcodec_plugin.so
    linux-vdso.so.1 =&amp;gt;  (0x00007fff46bff000)
    libvlccore.so.5 =&amp;gt; /usr/lib/libvlccore.so.5 (0x00007f6ed69ee000)
    libdbus-1.so.3 =&amp;gt; /usr/lib/libdbus-1.so.3 (0x00007f6ed67aa000)
    librt.so.1 =&amp;gt; /lib/librt.so.1 (0x00007f6ed65a1000)
    libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0x00007f6ed639d000)
    libpthread.so.0 =&amp;gt; /lib/libpthread.so.0 (0x00007f6ed6181000)
    libva-x11.so.1 =&amp;gt; /usr/lib/libva-x11.so.1 (0x00007f6ed5f78000)
    libva.so.1 =&amp;gt; /usr/lib/libva.so.1 (0x00007f6ed5d61000)
    libX11.so.6 =&amp;gt; /usr/lib/libX11.so.6 (0x00007f6ed5a28000)
    libavcodec.so.53 =&amp;gt; /usr/lib/libavcodec.so.53 (0x00007f6ed4b48000)
    libavutil.so.51 =&amp;gt; /usr/lib/libavutil.so.51 (0x00007f6ed4925000)
    libm.so.6 =&amp;gt; /lib/libm.so.6 (0x00007f6ed4630000)
    libc.so.6 =&amp;gt; /lib/libc.so.6 (0x00007f6ed428e000)
    /lib/ld-linux-x86-64.so.2 (0x00007f6ed6f1a000)
    libXext.so.6 =&amp;gt; /usr/lib/libXext.so.6 (0x00007f6ed407b000)
    libdrm.so.2 =&amp;gt; /usr/lib/libdrm.so.2 (0x00007f6ed3e70000)
    libXfixes.so.3 =&amp;gt; /usr/lib/libXfixes.so.3 (0x00007f6ed3c68000)
    libxcb.so.1 =&amp;gt; /usr/lib/libxcb.so.1 (0x00007f6ed3a4a000)
    libxvidcore.so.4 =&amp;gt; /usr/lib/libxvidcore.so.4 (0x00007f6ed3732000)
    libx264.so.120 =&amp;gt; /usr/lib/libx264.so.120 (0x00007f6ed33e5000)
    libvpx.so.1 =&amp;gt; /usr/lib/libvpx.so.1 (0x00007f6ed3145000)
    libvorbisenc.so.2 =&amp;gt; /usr/lib/libvorbisenc.so.2 (0x00007f6ed2c76000)
    libvorbis.so.0 =&amp;gt; /usr/lib/libvorbis.so.0 (0x00007f6ed2a48000)
    libtheoraenc.so.1 =&amp;gt; /usr/lib/libtheoraenc.so.1 (0x00007f6ed280b000)
    libtheoradec.so.1 =&amp;gt; /usr/lib/libtheoradec.so.1 (0x00007f6ed25f0000)
    libspeex.so.1 =&amp;gt; /usr/lib/libspeex.so.1 (0x00007f6ed23d6000)
    libschroedinger-1.0.so.0 =&amp;gt; /usr/lib/libschroedinger-1.0.so.0 (0x00007f6ed210b000)
    libz.so.1 =&amp;gt; /usr/lib/libz.so.1 (0x00007f6ed1ef5000)
    libopenjpeg.so.1 =&amp;gt; /usr/lib/libopenjpeg.so.1 (0x00007f6ed1ccc000)
    libopencore-amrwb.so.0 =&amp;gt; /usr/lib/libopencore-amrwb.so.0 (0x00007f6ed1ab8000)
    libopencore-amrnb.so.0 =&amp;gt; /usr/lib/libopencore-amrnb.so.0 (0x00007f6ed188e000)
    libmp3lame.so.0 =&amp;gt; /usr/lib/libmp3lame.so.0 (0x00007f6ed1616000)
    libgsm.so.1 =&amp;gt; /usr/lib/libgsm.so.1 (0x00007f6ed140b000)
    libXau.so.6 =&amp;gt; /usr/lib/libXau.so.6 (0x00007f6ed1206000)
    libXdmcp.so.6 =&amp;gt; /usr/lib/libXdmcp.so.6 (0x00007f6ed1000000)
    libogg.so.0 =&amp;gt; /usr/lib/libogg.so.0 (0x00007f6ed0dfa000)
    liborc-0.4.so.0 =&amp;gt; /usr/lib/liborc-0.4.so.0 (0x00007f6ed0b7e000)
    libstdc++.so.6 =&amp;gt; /usr/lib/libstdc++.so.6 (0x00007f6ed087a000)
    libgcc_s.so.1 =&amp;gt; /usr/lib/libgcc_s.so.1 (0x00007f6ed0665000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vlc 2.0.2-2的&lt;code&gt;libavcodec_plugin.so&lt;/code&gt;依赖情形（注意&lt;code&gt;libavcodec.so.54 =&amp;gt; not found&lt;/code&gt;这一行）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc  ldd vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/codec/libavcodec_plugin.so
    linux-vdso.so.1 =&amp;gt;  (0x00007ffff39ff000)
    libvlccore.so.5 =&amp;gt; /usr/lib/libvlccore.so.5 (0x00007f3e00814000)
    libdbus-1.so.3 =&amp;gt; /usr/lib/libdbus-1.so.3 (0x00007f3e005d0000)
    librt.so.1 =&amp;gt; /lib/librt.so.1 (0x00007f3e003c7000)
    libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0x00007f3e001c3000)
    libpthread.so.0 =&amp;gt; /lib/libpthread.so.0 (0x00007f3dfffa7000)
    libva-x11.so.1 =&amp;gt; /usr/lib/libva-x11.so.1 (0x00007f3dffd9e000)
    libva.so.1 =&amp;gt; /usr/lib/libva.so.1 (0x00007f3dffb87000)
    libX11.so.6 =&amp;gt; /usr/lib/libX11.so.6 (0x00007f3dff84e000)
    libavcodec.so.54 =&amp;gt; not found
    libavutil.so.51 =&amp;gt; /usr/lib/libavutil.so.51 (0x00007f3dff62a000)
    libm.so.6 =&amp;gt; /lib/libm.so.6 (0x00007f3dff335000)
    libc.so.6 =&amp;gt; /lib/libc.so.6 (0x00007f3dfef93000)
    /lib/ld-linux-x86-64.so.2 (0x00007f3e00d40000)
    libXext.so.6 =&amp;gt; /usr/lib/libXext.so.6 (0x00007f3dfed80000)
    libdrm.so.2 =&amp;gt; /usr/lib/libdrm.so.2 (0x00007f3dfeb75000)
    libXfixes.so.3 =&amp;gt; /usr/lib/libXfixes.so.3 (0x00007f3dfe96d000)
    libxcb.so.1 =&amp;gt; /usr/lib/libxcb.so.1 (0x00007f3dfe74f000)
    libXau.so.6 =&amp;gt; /usr/lib/libXau.so.6 (0x00007f3dfe54a000)
    libXdmcp.so.6 =&amp;gt; /usr/lib/libXdmcp.so.6 (0x00007f3dfe344000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;旧版本的ffmpeg中包含的&lt;code&gt;libavcodec.so&lt;/code&gt;指向&lt;code&gt;libavcodec.so.53&lt;/code&gt;，而重新打包之后的vlc 2.0.2-2使用的是&lt;code&gt;libavcodec.so.54&lt;/code&gt;。升级ffmpeg即可解决问题。&lt;/p&gt;

&lt;p&gt;同理，旧的x264中的&lt;code&gt;libx264.so&lt;/code&gt;指向&lt;code&gt;libx264.so.120&lt;/code&gt;，而重新打包的vlc 2.0.2-2要求有&lt;code&gt;libx264.so.124&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;➜  vlc  ldd vlc-2.0.2-2-x86_64/usr/lib/vlc/plugins/codec/libavcodec_plugin.so
| grep &amp;#39;not found&amp;#39;
    libx264.so.124 =&amp;gt; not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上所述，只要把x264和ffmpeg这两个依赖包都升级到vlc需要的最新版本即可。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;好吧，现在，问题出在哪里？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Arch packages的打包者在构建某个包前升级了他的依赖库版本，破坏了仍然在使用旧版本依赖库的用户对这个包的兼容性，但是这个变化的信息却没有通过Arch的包管理机制恰当地体现出来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不单单是没有写入PKGBUILD，这个依赖的变化信息甚至在整个Arch的git库中也不解其详。唯一可以作为线索的就是打包者在git log中留下的片言只语：“我用新的依赖库重构了这个包。”&lt;/strong&gt;至于是具体是什么版本的依赖库？Arch的哲学这时就发挥作用了：总是当下&lt;strong&gt;“最新”&lt;/strong&gt;的依赖库。&lt;/p&gt;

&lt;p&gt;从某种意义上，Arch是一个&lt;strong&gt;简洁&lt;/strong&gt;的发行版；但是无论如何，它都不能算得上一个&lt;strong&gt;态度严谨&lt;/strong&gt;的发行版。&lt;/p&gt;

&lt;p&gt;发生这样的事情，实际上不应该责怪打包者，因为问题的根源是Arch哲学造成的根本缺陷：最新版本拥有一切话语权，官方仓库不保留任何旧版本包，不处理任何旧版本包的issue。缺乏严谨的软件版本回溯机制。几乎不可避免的全系统升级。然后某一天你在赶项目赶作业之前一不小心手贱&lt;code&gt;sudo pacman -Syu&lt;/code&gt;了一下，然后重启一次系统就嗝屁了。你不得不停下手中的工作花上几百年的时间去修复系统。&lt;/p&gt;

&lt;p&gt;PKGBUILD中当然不是不能处理具体的依赖版本要求，而是大部分开发者都不愿意去关心这个要求：既然所有人都在用最新版本的依赖库，我干嘛要去花时间把几个月前甚至几年前的版本一一翻出来检查是否和我的包兼容？&lt;/p&gt;

&lt;p&gt;有些和kernel或者glibc关系密切的包（比如&lt;a href=&quot;https://www.archlinux.org/packages/community/x86_64/virtualbox-host-modules/&quot;&gt;virtualbox-host-modules&lt;/a&gt;）会比较严格地标明依赖库的版本限制（如linux&lt;3.7，linux&gt;=3.6），但是，其它绝大多数包的维护者采取了无视依赖版本号的态度。就像ffmpeg的依赖库列表这样：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/qiNJe.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;基本上，只要一个Arch包脱离了testing状态，它就成为了唯一“稳定”版本的包，直到它被一个更新的“稳定”版本取代。（请注意“稳定”在这里要打个引号←_←）它的依赖是什么？那些“最新”版本的依赖库。&lt;/p&gt;

&lt;p&gt;同样是ffmpeg，看看Debian是怎么写依赖关系的，几乎所有的依赖都有明确的版本限定：&lt;/p&gt;

&lt;p&gt;（虽然这么比较不太科学，因为Debian/Ubuntu把所有的libav*库都拆开了分别打包，但这还是能从一定程度上说明问题）&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/wQJkn.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;还有Ubuntu：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/UOyoi.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;Arch除了软件包的版本比较新之外，在开发与维护的严谨程度上已经被Debian/Ubuntu完爆。&lt;/p&gt;

&lt;p&gt;Debian/Ubuntu的打包方式虽然我完全没接触过，不过可以拿曾经被我抛弃的Gentoo的ebuild来和Arch的PKGBUILD机制做个横向的比较：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/Z79rt.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;上面是一个典型的Arch包，打包者通常只会用一行简单的列表来解决全部依赖关系。而Gentoo开发者对待依赖的态度显然严肃得多：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/G90fi.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;Gentoo和Arch一样，都是追求DIY和高度可定制性的发行版。而比起Arch忽略所有旧版本包的态度，Gentoo的做法是：&lt;/p&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;http://i.imgur.com/eENfq.png&quot; width=&quot;80%&quot;/&gt;&lt;/div&gt;

&lt;p&gt;Gentoo官方库保留每个软件包的历史版本，stable、unstable、hardmask三种状态一目了然。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最后想说几句哲♂学的问题。&lt;/p&gt;

&lt;p&gt;The Arch Way里面有这样一句话：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;By keeping the system simple, Arch Linux provides the freedom to make any choice about the system.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;前半句话是真的，从系统的简单（&lt;a href=&quot;http://en.wikipedia.org/wiki/KISS_principle&quot;&gt;KISS&lt;/a&gt;）程度来讲，Arch确实比Debian、Ubuntu甚至Gentoo都要更胜一筹。这种简单性的一个必然结果就是，不维护任何旧版本，也不用去纠缠涉及旧版本的依赖关系。&lt;/p&gt;

&lt;p&gt;所以，后半句话就成了谎言。&lt;/p&gt;

&lt;p&gt;你不可能轻易地make &lt;strong&gt;any&lt;/strong&gt; choice，至少是软件包版本上的choice。因为Arch为了它的简单性，已经牺牲掉了版本的可回溯性。当你因为某个新版本出现问题而想rollback到旧版本，或者想压住稳定的旧版本不进行升级，而这个包偏偏又需要依赖别的包或者被别的包依赖时，你的麻烦就大了。&lt;/p&gt;

&lt;p&gt;其它发行版也会有类似的问题。但Arch这种过分追求简单性和bleeding edge以至于完全忽视旧版本的态度，无疑是一个可能会导致用户深陷&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_hell&quot;&gt;依赖性地狱（Dependency hell）&lt;/a&gt;的陷阱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Simplicity has its damned costs. ——Mort&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;div style=&quot;text-align:center&quot;&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/-yNEh0sdd90&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】Lisp魔咒：对Lisp的非技术性吐槽</title>
        <link href="http://www.soimort.org/posts/124" />
        <updated>2012-11-06T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/124/lisp-curse</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://www.winestockwebdesign.com/Essays/Lisp_Curse.html&quot;&gt;The Lisp Curse&lt;/a&gt;
by Rudolf Winestock&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;这篇文章的标题叫“The Lisp Curse”。&lt;/p&gt;

&lt;p&gt;我给它加了一个副标题，叫“对Lisp的非技术性吐槽”。&lt;/p&gt;

&lt;p&gt;毫无疑问，这是一篇非技术性质的文章，但是它也许比很多技术文章能更好地解释一些疑问。列举几个无聊的的命题：&lt;em&gt;“为什么世界上&lt;a href=&quot;http://schemers.org/&quot;&gt;最好的编程语言&lt;/a&gt;没有得到它应有的地位”&lt;/em&gt;、&lt;em&gt;“为什么自底向上支撑着我们个人计算机乃至整个网络的Unix / BSD / GNU / GTK+ / Qt / Linux / Apache / MySQL...不是用Lisp/Scheme写的”&lt;/em&gt;、&lt;em&gt;“为什么王垠&lt;a href=&quot;http://news.cnblogs.com/n/153840/&quot;&gt;批完Google&lt;/a&gt;&lt;a href=&quot;http://news.cnblogs.com/n/157058/&quot;&gt;批学术界&lt;/a&gt;却没做多少&lt;a href=&quot;https://github.com/yinwang0&quot;&gt;牛逼哄哄的项目&lt;/a&gt;”&lt;/em&gt;或者&lt;em&gt;“为什么说‘&lt;a href=&quot;http://en.wikipedia.org/wiki/Lone_wolf_(trait)&quot;&gt;孤狼&lt;/a&gt;黑客’对开源软件的生态环境是有害的”&lt;/em&gt;……诸如此类。&lt;/p&gt;

&lt;p&gt;顺便说一句，我最初是在&lt;a href=&quot;https://twitter.com/yukihiro_matz/status/265244572853088256&quot;&gt;@yukihiro_matz&lt;/a&gt;的推上看到这篇文章的分享的。所谓的“孤狼黑客”，并不是指Matz和Van Rossum这些人——至少从Python和Ruby发布到社区的一刻起就不再是了。&lt;/p&gt;

&lt;p&gt;再补充一句，我相信不管是这篇文章的原作者还是翻译君本人，都没有任何对&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/comp.lang.lisp&quot;&gt;Lisp社区&lt;/a&gt;不敬的意思——只是就一项事实陈述和复述某种观点而已。&lt;/p&gt;

&lt;p&gt;好了，废话少说，以下是正文内容。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;这篇文章是另一次尝试，旨在解释Lisp语言在具备强大力量的同时、为何Lisp社区却无法重现它们在&lt;a href=&quot;http://c2.com/cgi/wiki?AiWinter&quot;&gt;“AI之冬”&lt;/a&gt;之前的辉煌。毫无疑问，即便在式微之后，Lisp语言仍然是各种奇思妙想的重要来源。这一事实，加之各种Lisp实现的优异架构，还有如今在长达十年之后Lisp的复兴、显示着那些Lisp拥护者们是多么需要为自己的得意之作找到一点优越感；尽管有这一切，他们却没能成功地把Lisp的力量转换成一场压倒性的技术革新。&lt;/p&gt;

&lt;p&gt;在本文中，我将阐述这样一个论点：Lisp那极其强大的表达能力，实际上是如何成为它缺乏前进动力的致命诱因的。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Lisp的力量也是它自身最危险的天敌。&lt;/p&gt;

&lt;p&gt;要证明这件事情，试想一个简单的思维实验：选择两种非面向对象的程序语言。你的任务，如果你愿意接受的话，就是为它们提供面向对象编程范式的支持，并且保持它们与原语言向后兼容——排除一些边界情况以外。把任意两种语言放到这个思维实验的设定当中，你会很容易发现一些语言较另一些语言更容易完成任务。这正是这个思维实验的要点。随手举个简单的例子：&lt;a href=&quot;http://en.wikipedia.org/wiki/INTERCAL&quot;&gt;INTERCAL&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Pascal_(programming_language)&quot;&gt;Pascal&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在让我们把这个思维实验变得更有说服力些。想象一下给C和Scheme添加面向对象的支持。让Scheme支持面向对象不过是个稍微费点脑筋的家庭作业。另一方面，让C支持面向对象，你恐怕得有Bjarne Stroustrup的本事才能办到。&lt;/p&gt;

&lt;p&gt;这种对于解决问题所需才能和努力程度上的分歧，造成了&lt;em&gt;Lisp的魔咒&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lisp是如此强大，以至于在其他编程语言中的技术问题，到了Lisp中变成了社会问题。&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;想一想Scheme的情形吧。因为让Scheme支持面向对象是如此轻而易举，许多Scheme黑客都完成过这件事情，更准确地说，是许多&lt;em&gt;独立的&lt;/em&gt;Scheme黑客都完成过。这就导致了在20世纪90年代，这个语言的面向对象支持包像工厂量产出来的库存清单一样数不胜数。想想&lt;a href=&quot;http://en.wikipedia.org/wiki/The_Paradox_of_Choice%3A_Why_More_Is_Less&quot;&gt;选择谬论&lt;/a&gt;就知道，没有哪一个包能够成为正式的标准。如今某些Scheme实现已经有了它们自己的面向对象功能，这还不算太坏。尽管如此，那些五花八门的由不同独立开发者开发出来的包所造成的问题，正如Olin Shivers在给&lt;a href=&quot;http://en.wikipedia.org/wiki/Scsh&quot;&gt;Scheme Shell（scsh）&lt;/a&gt;写文档的时候所提到的一样。&lt;/p&gt;

&lt;p&gt;独立黑客们写出来的程序基本上遵循“抓痒模型”。这些程序解决了写程序的黑客们自己关心的问题，但是却未必能很好地处理对于其他人来说有用的部分功能。况且，虽说这些程序无疑可以在这个黑客自己的环境配置上运行得很好，但却不一定能移植到其他的Scheme实现、甚至不同平台上的同一Scheme实现上。文档可能会极度匮乏。从现实的角度讲，一个黑客用自己挤出来的空闲时间做出来的项目，当然也可能会因为黑客自己的现实生活问题而烂尾。正如Olin Shivers指出的那样，这些个人性质的项目更倾向于解决整个问题的百分之八十。&lt;/p&gt;

&lt;p&gt;Mark Tarver博士的文章，&lt;a href=&quot;http://www.lambdassociates.org/blog/bipolar.htm&quot;&gt;The Bipolar Lisp Programmer（双面Lisp程序员）&lt;/a&gt;，对这种现象有一个确切的表述。他写道，这些“孤狼”式的Lisp黑客以及他们：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;……不能把事情恰当地做完收尾。所谓的“用过就扔设计”绝对和&lt;a href=&quot;https://www.healthtap.com/#topics/big-bowel-movements&quot;&gt;拉屎&lt;/a&gt;这件事儿没什么两样（注：原文如此），而它来源于Lisp社区。Lisp允许你如此虎头蛇尾地了结一件事，而且还让你心安理得地这么去做。十年前，我有一次需要给我的Lisp程序写一个GUI。没问题，我找到了9个GUI库。麻烦在于这9个库没有一个拥有足够完整的文档，而且它们全部是bug充斥的。基本上，每个人都实现了他们自己的一套解决方案，对于他们来说能用就行。这是一种拉屎式的态度（注：原文如此）；反正我做到了，我消化它了。这同样也是无须在他人帮助下即可得到的产物。&lt;/em&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;那么再想一想C语言在上述思维实验中的情形吧。由于在C上面实现面向对象支持的困难程度，只有两个严肃的解决方案摆上了台面：C++，以及Objective-C。Objective-C在Mac上最为流行，而C++几乎统治了其他一切平台。这意味着，给定一个平台，如何让C支持面向对象的扩展几乎已经被唯一确定了。这意味着这些语言的面向对象支持将拥有完善的文档，高度集成的IDE，和兼容性良好的库，等等。&lt;/p&gt;

&lt;p&gt;Mark Tarver博士的文章说到这一点：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;现在与之相反，C/C++的做事方式完全不同。用镊子和胶水一步步搭建成一个东西实在太他妈困难了，所以你所做的一切都是实实在在的成就。你想要为它好好地写些文档。你会在做一个规模可观的C语言项目时候需要他人的帮助；因此你也更加容易变得社会性、学会去与他人合作。你需要做到这些，因为你需要完成某件事情。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;而全部的这些，从一个雇主的角度来讲，是非常吸引人的。十个能够相互交流、写文档与团队协作的人显然会比一个像拉翔一样自己去hack些Lisp代码的人更有用，而这种翔的替代品只能是另一坨翔，这些翔们随时都可能因为某些个人的问题、自己退出项目而丢下一个不可收拾的烂摊子。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;所以说，那些懂C的人不会去纠结“我应该用哪种面向对象系统？”相反，他们会去选择C++或者Objective-C，就像他们的同事所选择的一样，然后他们会提问“我该怎样使用面向对象的功能X？”答案很简单：&lt;a href=&quot;http://www.baidu.com/&quot;&gt;“咕狗一下，你就知道。”&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;真正的黑客，当然早就知道面向对象并非如它的拥趸们所宣称的那样是解决一切问题的灵丹妙药。真正的黑客已经在探寻更加高阶的概念，诸如不可变数据结构、类型推断、惰性求值、monad、arrow、模式匹配、约束编程，等等。真正的黑客也都知道，C/C++对于写大部分不需要进行任意位操作的程序来说并不合适。尽管如此，Lisp的魔咒仍然存在。&lt;/p&gt;

&lt;p&gt;一些沾沾自喜的Lisp发烧友，调研了当前学术界编程语言的硕果（Haskell、OCaml等等）后，发现它们所缺失的一些特性，要么就是已经在Lisp中存在、要么就是可以用Lisp很轻易地实现——并且可以&lt;a href=&quot;http://www.reddit.com/r/programming/comments/ujj3/a_critique_of_abelson_and_sussman_or_why/cutzn&quot;&gt;改进&lt;/a&gt;——基于Lisp宏。他们也许是对的。&lt;/p&gt;

&lt;p&gt;但是太可惜了，Lisp黑客们。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Mark Tarver博士——在上面已经两次引用过——曾经设计过一个Lisp的方言，叫做&lt;a href=&quot;http://www.lambdassociates.org/&quot;&gt;Qi&lt;/a&gt;。它仅仅由少于一万行的宏组成，基于Clisp运行。它实现了绝大部分Haskell和OCaml所独有的特性。从某个方面来说，Qi甚至超越了它们。举个例子说吧，Qi的类型推断引擎本身是&lt;em&gt;图灵完全&lt;/em&gt;的。在&lt;a href=&quot;http://www.wimp.com/theman/&quot;&gt;这样的&lt;/a&gt;一个由天才科学家组成的杰出团队才能开发出Haskell语言的世界中，Tarver博士，他完全是一个人做出来了Qi。&lt;/p&gt;

&lt;p&gt;再看一眼上面这段话。仔细想想，是不是可怕极了。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;em&gt;给读者的习题&lt;/em&gt;：假想Haskell与Common Lisp之间发生了激烈的对抗，下一步将会发生什么？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;答案&lt;/em&gt;：Lisp魔咒应验了。每两个或者三个Lisp黑客就会开发出一套属于自己的惰性求值、纯函数式、arrow、模式匹配、类型推断等等的实现。大部分这种项目都是孤狼式开发。因而，它们具备大部人所需要的80%功能（虽然这80%的定义会随情况不同而各异）。它们的文档通常会很差。它们无法在不同的Lisp系统上移植。有些项目可能起初信誓旦旦地会维护下去，直到开发者决定自己跑到别处赚钱去了，结果丢下一个无法收拾的烂摊子。有一些可能会在某种程度上多多少少地打败Haskell，但是它的认可度会被&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/comp.lang.lisp&quot;&gt;comp.lang.lisp&lt;/a&gt;新闻组里面的口水战淹没。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;故事的结局&lt;/em&gt;：任意一个传统的Lisp黑客的宏能够拼凑成一个文档匮乏的、不可移植的、bug充斥的80%的Haskell实现，&lt;em&gt;仅仅因为&lt;/em&gt;Lisp是一种比Haskell表达力更加强大的语言。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;这个故事的教育意义在于，&lt;strong&gt;次级效应和三级效应至关重要&lt;/strong&gt;。技术不只是影响我们解决技术问题的方式，它也影响着我们的社会行为。而社会行为会反馈并施加影响于我们最初试图解决的技术问题。&lt;/p&gt;

&lt;p&gt;Lisp是一个活生生的事例。Lisp是如此强大有力，它鼓励个人的、狂热的特立独行。在&lt;a href=&quot;http://en.wikipedia.org/wiki/Lisp_machine&quot;&gt;Lisp机器&lt;/a&gt;曾经盛极一时的年代，这种特立独行产生了举世瞩目的成果。但也正是同样的特立独行，阻碍了所谓“自底而上纯Lisp实现”的计算机系统的复苏；自Symbolics和LMI夭折之后，再也没有一个“Lisp操作系统”项目达到过值得令人关注的高度。&lt;/p&gt;

&lt;p&gt;这些次级和三级效应的一个后果是，即使Lisp是有史以来最富于表达力的编程语言，以至于理论上几乎不可能创造出比它更具表达力的语言，&lt;em&gt;Lisper们将仍然有许多从其他编程语言那里学习的东西&lt;/em&gt;。Smalltalk程序员们教会了每个人——包括那些Lisp黑客们——多多少少一点关于面向对象的概念。&lt;a href=&quot;http://www.discenda.org/Clean/&quot;&gt;Clean语言&lt;/a&gt;和&lt;a href=&quot;http://www.mozart-oz.org/&quot;&gt;Mozart/Oz&lt;/a&gt;也有着一些自己的奇特之处。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Lisp魔咒并不违背&lt;a href=&quot;http://www.loper-os.org/?p=69&quot;&gt;Stanislav Datskovskiy&lt;/a&gt;的至理名言：&lt;strong&gt;雇主们更喜欢可以被取代的雇员，而不是生产率最高的雇员。&lt;/strong&gt;说得太实在了。你早该醒悟到那些管理学课程只是骗钱的把戏。然而，他这篇文章的最后几行似乎存在问题。请看：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在“自由软件”的世界里，工业界教条仅仅是在口头上被激烈地批判，但却从未在实践中被反对过。那些“办公隔间地狱”里被唯恐避之不及的概念，同样也未曾在业余爱好者中间得到过青睐。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在脚注中，他将Linux作为一个拒绝追求新奇想法的实例。为了例证，他将&lt;a href=&quot;http://slashdot.org/story/00/06/06/1151209/Systems-Research-Is-Dead&quot;&gt;操作系统&lt;/a&gt;作为自己的一个论点（下面评论的1L是SB）。他并没有提到编程语言。Python和Ruby都受到了Lisp的影响。很多它们的饭表示了对Lisp的尊重，而他们的一些兴趣则促进了Lisp的复兴。公正地讲，JavaScript也曾被描述为“披着C外衣的Scheme”，尽管它诞生在那些&lt;a href=&quot;http://www.jwz.org/tent-of-doom/&quot;&gt;办公隔间地狱&lt;/a&gt;中间。&lt;/p&gt;

&lt;p&gt;即便有如此大的影响力，在工业和开源界里，Lisp也仅仅只吸引了一部分程序员的一部分注意力，而这也是拜最近脚本语言的兴起所赐。那些拿着MBA学位的高富帅码农们的思维封闭并不是唯一的原因。“Lisp魔咒”本身能解释更多的事情。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;提供给Lisp的、可用的自由开发环境可以作为“Lisp魔咒”的一个例证。&lt;/p&gt;

&lt;p&gt;尽管说出来让人难堪，但必须得有人去做这件事情。忘掉Lisp机器吧；我们甚至还没有一个能达到算得上&lt;a href=&quot;http://www.opencobalt.org/&quot;&gt;Smalltalk&lt;/a&gt;&lt;a href=&quot;http://www.pharo-project.org/home&quot;&gt;黑客&lt;/a&gt;&lt;a href=&quot;http://www.squeak.org/&quot;&gt;小康标准&lt;/a&gt;的开发环境（&lt;em&gt;“我总赶脚到Lisp是一个牛逼的语言，而Smalltalk是一个牛逼的环境。”&lt;/em&gt;——&lt;a href=&quot;http://onsmalltalk.com/aha-moments-in-lisp&quot;&gt;Ramon Leon&lt;/a&gt;如是说）。除非他们愿意付上千刀美元，否则Lisp黑客们仍然会受制于Emacs。&lt;del&gt;（翻译君：&lt;a href=&quot;http://www.lispworks.com/buy/prices-1c.html&quot;&gt;比肾还贵&lt;/a&gt;的LispWorks，包邮哦亲，&lt;a href=&quot;http://disney.go.com/wreck-it-ralph/&quot;&gt;欲购从速&lt;/a&gt;哦）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;James Gosling，第一个在Unix上运行的Emacs的作者，&lt;a href=&quot;http://www.computerworld.com.au/article/207799/don_t_use_emacs_says_java_father/&quot;&gt;恰当地指出了&lt;/a&gt;Emacs已经长达二十年没有任何基础上的变动。这是因为，Emacs维护者们只是不断地在这个当年由一个MIT的AI实验室的研究生做的设计上垒代码，那时Emacs项目仍然间接地从国债那里获得资助。也许Slashdot喷子会反驳说Emacs已经无所不能，它可以完成其它任何开发环境所能做的事情，而且只会完成得更好。不然那些&lt;a href=&quot;http://www.ymeme.com/zmacs-vs-emacs-manual.html&quot;&gt;当年曾经用过&lt;/a&gt;Lisp机器的也要这么说。&lt;/p&gt;

&lt;p&gt;那么，为什么Lisp黑客们没有把那些Smalltalk家伙们给彻底打败呢？为什么他们没有做出一个自由的开发环境，可以从某种程度上唤回Lisp机器曾经的辉煌，即使他们不能够重现出另一个Lisp机器？&lt;/p&gt;

&lt;p&gt;这件事没有发生的原因来自于Lisp魔咒。大量的Lisp黑客应该去协作。说得更详细些：大量&lt;em&gt;成为Lisp黑客的人们&lt;/em&gt;应该去协作。而且他们应该学会合作去做一个新的设计、而非遵从一个从一开始就写死了的现有设计。这过程中不应该有任何来自外界的压力，例如风险资本家或者企业雇主，来干涉他们做事的方式。&lt;/p&gt;

&lt;p&gt;每个项目都会存在参与者的分歧，诸如意见不合、风格或哲学上的冲突。如果这些社会性的问题持续下去，任何大的项目都无法完成，这就产生了一个让它们倾向于解决的反作用力。“要么我们团结一心，要么我们都会被吊死在同一棵树上”。而Lisp的强大表达能力削弱了这个反作用力；一个人总可以着手去自搞一套。这样，刚愎自用的黑客们认为不值得去应付观点分歧带来的麻烦；因此他们要么退出了合作项目，要么就干脆不参加已有的项目、而选择自力更生从头开始。这就是Lisp魔咒。&lt;/p&gt;

&lt;p&gt;我们甚至可以自己去hack Emacs，为了追求个人理念中所谓的&lt;em&gt;“足够好”&lt;/em&gt;。于是乎，Lisp诅咒差不多就变成了&lt;a href=&quot;http://en.wikipedia.org/wiki/Worse_is_better&quot;&gt;“坏即是好（Worse is Better）”&lt;/a&gt;的同义词。&lt;del&gt;（翻译君：这最后一段有点不知所云。。。）&lt;/del&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;Lisp的强大表达能力也会带来坏处。天下可没有免费的午餐。&lt;/strong&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Chromium保存网页的.html文件神秘消失问题</title>
        <link href="http://www.soimort.org/posts/123" />
        <updated>2012-10-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/123/chromium-issue</id>
        <content type="html">&lt;p&gt;曾几何时，我的Chromium浏览器（包括Google Chrome在内）出现了某些网页不能正确保存的问题。&lt;/p&gt;

&lt;p&gt;准确地说：网页下载完成之后，&lt;a href=&quot;chrome://downloads&quot;&gt;chrome://downloads&lt;/a&gt;中显示的状态会马上变成“Removed”，&lt;code&gt;_files&lt;/code&gt;文件夹在，但是硬盘上相同的位置却找不到与之对应的&lt;code&gt;.html&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;这个issue的奇妙之处，就在于它难以可预测地重现出来。有时候一个网页第一次不能正确保存，多试上几次就好了。在观察之前，你永远也不知道这个html文件保存成功了与否。。。（看起来就和薛定谔的喵星人实验一样）&lt;/p&gt;

&lt;p&gt;这issue似乎也没法traceback，因为毕竟不是segfault这类硬性bug。很长一段时间里我都不知道是不是只有我一个人遇到了这问题。&lt;/p&gt;

&lt;p&gt;最近终于找到了这个issue，居然在2010年Chrome还是4.0版的时候就有人报过了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/chromium/issues/detail?id=32771&quot;&gt;http://code.google.com/p/chromium/issues/detail?id=32771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chromium的开发人员表示，导致这个bug在长达几年的时间内都没有得到解决的原因是这一块的代码过于复杂和混乱，他们准备在未来几个月内重构这部分代码，希望能够在今年年底内得到解决。。。&lt;/p&gt;

&lt;p&gt;然后是我目前的修补方案（当然不是Chromium的patch，我自己连编译一次都没成功过= =）：&lt;/p&gt;

&lt;p&gt;在Linux下，实际上大部分情况下这个html是保存下来了的，不过是以临时文件&lt;code&gt;.org.chromium.*&lt;/code&gt;的形式，只是Chromium不知为何没有正确地创建最终的&lt;code&gt;.html&lt;/code&gt;文件。（Windows的情况暂时还不清楚）&lt;/p&gt;

&lt;p&gt;进保存网页的目录下，Shell一行流：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3961302.js?file=fix_unsaved_html.sh&quot;&gt;&lt;/script&gt;

&lt;p&gt;或者写成bash函数（放进&lt;code&gt;~/.zshrc&lt;/code&gt;或者&lt;code&gt;~/.bashrc&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code id=&quot;bash&quot;&gt;function fix_unsaved_html {
    i=
    for i in .org.chromium.*; do
        echo -ne &quot;$i : &quot;
        f=`grep -o '&quot;./[^&quot;]*_files/' $i | uniq 2&gt;/dev/null`
        if [ -n &quot;$f&quot; ]; then
            j=${f:3:-7}.html
            mv -f $i $j
            echo &quot;moved to \&quot;$j\&quot;&quot;
        else
            rm -f $i
            echo &quot;removed&quot;
        fi
    done 2&gt;/dev/null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次用Chromium保存完网页后，记得找回丢失的&lt;code&gt;.html&lt;/code&gt;们：&lt;/p&gt;

&lt;pre&gt;&lt;code id=&quot;bash&quot;&gt;$ cd ~/Downloads/
$ fix_unsaved_html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，希望这个几乎与Chromium历史一样悠久的bug如开发者所说，在今年年内能够得到解决。(`・ω・´)&lt;/p&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>RVM + Rails + Heroku开发环境搭建</title>
        <link href="http://www.soimort.org/posts/122" />
        <updated>2012-10-23T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/122/rvm-rails-heroku</id>
        <content type="html">&lt;p&gt;说来惭愧，所有我跟过的在线课程，没有哪一门不是拖到作业截止日期之前的周末才拼命通宵补课赶作业的……&lt;/p&gt;

&lt;p&gt;上学期曾经跟过&lt;a href=&quot;http://www.udacity.com&quot;&gt;Udacity&lt;/a&gt;的&lt;a href=&quot;http://www.udacity.com/overview/Course/cs253/CourseRev/apr2012&quot;&gt;Web Development&lt;/a&gt;（这门课是基于Python + Google App Engine），结果因为拖延半途而废。当然这多多少少和我不太喜欢GAE这个平台（因为它的语言限制加上GAE Datastore的不可移植性）也有关系，加上不想重新去适应Python 2.x。（估计Google会坚持在GAE上强推它自己的Go，对py3k的支持看来是无望了）&lt;/p&gt;

&lt;p&gt;这学期因为决定了要考语言，放弃了感兴趣的&lt;a href=&quot;https://www.coursera.org/course/compdata&quot;&gt;Computing for Data Analysis&lt;/a&gt;、&lt;a href=&quot;https://www.coursera.org/course/progfun&quot;&gt;Scala&lt;/a&gt;和其他好几门在线课程，只跟下来了&lt;a href=&quot;https://www.edx.org&quot;&gt;edX&lt;/a&gt;的&lt;a href=&quot;https://www.edx.org/courses/BerkeleyX/CS169.1x/2012_Fall&quot;&gt;CS169.1x (SaaS)&lt;/a&gt;。闲话少说，UC Berkeley CS169用的是Ruby on Rails + Heroku，很对我的口味，简单统一的语言/框架（比起Ruby，想一想Python下鱼龙混杂的web框架、还有语言自身2/3版本不兼容带来的内耗和遗留问题）、简单的云平台（和AWS比起来，Heroku确实易用得多）。&lt;/p&gt;

&lt;p&gt;尽管如此，要在RVM上安装Rails开发环境并且让程序最终在Heroku上成功跑起来，可能并没有想象中那么容易，值得在此记录一下。（事实上这东西折腾了我一个周末，比最后实际写代码的时间都要多……）&lt;/p&gt;

&lt;p&gt;（p.s. 这个jekyll博客的所有帖子URL也都换成rails风格的了，看起来比以前清爽了许多哈哈）&lt;/p&gt;

&lt;h2&gt;RVM的安装与使用&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://rvm.beginrescueend.com/&quot;&gt;RVM (Ruby Version Manager)&lt;/a&gt;是一套用来管理不同版本的Ruby及其Gems的命令行工具。它允许你在同一个系统/用户下安装多个不同版本（或不同实现）的Ruby，而无须借助虚拟机。&lt;/p&gt;

&lt;p&gt;安装RVM前，确保系统中已经装有curl和git。&lt;/p&gt;

&lt;p&gt;如果当前系统下已经安装了Ruby，可以通过gem来安装RVM（将RVM作为系统Ruby的一个gem来管理和使用）。不推荐这种方法，现在应当使用官方提供的安装脚本独立地安装RVM：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ curl -L get.rvm.io | bash -s stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成后，手动将以下行添加到Shell的启动脚本（我的是&lt;code&gt;~/.zshrc&lt;/code&gt;。根据实际情况当然也可以是&lt;code&gt;~/.bashrc&lt;/code&gt;、&lt;code&gt;~/.bash_login&lt;/code&gt;或者&lt;code&gt;~/.zprofile&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;[[ -s &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot; ]] &amp;amp;&amp;amp; . &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在这里不需要再将RVM的bin目录手动添加到&lt;code&gt;$PATH&lt;/code&gt;。也就是说，&lt;code&gt;PATH=$PATH:$HOME/.rvm/bin&lt;/code&gt;这一行在&lt;code&gt;~/.zshrc&lt;/code&gt;中并不是必需的。&lt;/p&gt;

&lt;p&gt;如果在GNOME terminal + zsh中使用RVM，参考以下说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integrating RVM with gnome-terminal:&lt;/strong&gt; &lt;a href=&quot;https://rvm.io/integration/gnome-terminal/&quot;&gt;https://rvm.io/integration/gnome-terminal/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将custom command一项设置为&lt;code&gt;/bin/zsh --login&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;Shell启动脚本（例如&lt;code&gt;~/.zshrc&lt;/code&gt;）修改后，打开一个新的terminal session（或执行&lt;code&gt;source ~/.zshrc&lt;/code&gt;）。测试RVM是否安装成功：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ type rvm | head -n1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;rvm is a shell function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表明安装已成功。&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm notes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm requirements
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看RVM的功能提示、依赖信息等等。以后每次升级过RVM后都应检查这些信息，以确保RVM能正常工作。&lt;/p&gt;

&lt;p&gt;在Arch Linux中，运行RVM会出现类似如下的警告：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;BEWARE! rubygems &amp;quot;--user-install&amp;quot; option is not recommended
for RVM installations.
Double check your /etc/gemrc.
You could remove this warning by adding &amp;#39;export rvm_ignore_gemrc_issues=1&amp;#39;
to your ~/.rvmrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从&lt;code&gt;/etc/gemrc&lt;/code&gt;中注释掉以下行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;#gem: --user-install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让RVM决定所有gems的安装位置，而不是直接使用系统RubyGems的&lt;code&gt;$HOME/.gem/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查看所有可供安装的Ruby版本（包括MRI/YARV、Rubinius、REE、MacRuby、JRuby和IronRuby等不同实现）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm list known
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新安装的RVM中没有任何可用的Ruby。使用&lt;code&gt;rvm install&lt;/code&gt;命令进行安装。例如安装1.9.3-p286版本的MRI（官方Ruby）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm install 1.9.3-p286
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设定某个版本为RVM的默认Ruby：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm use 1.9.3-p286 --default
Using .../.rvm/gems/ruby-1.9.3-p286
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者设定RVM在默认情况下不使用RVM中的Ruby，而使用系统Ruby：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm use system --default
Now using system ruby.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看RVM中所有已安装的Ruby版本：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm list

rvm rubies

   jruby-1.6.8 [ x86_64 ]
=* ruby-1.9.3-p286 [ x86_64 ]

# =&amp;gt; - current
# =* - current &amp;amp;&amp;amp; default
#  * - default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示该版本为RVM默认Ruby，&lt;code&gt;=&lt;/code&gt;表示该版本为RVM当前正在使用的Ruby。&lt;/p&gt;

&lt;p&gt;切换到RVM的默认Ruby：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者切换到某指定版本的RVM Ruby：（注意到RVM会自动在&lt;code&gt;$PATH&lt;/code&gt;变量中添加相应版本Ruby的gems bin目录）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm 1.9.3-p286
$ rvm current
ruby-1.9.3-p286
$ which ruby
.../.rvm/rubies/ruby-1.9.3-p286/bin/ruby
$ echo $PATH
.../.rvm/gems/ruby-1.9.3-p286/bin:
.../.rvm/gems/ruby-1.9.3-p286@global/bin:
.../.rvm/rubies/ruby-1.9.3-p286/bin:
.../.rvm/bin:
/usr/local/bin:/usr/bin:/bin:...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者切换到系统Ruby（非RVM Ruby）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm system
$ rvm current
system
$ which ruby
/usr/bin/ruby
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多关于RVM的使用，参见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RVM - ArchWiki:&lt;/strong&gt; &lt;a href=&quot;https://wiki.archlinux.org/index.php/RVM&quot;&gt;https://wiki.archlinux.org/index.php/RVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RVM的卸载（简单的说只要删除&lt;code&gt;~/.rvm&lt;/code&gt;目录和&lt;code&gt;~/.rvmrc&lt;/code&gt;，以及改回原来的Shell启动脚本即可）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm implode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Gems和Bundler&lt;/h2&gt;

&lt;p&gt;查看系统Ruby的gems目录位置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm system
$ rvm gemdir
/usr/lib/ruby/gems/1.9.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若系统&lt;code&gt;/etc/gemrc&lt;/code&gt;中有&lt;code&gt;gem: --user-install&lt;/code&gt;，或用户的&lt;code&gt;~/.gemrc&lt;/code&gt;中显式设定了&lt;code&gt;gemhome: .../.gem/ruby/1.9.1&lt;/code&gt;，则系统Ruby的gems位置是位于用户主目录下的&lt;code&gt;~/.gem&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm gemdir
.../.gem/ruby/1.9.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;rvm use&lt;/code&gt;切换到RVM中的Ruby后，&lt;code&gt;rvm gemdir&lt;/code&gt;的结果不应再是以上两种之一！此时的gems位置应该在用户主目录中的&lt;code&gt;~/.rvm&lt;/code&gt;下，类似如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm 1.9.3
$ rvm gemdir
.../.rvm/gems/ruby-1.9.3-p286
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不是，则应该修改&lt;code&gt;/etc/gemrc&lt;/code&gt;或&lt;code&gt;~/.gemrc&lt;/code&gt;中的设置。&lt;/p&gt;

&lt;p&gt;RVM中新安装的Ruby仅包含有限几个预装的gems：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem list

*** LOCAL GEMS ***
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm gemset empty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以卸载当前Ruby的所有gems。&lt;/p&gt;

&lt;p&gt;更多关于RVM下gemset的使用方法，参见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Get started right with RVM:&lt;/strong&gt; &lt;a href=&quot;http://sirupsen.com/get-started-right-with-rvm/&quot;&gt;http://sirupsen.com/get-started-right-with-rvm/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Named Gem Sets:&lt;/strong&gt; &lt;a href=&quot;https://rvm.io/gemsets/basics/&quot;&gt;https://rvm.io/gemsets/basics/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://gembundler.com/&quot;&gt;Bundler&lt;/a&gt;是一套用于自动解决Ruby项目中各种gems依赖关系的工具。很多Ruby项目依赖于某些特定版本的gems，Bundler省去了在不同机器上部署时手动处理依赖的繁琐。它本身可以通过gem安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install bundler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后你就可以使用&lt;code&gt;bundle install&lt;/code&gt;命令来构建很多常见的Ruby on Rails项目了（只要有&lt;code&gt;Gemfile&lt;/code&gt;存在）。Bundler在构建过程中会自动解决需要的gems依赖（因此你无需再手动安装Rails）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ bundle install --without production
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;--without production&lt;/code&gt;选项用于指定仅安装在开发环境下（而非生产环境）所需要的依赖。&lt;/p&gt;

&lt;h2&gt;解决存在bug的Gems依赖&lt;/h2&gt;

&lt;p&gt;理论上，&lt;code&gt;bundle install&lt;/code&gt;命令可以自动完成从gems依赖安装到项目构建这一系列过程。但现实的状况是：所要构建的Rails项目中经常会出现所依赖的gems安装失败的情形。&lt;/p&gt;

&lt;p&gt;这些gems包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;linecache19 0.5.12&lt;/strong&gt;（ruby-debug19的依赖）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ruby-debug-base19 0.11.25&lt;/strong&gt;（ruby-debug19的依赖）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;therubyracer 0.9.9&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;貌似是因为在我的系统Ruby（1.9.3）上构建这些gems的native extensions所使用的库文件（1.9.1）不兼容所导致的。为什么Arch上的Ruby 1.9.3用的是Ruby 1.9.1的库文件？我也不知道……&lt;/p&gt;

&lt;p&gt;Bundler错误信息之一（linecache19安装失败）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Installing linecache19 (0.5.12) with native extensions 
Gem::Installer::ExtensionBuildError: ERROR:
Failed to build gem native extension.

        /usr/bin/ruby extconf.rb 
checking for vm_core.h... no
/usr/lib/ruby/gems/1.9.1/gems/ruby_core_source-0.1.5/lib/ruby_core_source.rb:
39: Use RbConfig instead of obsolete and deprecated Config.
checking for vm_core.h... no
*** extconf.rb failed ***
Could not create Makefile due to some reason, probably lack of
necessary libraries and/or headers.  Check the mkmf.log file for more
details.  You may need configuration options.
...
Gem files will remain installed in
.../.bundler/tmp/32123/gems/linecache19-0.5.12 for inspection.
Results logged to
.../.bundler/tmp/32123/gems/linecache19-0.5.12/ext/trace_nums/gem_make.out
An error occurred while installing linecache19 (0.5.12),
and Bundler cannot continue.
Make sure that `gem install linecache19 -v &amp;#39;0.5.12&amp;#39;`
succeeds before bundling.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bundler错误信息之二（ruby-debug-base19安装失败）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Installing ruby-debug-base19 (0.11.25) with native extensions 
Gem::Installer::ExtensionBuildError: ERROR:
Failed to build gem native extension.

        /usr/bin/ruby extconf.rb 
checking for rb_method_entry_t.body in method.h... no
checking for vm_core.h... no
/usr/lib/ruby/gems/1.9.1/gems/ruby_core_source-0.1.5/lib/ruby_core_source.rb:
39: Use RbConfig instead of obsolete and deprecated Config.
checking for rb_method_entry_t.body in method.h... no
checking for vm_core.h... no
*** extconf.rb failed ***
Could not create Makefile due to some reason, probably lack of
necessary libraries and/or headers.  Check the mkmf.log file for more
details.  You may need configuration options.
...
Gem files will remain installed in
.../.bundler/tmp/32432/gems/ruby-debug-base19-0.11.25 for inspection.
Results logged to
.../.bundler/tmp/32432/gems/ruby-debug-base19-0.11.25/ext/ruby_debug/gem_make.out
An error occurred while installing ruby-debug-base19 (0.11.25),
and Bundler cannot continue.
Make sure that `gem install ruby-debug-base19 -v &amp;#39;0.11.25&amp;#39;`
succeeds before bundling.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尝试了手动从gem安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install linecache19 -v &amp;#39;0.5.12&amp;#39;
$ gem install ruby-debug-base19 -v &amp;#39;0.11.25&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在构建native extensions这一步都会出错。参考了StackOverflow上的一篇帖子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Error in “bundle install”:&lt;/strong&gt; &lt;a href=&quot;http://stackoverflow.com/questions/10114416/error-in-bundle-install&quot;&gt;http://stackoverflow.com/questions/10114416/error-in-bundle-install&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是从AUR安装了Ruby 1.9.3的source（&lt;a href=&quot;http://aur.archlinux.org/packages.php?ID=58447&quot;&gt;ruby-source 1.9.3_p194-1&lt;/a&gt;），然后在gem安装时手动指定include目录：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install linecache19 -- --with-ruby-include=/usr/src/ruby-1.9.3-p194/
Fetching: archive-tar-minitar-0.5.2.gem (100%)
Fetching: ruby_core_source-0.1.5.gem (100%)
Fetching: linecache19-0.5.12.gem (100%)
Building native extensions.  This could take a while...
Successfully installed archive-tar-minitar-0.5.2
Successfully installed ruby_core_source-0.1.5
Successfully installed linecache19-0.5.12
3 gems installed
Installing ri documentation for archive-tar-minitar-0.5.2...
Installing ri documentation for ruby_core_source-0.1.5...
Installing ri documentation for linecache19-0.5.12...
Installing RDoc documentation for archive-tar-minitar-0.5.2...
Installing RDoc documentation for ruby_core_source-0.1.5...
Installing RDoc documentation for linecache19-0.5.12...

$ gem install ruby-debug-base19 -- --with-ruby-include=/usr/src/ruby-1.9.3-p194/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功。&lt;/p&gt;

&lt;p&gt;从gem安装therubyracer失败：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install therubyracer -v &amp;#39;0.9.9&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考StackOverflow上的另一篇帖子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Why does therubyracer fails to build on my Debian:&lt;/strong&gt; &lt;a href=&quot;http://stackoverflow.com/questions/8991963/why-does-therubyracer-fails-to-build-on-my-debian&quot;&gt;http://stackoverflow.com/questions/8991963/why-does-therubyracer-fails-to-build-on-my-debian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过我估计是therubyracer 0.9.9（版本较旧）与最新的libv8不兼容的原因，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem list libv8

*** LOCAL GEMS ***

libv8 (3.11.8.3 x86_64-linux, 3.3.10.4 x86_64-linux)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;移除了最新的libv8 3.11.8.3，默认使用之前Bundler自动安装的3.3.10.4：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem uninstall libv8 -v &amp;#39;3.11.8.3&amp;#39;
Successfully uninstalled libv8-3.11.8.3-x86_64-linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;果然安装成功：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install therubyracer -v &amp;#39;0.9.9&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bundler这时也能成功构建了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ bundle install --without production
Fetching gem metadata from http://rubygems.org/.
Error Bundler::HTTPError during request to dependency API
Fetching full source index from http://rubygems.org/
Enter your password to install the bundled RubyGems to your system: 
Using rake (0.9.2.2) 
Using multi_json (1.0.4) 
Using activesupport (3.1.0) 
Using bcrypt-ruby (3.0.1) 
Using builder (3.0.0) 
Using i18n (0.6.0) 
Using activemodel (3.1.0) 
Using erubis (2.7.0) 
Using rack (1.3.5) 
Using rack-cache (1.0.3) 
Using rack-mount (0.8.3) 
Using rack-test (0.6.1) 
Using hike (1.2.1) 
Using tilt (1.3.3) 
Using sprockets (2.0.3) 
Using actionpack (3.1.0) 
Using mime-types (1.17.2) 
Using polyglot (0.3.3) 
Using treetop (1.4.10) 
Using mail (2.3.0) 
Using actionmailer (3.1.0) 
Using arel (2.2.1) 
Using tzinfo (0.3.31) 
Using activerecord (3.1.0) 
Using activeresource (3.1.0) 
Using archive-tar-minitar (0.5.2) 
Using coffee-script-source (1.2.0) 
Using execjs (1.2.13) 
Using coffee-script (2.2.0) 
Using rack-ssl (1.3.2) 
Using json (1.6.3) 
Using rdoc (3.12) 
Using thor (0.14.6) 
Using railties (3.1.0) 
Using coffee-rails (3.1.1) 
Using columnize (0.3.5) 
Using haml (3.1.4) 
Using jquery-rails (1.0.19) 
Using libv8 (3.3.10.4) 
Using ruby_core_source (0.1.5) 
Using linecache19 (0.5.12) 
Using bundler (1.2.1) 
Using rails (3.1.0) 
Using ruby-debug-base19 (0.11.25) 
Using ruby-debug19 (0.11.6) 
Using sass (3.1.12) 
Using sass-rails (3.1.5) 
Using sqlite3 (1.3.5) 
Using therubyracer (0.9.9) 
Installing uglifier (1.2.2) 
Your bundle is complete! Use `bundle show [gemname]` to see
where a bundled gem is installed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来问题是解决了。但是，运行Rails后却跳出以下“undefined symbol”的错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;rake aborted!
.../gems/ruby-1.9.3-p286/gems/ruby-debug-base19-0.11.25/lib/ruby_debug.so:
undefined symbol: ruby_current_thread -
.../gems/ruby-1.9.3-p286/gems/ruby-debug-base19-0.11.25/lib/ruby_debug.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;a href=&quot;http://rails.vandenabeele.com/blog/2011/12/21/installing-ruby-debug19-with-ruby-1-dot-9-3-on-rvm/&quot;&gt;这篇文章&lt;/a&gt;中所说的现象一模一样。导致&lt;code&gt;ruby_debug.so&lt;/code&gt;链接库错误的罪魁祸首就是这两个库：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;linecache19 0.5.12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ruby-debug-base19 0.11.25&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法参考了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://rails.vandenabeele.com/blog/2011/12/21/installing-ruby-debug19-with-ruby-1-dot-9-3-on-rvm/&quot;&gt;http://rails.vandenabeele.com/blog/2011/12/21/installing-ruby-debug19-with-ruby-1-dot-9-3-on-rvm/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8378277/cannot-use-ruby-debug19-with-1-9-3-p0&quot;&gt;http://stackoverflow.com/questions/8378277/cannot-use-ruby-debug19-with-1-9-3-p0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.wyeworks.com/2011/11/1/ruby-1-9-3-and-ruby-debug/&quot;&gt;http://blog.wyeworks.com/2011/11/1/ruby-1-9-3-and-ruby-debug/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/1331533&quot;&gt;https://gist.github.com/1331533&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，下载这两个打过补丁的gems：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;linecache19 0.5.13&lt;/strong&gt; &lt;a href=&quot;http://rubyforge.org/frs/download.php/75414/linecache19-0.5.13.gem&quot;&gt;http://rubyforge.org/frs/download.php/75414/linecache19-0.5.13.gem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ruby-debug-base19 0.11.26&lt;/strong&gt; &lt;a href=&quot;http://rubyforge.org/frs/download.php/75415/ruby-debug-base19-0.11.26.gem&quot;&gt;http://rubyforge.org/frs/download.php/75415/ruby-debug-base19-0.11.26.gem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;替换掉&lt;code&gt;RubyGems.org&lt;/code&gt;上会导致错误的旧版本：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install linecache19-0.5.13.gem
$ gem install ruby-debug-base19-0.11.26.gem --
  --with-ruby-include=/usr/src/ruby-1.9.3-p194/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;Gemfile&lt;/code&gt;中指定使用新版本的gems：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;gem &amp;#39;linecache19&amp;#39;, &amp;#39;0.5.13&amp;#39;
gem &amp;#39;ruby-debug-base19&amp;#39;, &amp;#39;0.11.26&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ bundle update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行Rails server。现在可以正常工作了！&lt;/p&gt;

&lt;h2&gt;Rails：找不到JavaScript运行时&lt;/h2&gt;

&lt;p&gt;当未在Bundler的&lt;code&gt;Gemfile&lt;/code&gt;中指定使用的therubyracer时，直接运行Rails server可能会导致“Could not find a JavaScript runtime.”错误。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rake
rake aborted!
Could not find a JavaScript runtime.
See https://github.com/sstephenson/execjs for a list of available runtimes.

(See full trace by running task with --trace)

$ rails server
.../.rvm/gems/ruby-1.9.3-p286/gems/execjs-1.4.0/lib/execjs/runtimes.rb:51:
in `autodetect&amp;#39;: Could not find a JavaScript runtime.
See https://github.com/sstephenson/execjs for a list of available runtimes.
(ExecJS::RuntimeUnavailable)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7092107/rails-3-1-error-could-not-find-a-javascript-runtime&quot;&gt;http://stackoverflow.com/questions/7092107/rails-3-1-error-could-not-find-a-javascript-runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9202324/execjs-could-not-find-a-javascript-runtime-but-execjs-and-therubyracer-are-in&quot;&gt;http://stackoverflow.com/questions/9202324/execjs-could-not-find-a-javascript-runtime-but-execjs-and-therubyracer-are-in&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6282307/execjs-and-could-not-find-a-javascript-runtime&quot;&gt;http://stackoverflow.com/questions/6282307/execjs-and-could-not-find-a-javascript-runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐的解决方法是安装Node.js以取代therubyracer作为JavaScript运行时环境：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo pacman -S nodejs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;部署到Heroku&lt;/h2&gt;

&lt;p&gt;你依然可以通过gem来安装&lt;a href=&quot;http://rubygems.org/gems/heroku&quot;&gt;Heroku客户端&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem install heroku
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过官方已经不再推荐使用gem安装。通过以下命令安装最新的&lt;a href=&quot;https://toolbelt.heroku.com/&quot;&gt;Heroku toolbelt&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ wget -qO- https://toolbelt.heroku.com/install-other.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加以下行到&lt;code&gt;~/.zshrc&lt;/code&gt;（或其他类似地方）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;PATH=/usr/local/heroku/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查Heroku toolbelt能否正常工作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ heroku version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Heroku帐号进行登录、SSH验证：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ heroku login
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GitHub上有许多Heroku提供的官方示例。例如Ruby：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/heroku/ruby-sample.git
$ cd ruby-sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个Heroku App（系统会分配一个随机生成的ID作为你的App的域名）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ heroku create
Creating arcane-tundra-6426... done, stack is cedar
http://arcane-tundra-6426.herokuapp.com/ | git@heroku.com:arcane-tundra-6426.git
Git remote heroku added
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过Git即可简单部署App到Heroku：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多Heroku的文档参见：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://devcenter.heroku.com/&quot;&gt;https://devcenter.heroku.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Getting Started with Heroku:&lt;/strong&gt; &lt;a href=&quot;https://devcenter.heroku.com/articles/quickstart&quot;&gt;https://devcenter.heroku.com/articles/quickstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Getting Started with Ruby on Heroku:&lt;/strong&gt; &lt;a href=&quot;https://devcenter.heroku.com/articles/ruby&quot;&gt;https://devcenter.heroku.com/articles/ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Getting Started with Rails 3.x on Heroku:&lt;/strong&gt; &lt;a href=&quot;https://devcenter.heroku.com/articles/rails3&quot;&gt;https://devcenter.heroku.com/articles/rails3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;其他重要事项&lt;/h2&gt;

&lt;h3&gt;RVM初始脚本的导入&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;[[ -s &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot; ]] &amp;amp;&amp;amp; . &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行应当添加到&lt;code&gt;~/.zshrc&lt;/code&gt;或&lt;code&gt;~/.bashrc&lt;/code&gt;的&lt;strong&gt;末尾&lt;/strong&gt;，即必须在对&lt;code&gt;$GEM_HOME&lt;/code&gt;和&lt;code&gt;$PATH&lt;/code&gt;变量的设置之后。否则当设定了除system以外的RVM Ruby为默认Ruby时，启动新的shell session会导致各种环境变量值的混乱（&lt;code&gt;$GEM_HOME&lt;/code&gt;、&lt;code&gt;$PATH&lt;/code&gt;和&lt;code&gt;rvm current&lt;/code&gt;、&lt;code&gt;rvm gemdir&lt;/code&gt;的值不匹配），这可能会造成包括Heroku toolbelt在内的很多Ruby程序出错。&lt;/p&gt;

&lt;h3&gt;Bundler和$GEM_HOME&lt;/h3&gt;

&lt;p&gt;在Arch Linux上，为了使Bundler能够正常工作，需要存在环境变量&lt;code&gt;$GEM_HOME&lt;/code&gt;。否则执行&lt;code&gt;bundle install&lt;/code&gt;会出现如下错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Could not install to path `` because of an invalid symlink.
Remove the symlink so the directory can be created.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若使用RVM Ruby，&lt;code&gt;$GEM_HOME&lt;/code&gt;和&lt;code&gt;$GEM_PATH&lt;/code&gt;变量的值会被自动设置，Bundler不会出错。&lt;/p&gt;

&lt;p&gt;若使用&lt;code&gt;rvm system&lt;/code&gt;命令切换到系统Ruby，&lt;code&gt;$GEM_HOME&lt;/code&gt;和&lt;code&gt;$GEM_PATH&lt;/code&gt;变量不知何故会丢失（变成空值）。暂时没有找到好的解决方法，只能手动&lt;code&gt;export $GEM_HOME&lt;/code&gt;，或指定Bundler使用其他的路径：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ bundle install --path .bundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;一些有用的命令&lt;/h3&gt;

&lt;p&gt;查看当前RVM信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ rvm info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看当前RubyGems环境：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ gem env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </entry>
    
    
    
    <entry>
        <title>YouTube Live Stream直播视频的下载</title>
        <link href="http://www.soimort.org/posts/121" />
        <updated>2012-09-06T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/121/live-stream</id>
        <content type="html">&lt;p&gt;上周在&lt;a href=&quot;http://www.youtube.com/live&quot;&gt;YouTube Live&lt;/a&gt;上看了&lt;a href=&quot;https://plus.google.com/+AKB48/posts/giJESU7pbcT&quot;&gt;AKB48劇場 前田敦子卒業公演&lt;/a&gt;的直播，顺便研究了一下这个问题。&lt;/p&gt;

&lt;p&gt;开学这一阵子琐事比较多……不过今天终于还是决定把这篇东西发出来了。&lt;/p&gt;

&lt;h2&gt;什么是&lt;a href=&quot;http://www.youtube.com/live&quot;&gt;YouTube Live Stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;简单地讲，就是YouTube提供的&lt;a href=&quot;http://en.wikipedia.org/wiki/Webcast&quot;&gt;视频节目播送&lt;/a&gt;（broadcasting）服务。与YouTube通常提供的那些视频分享不同，Live Stream是限时播放的，所以你可以把它类比成电视节目之类的东西。&lt;/p&gt;

&lt;p&gt;YouTube提供的&lt;a href=&quot;http://www.youtube.com/live&quot;&gt;Live Stream服务&lt;/a&gt;在全球范围内被广泛用于视频节目的网络播送，但在德国除外，原因是在一个叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Gesellschaft_f%C3%BCr_musikalische_Auff%C3%BChrungs-_und_mechanische_Vervielf%C3%A4ltigungsrechte&quot;&gt;GEMA&lt;/a&gt;的邪恶组织操纵下，德国据说制定了一项规定“任何（潜在可能）超过300人观看的播送类节目都必须事先取得许可否则将处以50万欧元的巨额罚款”的脑残法律，导致没打赢官司的Google直接封杀了从德国境内对YouTube Live Stream的访问。（幸好我没在德国上学，不然也要翻墙才能看直播了……）&lt;/p&gt;

&lt;p&gt;任何人都可以在YouTube Live Stream上&lt;a href=&quot;http://support.google.com/youtube/bin/static.py?hl=en&amp;amp;topic=2474327&amp;amp;guide=2474025&amp;amp;page=guide.cs&amp;amp;answer=2523404&quot;&gt;创建自己的live event&lt;/a&gt;，向全世界播放自己定制的视频节目。（只要你高兴，你也可以用它来发表“Remember, remember, the fifth of November”这样的演说，虽然很多人只是拿它来直播游戏比赛而已……）&lt;/p&gt;

&lt;h2&gt;Live Stream的工作机理&lt;/h2&gt;

&lt;h3&gt;流媒体协议和HTTP&lt;/h3&gt;

&lt;p&gt;在很久以前，网络上的&lt;a href=&quot;http://en.wikipedia.org/wiki/Streaming_media&quot;&gt;流媒体&lt;/a&gt;一般是通过专门的应用层协议来实现的。这样的协议主要包括：标准&lt;a href=&quot;http://en.wikipedia.org/wiki/Internet_protocol_suite&quot;&gt;TCP/IP&lt;/a&gt;应用层上的实时串流协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol&quot;&gt;RTSP（Real Time Streaming Protocol）&lt;/a&gt;和与之协同工作的实时传输协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Real-time_Transport_Protocol&quot;&gt;RTP（Real-time Transport Protocol）&lt;/a&gt;、实时传输控制协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Real-time_Transport_Control_Protocol&quot;&gt;RTCP（Real-time Transport Control Protocol）&lt;/a&gt;，微软提出的&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_Media_Server&quot;&gt;MMS（Microsoft Media Server）&lt;/a&gt;协议，以及Macromedia提出的&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol&quot;&gt;RTMP（Real Time Messaging Protocol）&lt;/a&gt;协议，等等。&lt;/p&gt;

&lt;p&gt;如今，由于Web在Internet技术中占据了绝对地位，由用户直接通过这些协议来访问流媒体的情况几乎已经没有了。现在的流媒体应用，无一例外是以浏览器所支持的HTTP协议为基础的。&lt;/p&gt;

&lt;h3&gt;1. 实时串流协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol&quot;&gt;RTSP（Real Time Streaming Protocol）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;作为标准TCP/IP协议栈应用层上的流媒体协议，RTSP是运行在RTP和RTCP这两个传输协议上的。&lt;/p&gt;

&lt;p&gt;RTP和RTCP又是基于传输层上的用户数据包协议&lt;a href=&quot;http://en.wikipedia.org/wiki/User_Datagram_Protocol&quot;&gt;UDP（User Datagram Protocol）&lt;/a&gt;而实现。媒体流被切分成小的数据包进行传输，这意味着它的实现简单而且高效，但是却没有相应的数据完整性确保和纠错机制，需要靠应用程序自身来验证接收数据的完整性。&lt;/p&gt;

&lt;p&gt;RTSP是一种比较古老的流媒体协议，今天的应用并不特别广泛。&lt;/p&gt;

&lt;h3&gt;2. 实时通信协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol&quot;&gt;RTMP（Real Time Messaging Protocol）&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;RTMP是不同于RTSP的另一种应用层流媒体协议，它最初由Macromedia制定并持有专利，用来实现客户端Flash播放器和远程服务器之间的媒体流传输。&lt;/p&gt;

&lt;p&gt;在Macromedia被Adobe收购之后，该协议的一部分规范已经公开了出来。&lt;/p&gt;

&lt;p&gt;不同于基于用户数据包协议UDP进行传输的RTP和RTCP，RTMP在传输层上基于“可信的”传输控制协议&lt;a href=&quot;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP（Transmission Control Protocol）&lt;/a&gt;。这意味着对于每一个字节的数据，协议都将确保其被完整正确地送达，但这同时也增加了超时、重试和重新传输的时间开销，为了保证流媒体播放速率的流畅，常常需要进行一定的缓冲。这造成了RTMP在实现上也较RTSP为复杂。&lt;/p&gt;

&lt;p&gt;前面已经说过，现在Web上的流媒体应用均是通过HTTP来进行访问的。因此就有了RTMP的一个基于HTTP隧道的衍生版本协议：&lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol#HTTP_tunneling&quot;&gt;RTMPT&lt;/a&gt;。在该协议中，数据被封装后藉由HTTP传输，并映射到服务器的80端口（标准HTTP端口）。在通讯时，隧道将会通过HTTP发送包含&lt;a href=&quot;http://en.wikipedia.org/wiki/Action_Message_Format&quot;&gt;AMF&lt;/a&gt;格式数据的POST请求，以此实现对流媒体的传输控制。&lt;/p&gt;

&lt;p&gt;最重要的实现RTMP协议的客户端软件，自然是地球人都知道的&lt;a href=&quot;http://en.wikipedia.org/wiki/Adobe_Flash_Player&quot;&gt;Adobe Flash Player&lt;/a&gt;。正是得益于这种机制（RTMP协议和AMF数据格式），我们才能够在基于HTTP的Web浏览器上通过Flash Player观看各种网站上的FLV视频、直播，而无需关心背后具体的流媒体协议是什么。&lt;/p&gt;

&lt;p&gt;为什么在这里着重介绍RTMP协议呢？原因很简单：RTMP正是YouTube Live Stream所使用的流媒体协议。我们在设置Live Stream的编码器的时候，实际上就是在把编码器所输出的流媒体源连接到Google的服务器，于是这样就实现了从任意媒体流到YouTube的播送。YouTube官方推荐的编码器主要有两种：Wirecast和Flash Media Live Encoder（FMLE），这两种编码器都支持RTMP协议的输出。&lt;/p&gt;

&lt;p&gt;简而言之，由于Flash在Web平台上的大行其道，目前RTMP的应用范围较广。它也正是YouTube Live Stream目前所支持的主要流媒体协议。&lt;/p&gt;

&lt;h3&gt;3. &lt;a href=&quot;http://en.wikipedia.org/wiki/Adaptive_bitrate_streaming&quot;&gt;自适应比特率流（Adaptive Bitrate Streaming）&lt;/a&gt;与&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_Live_Streaming&quot;&gt;HTTP Live Streaming&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;下面就要说到本文的重点，即不同于RTSP和RTMP的第三种形式的流媒体技术： &lt;a href=&quot;http://en.wikipedia.org/wiki/Adaptive_bitrate_streaming&quot;&gt;自适应比特率流（Adaptive Bitrate Streaming）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;自适应比特率流是纯基于HTTP的技术。它的优越之处不仅在于使用了通用的HTTP协议，更在于它可以根据用户的带宽和CPU处理能力实时地调整传输媒体流的编码和画质（比特率），这要求编码器具有将源媒体流内容同时编码成不同比特率的能力。从细节实现上来说，通过HTTP传输的媒体流提供了各种从低画质到高画质不同比特率的版本，每一个版本的媒体流都被切割成许多小片段（一个典型的片段长度一般在2秒到10秒之间）。媒体流的客户端将自动检测网络速度并下载与之相匹配的比特率流片段，一旦检测到下载速度高于当前媒体流片段的比特率，客户端会转而下载更高画质（比特率）的媒体流；反之，则下载较低画质（比特率）的媒体流。顾名思义，这就是所谓的“自适应比特率”了。&lt;/p&gt;

&lt;p&gt;下面的两张图很好地解释了自适应比特率流的工作原理：（摘自维基百科）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Adaptive_streaming_overview_daseddon_2011_07_28.png/660px-Adaptive_streaming_overview_daseddon_2011_07_28.png&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Adaptive_streaming_overview_bit_rates_2011_07_28.png/660px-Adaptive_streaming_overview_bit_rates_2011_07_28.png&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不难看出，自适应比特率流的好处是双向的：对于用户来说，总是能够在当前网络带宽和客户端环境的限制下观看到最高画质的视频；对于服务的提供者来说，通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;CDN（Content delivery network，内容分发网络）&lt;/a&gt;将来自源服务器的媒体流分发到边界服务器上进行缓存，用户的客户端直接通过HTTP协议访问这些边界服务器，大大地节约了服务器的软件许可证成本（因为这些边界服务器只需运行简单的HTTP服务器，用于视频编码的昂贵软件诸如Adobe Flash Media Streaming Server是部署在中心服务器上的）。&lt;/p&gt;

&lt;p&gt;把媒体流切分成小的数据包这一工作机理跟前面提到过的RTSP/RTP很相似，但和基于UDP进行传输的RTSP/RTP所不同的是，自适应比特率流使用HTTP，因此可以穿过任何允许HTTP数据通过的防火墙或代理。&lt;/p&gt;

&lt;p&gt;自适应比特率流这项技术由Move Networks公司持有专利，具体的实现有Adobe的Dynamic Streaming，Apple的&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_Live_Streaming&quot;&gt;HTTP Live Streaming&lt;/a&gt;和Microsoft的Smooth Streaming等。在此简单地介绍一下Apple的HTTP Live Streaming（简称HLS），我们将在后面看到它在YouTube Live Stream中的应用。&lt;/p&gt;

&lt;p&gt;Apple提出的&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_Live_Streaming&quot;&gt;HTTP Live Streaming&lt;/a&gt;，本身是QuickTime X和iOS的软件系统组成部分。它的实现基于自适应比特率流的工作原理，不再赘述。在每次媒体流会话开始的时候，一个&lt;a href=&quot;http://en.wikipedia.org/wiki/M3U&quot;&gt;M3U播放列表&lt;/a&gt;将被下载，它包含了不同比特率媒体流的元信息。这个M3U文件是至关重要的（我们将会在后面进行具体下载的时候遇到）。&lt;/p&gt;

&lt;h2&gt;抓取一个YouTube Live Stream！&lt;/h2&gt;

&lt;p&gt;说了这么多空泛的理论，现在，来实际尝试着下载一个YouTube的Live Stream视频吧。&lt;/p&gt;

&lt;h3&gt;下载基于RTMP协议的媒体流&lt;/h3&gt;

&lt;p&gt;前面提到过，YouTube Live Stream上的直播，大部分是基于RTMP协议实现的。原因之一在于，Adobe的Flash技术对Live媒体流的支持已经非常成熟（&lt;a href=&quot;http://www.adobe.com/products/flash-media-encoder.html&quot;&gt;Flash Media Live Encoder&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;另一方面，用脚本来实现YouTube上任意视频的下载非常简单，只需从视频信息页的元数据中解析出&lt;code&gt;url_encoded_fmt_stream_map&lt;/code&gt;的值，就得到了可直接用于下载的真实地址。（估计是YouTube也意识到了通过各种技术手段限制下载是徒劳无功的，只要浏览器能看到视频，就永远也无法阻止人们用Python伪装成浏览器的客户端来下载视频……）&lt;/p&gt;

&lt;p&gt;你可以用&lt;a href=&quot;http://pypi.python.org/pypi/you-get&quot;&gt;You-Get&lt;/a&gt;（使用Python 3）或者&lt;a href=&quot;http://rg3.github.com/youtube-dl/&quot;&gt;youtube-dl&lt;/a&gt;（使用Python 2）这些专门的下载工具来检测某个YouTube视频能否下载。嗯，这里当然还是用我自己的You-Get：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/mvD0T.jpg&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是一个YouTube Live Stream的直播页面。你可以看到，它和一般的YouTube视频几乎没什么差别，同样可以直接解析出真实的URL用于下载。不妨拿它和一个普通YouTube视频比较一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tNm9l.jpg&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有两点特别值得注意：1、Live Stream的媒体容器类型总是&lt;a href=&quot;http://en.wikipedia.org/wiki/Flash_Video&quot;&gt;FLV（video/x-flv）&lt;/a&gt;，这是由YouTube Live本身使用基于RTMP协议的Flash编码器决定的。而普通YouTube视频的容器可以是WebM、MP4、FLV或3GP这几种类型中的任意一种；2、Live Stream的大小几乎总是2048MB，这貌似是由Flash编码器总把一个特定时间段的视频编码成固定大小决定的（？）。&lt;/p&gt;

&lt;p&gt;如果所有的YouTube Live Stream都像文档中所说的那样确实&lt;a href=&quot;http://support.google.com/youtube/bin/static.py?hl=en&amp;amp;topic=2474327&amp;amp;guide=2474025&amp;amp;page=guide.cs&amp;amp;answer=1723080&quot;&gt;采用了基于RTMP协议的Flash流媒体&lt;/a&gt;进行编码，这意味着它们都可以直接解析出一个单一的URL来下载，那么这篇文章就没有存在的必要了。现在来看看我所遇到的另外一种情况。&lt;/p&gt;

&lt;h3&gt;下载基于HTTP Live Streaming的媒体流&lt;/h3&gt;

&lt;p&gt;（注意：在直播结束后这个视频的状态已经变成了private，现在不能再用它来做测试。包括下文提到的所有URL均已失效。）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;视频页面：&lt;a href=&quot;http://www.youtube.com/watch?v=UCW6kKNJ8cw&quot;&gt;http://www.youtube.com/watch?v=UCW6kKNJ8cw&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;get_video_info&lt;/code&gt;信息：&lt;a href=&quot;http://www.youtube.com/get_video_info?&amp;amp;video_id=UCW6kKNJ8cw&quot;&gt;http://www.youtube.com/get_video_info?&amp;amp;video_id=UCW6kKNJ8cw&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直播开始后，试了一下You-Get，发现不能像之前测试过的其它Live Stream一样直接下载。原因是在&lt;code&gt;get_video_info&lt;/code&gt;中解析到的&lt;code&gt;url_encoded_fmt_stream_map&lt;/code&gt;这一项是空的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;quot;url_encoded_fmt_stream_map&amp;quot;: &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;真正的视频地址在哪儿呢？注意到元数据中还有另外一项叫做&lt;code&gt;hlsvp&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;quot;hlsvp&amp;quot;: &amp;quot;http://www.youtube.com/api/manifest/hls_variant/upn/
DBd_eJivWi0/sparams/id,ip,ipbits,maudio,playlist_type,pmbypass
,expire/playlist_type/LIVE/maudio/1/ip/85.30.32.34/ipbits/8/si
gnature/CAC5E3A176930C924A125F7695730D89F519359C.CE80CCDF06F59
D6F2FFADEF88E6649C81E4BEDF4/sver/3/source/yt_live_broadcast/ex
pire/1346084679/key/yt1/pmbypass/yes/id/5025ba90a349f1cc/file/
index.m3u8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面说过，Apple的HTTP Live Streaming采取了自适应比特率流的工作方式，不同比特率媒体流的元信息会通过一个扩展M3U播放列表来进行传输。所以，不出意外，这是一个典型的HTTP Live Streaming实例。当然，这些流媒体协议之类的东西，我当时是不知道的。我所能知道的，就是这只是一个M3U播放列表而已……&lt;/p&gt;

&lt;p&gt;这个&lt;code&gt;index.m3u8&lt;/code&gt;其实是一个包含了更多播放列表的播放列表（注意&lt;code&gt;.m3u8&lt;/code&gt;是一个标准的扩展名，最后的“8”代表该M3U文件使用UTF-8编码）：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3621651.js?file=gistfile1.sh&quot;&gt;&lt;/script&gt;

&lt;p&gt;从注释就很容易看懂了，这里的每一个M3U播放列表对应每一种带宽限制对应的视频编码方式（这里一律都是视频编码&lt;a href=&quot;http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC&quot;&gt;H.264/MPEG-4 AVC&lt;/a&gt; + 音频编码&lt;a href=&quot;http://en.wikipedia.org/wiki/Advanced_Audio_Coding&quot;&gt;MPEG4-AAC&lt;/a&gt;）和分辨率（从72p到720p均有），用于客户端自动匹配当前带宽范围内最适宜的比特率媒体流。&lt;/p&gt;

&lt;p&gt;我们选择720p的媒体流，下载与之对应的M3U播放列表：&lt;/p&gt;

&lt;p&gt;http://www.youtube.com/api/manifest/hls&lt;em&gt;playlist/id/5025ba90a349f1cc/&lt;br&gt;
itag/95/source/yt&lt;/em&gt;live&lt;em&gt;broadcast/ratebypass/yes/cmbypass/yes/playlist&lt;br&gt;
_type/LIVE/maudio/1/pmbypass/yes/upn/Rwg0UFeZvSM/sver/3/ip/85.30.32.3&lt;br&gt;
4/ipbits/8/expire/1346084679/sparams/ip,ipbits,expire,id,itag,source,&lt;br&gt;
ratebypass,cmbypass,playlist&lt;/em&gt;type,maudio,pmbypass/signature/13694295F&lt;br&gt;
515B7A54C50A4E4CC74287D325506A7.7E5106F9BBC81C855CFB7DBB8E9EF1E2D35E5&lt;br&gt;
FCD/key/ck1/file/index.m3u8&lt;/p&gt;

&lt;p&gt;Linux下的播放器软件中，GNOME的Totem Movie Player是支持M3U播放列表的。用Totem直接打开这个&lt;code&gt;.m3u8&lt;/code&gt;文件，就可以和在浏览器中一样观看YouTube Live Stream的直播了。（不过因为是硬性选择了720p媒体流的M3U，我这鬼地方的网速不给力所以延迟比较明显……如果使用比特率自适应的&lt;code&gt;index.m3u8&lt;/code&gt;来播放，应该会比较流畅）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/kAcvM.jpg&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个M3U文件的内容包含以下5个长度为数秒的视频小片段的URL，用于客户端（浏览器或者Totem播放器）播放时缓冲：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3621846.js?file=gistfile1.sh&quot;&gt;&lt;/script&gt;

&lt;p&gt;隔几秒种再抓取一下这个文件，发现列表内容更新了：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3622157.js?file=gistfile1.sh&quot;&gt;&lt;/script&gt;

&lt;p&gt;显而易见，这些流媒体片段是一个连续的序列，视频片段URL的模式完全一致，只有&lt;code&gt;sq/&lt;/code&gt;后面的片段序号和最后的&lt;code&gt;dur&lt;/code&gt;参数存在差别（这个用于指定片段长度的参数并不是必须的）。&lt;/p&gt;

&lt;p&gt;事情到了这一步开始变得异常简单，我们可以直接通过遍历URL来下载这些片段了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;download_urls([&amp;#39;http://redirector.c.youtube.com/videoplayback\
/id/5025ba90a349f1cc/itag/95/source/yt_live_broadcast/sq/&amp;#39; + \
str(id) + &amp;#39;/file/seg.ts?ratebypass=yes&amp;amp;cmbypass=yes&amp;amp;playlist_\
type=LIVE&amp;amp;maudio=1&amp;amp;pmbypass=yes&amp;amp;upn=Rwg0UFeZvSM&amp;amp;sver=3&amp;amp;ip=85.\
30.32.34&amp;amp;ipbits=8&amp;amp;expire=1346084679&amp;amp;sparams=ip,ipbits,expire,\
id,itag,source,ratebypass,cmbypass,playlist_type,maudio,pmbyp\
ass&amp;amp;signature=13694295F515B7A54C50A4E4CC74287D325506A7.7E5106\
F9BBC81C855CFB7DBB8E9EF1E2D35E5FCD&amp;amp;key=ck1&amp;amp;live=1&amp;#39; \
for id in range(0, 3000)])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，这么做其实是有问题的。因为我们绕过了直播过程中流媒体的M3U渐进缓冲序列，直接试图一次批量下载全部可能的URL，这造成了可能我们在访问序列中的某个视频时，实际上这个资源当前还不存在（因为是直播嘛，你当然不可能在还没有播放到某个时间点的时候就穿越去下载未来的片段。。。）&lt;/p&gt;

&lt;p&gt;这可能会导致一个“404 Not Found”或者“Name or service not known”之类的错误。解决方案是不要直接裸下URL，而是通过重复抓取M3U播放列表、获取当前可用的视频片段来对其循序渐进地下载（模仿浏览器或播放器的工作方式）。M3U文件中的&lt;code&gt;EXT-X-MEDIA-SEQUENCE&lt;/code&gt;也就是播放列表中第一个片段（当前缓冲片段）的序号，该片段URL前注释里的&lt;code&gt;EXTINF&lt;/code&gt;或URL中的&lt;code&gt;dur&lt;/code&gt;参数指示了其长度，以这个长度进行延时后，重新抓取一次M3U列表就可以确保得到下一个视频片段。以此类推，可以抓取到所有的视频片段。这在Python中实现起来很容易，不再赘述。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/SzkHG.jpg&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以知道，这些视频片段的媒体容器是&lt;a href=&quot;http://en.wikipedia.org/wiki/MPEG_transport_stream&quot;&gt;MPEG-2 Transport Stream（video/mp2t）&lt;/a&gt;，所以文件的扩展名保存为&lt;code&gt;.ts&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/DOdYb.jpg&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;研究出这个Live Stream到底是怎么一回事以后，边看直播边调试脚本，赶在直播结束视频地址失效之前，我这的渣网速竟然能把主要部分都抓下来了（2000个片段，3.6GB，全长约3小时左右）。下一步要做的是……&lt;/p&gt;

&lt;h3&gt;合并视频片段&lt;/h3&gt;

&lt;p&gt;当然，一提到合并视频，就不能不提到处理多媒体文件的神器：&lt;a href=&quot;http://ffmpeg.org/&quot;&gt;FFmpeg&lt;/a&gt;。&lt;/p&gt;

&lt;del&gt;但是，我们其实有一个更简单的方法：直接把这些片段文件连接起来！&lt;/del&gt;

&lt;del&gt;用于网络流媒体传输的[MPEG-2 TS](http://en.wikipedia.org/wiki/MPEG_transport_stream)是极少数能够通过直接连接文件来实现合并的多媒体容器之一（其它类似的格式还有DV，MPEG-1，和用于介质存储的[MPEG-2 PS](http://en.wikipedia.org/wiki/MPEG_program_stream)）。所以，不用劳烦FFmpeg了，直接把这2000个片段按先后顺序连接起来即可。&lt;/del&gt;

&lt;del&gt;合并后的这个大的MPEG TS文件在Totem中的支持并不怎么好，时间轴好像有问题。在VLC中可以正常播放。当然，最好是stream成更适合保存的格式诸如MPEG PS或者MP4、FLV，至于用VLC，FFmpeg，还是随便其它哪个支持MPEG TS格式的转换工具就任意了。&lt;/del&gt;

&lt;p&gt;&lt;strong&gt;9月19日更正：&lt;/strong&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/MPEG_transport_stream&quot;&gt;MPEG-2 TS&lt;/a&gt;是不能够像&lt;a href=&quot;http://en.wikipedia.org/wiki/MPEG_program_stream&quot;&gt;MPEG-2 PS&lt;/a&gt;那样通过直接连接文件来实现合并的！&lt;/p&gt;

&lt;p&gt;暂时不想花时间研究MPEG-2 TS的容器规范。最靠谱的合并&lt;code&gt;.ts&lt;/code&gt;文件的方法，就只有借助于FFmpeg了。&lt;/p&gt;

&lt;p&gt;btw. 视频转码果然很烧GPU……(´д`;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3XfPT.jpg&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然也不一定非要把所有片段全部连接成一个文件，可以按照需求任意合并。不多说了，总之请多多支持正版……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/c3YWN.jpg&quot; width=&quot;80%&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结和未来工作&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于RTMP协议的YouTube直播视频可以用任何YouTube下载工具直接下载，问题解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于HTTP Live Streaming的YouTube直播视频的下载，初步打算放到下个版本的&lt;a href=&quot;http://www.soimort.org/you-get&quot;&gt;You-Get&lt;/a&gt;中实现。目前最大的问题是测试起来可能会有困难，毕竟我在YouTube上面只见过这么一个应用HTTP Live Streaming的特例（难道说是因为这种协议比较高端洋气?），绝大多数直播还是基于RTMP协议的。（YouTube的官方文档上也只提到了RTMP Flash Stream。个人推测这次直播也许有Google的特殊支持……）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>You-Get 0.2.1：Vimeo视频的下载</title>
        <link href="http://www.soimort.org/posts/120" />
        <updated>2012-09-02T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/120/you-get</id>
        <content type="html">&lt;p&gt;Python 3的YouTube/优酷视频下载工具&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;You-Get&lt;/a&gt;今天更新到0.2.1版了。&lt;/p&gt;

&lt;p&gt;新版本特性一览：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;添加了对&lt;a href=&quot;http://vimeo.com&quot;&gt;Vimeo&lt;/a&gt;的支持。&lt;/li&gt;
&lt;li&gt;添加了对youku-lixian所支持的其他所有视频网站的支持：

&lt;ul&gt;
&lt;li&gt;AcFun &lt;a href=&quot;http://www.acfun.tv&quot;&gt;http://www.acfun.tv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;bilibili &lt;a href=&quot;http://www.bilibili.tv&quot;&gt;http://www.bilibili.tv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CNTV &lt;a href=&quot;http://www.cntv.cn&quot;&gt;http://www.cntv.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;爱奇艺 &lt;a href=&quot;http://www.iqiyi.com&quot;&gt;http://www.iqiyi.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;酷6网 &lt;a href=&quot;http://www.ku6.com&quot;&gt;http://www.ku6.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PPTV &lt;a href=&quot;http://www.pptv.com&quot;&gt;http://www.pptv.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新浪视频 &lt;a href=&quot;http://video.sina.com.cn&quot;&gt;http://video.sina.com.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;搜狐视频 &lt;a href=&quot;http://tv.sohu.com&quot;&gt;http://tv.sohu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;56网 &lt;a href=&quot;http://www.56.com&quot;&gt;http://www.56.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;凤凰视频 &lt;a href=&quot;http://v.ifeng.com&quot;&gt;http://v.ifeng.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加上0.0.1版中原有的支持：

&lt;ul&gt;
&lt;li&gt;YouTube &lt;a href=&quot;http://www.youtube.com&quot;&gt;http://www.youtube.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;音悦台 &lt;a href=&quot;http://www.yinyuetai.com&quot;&gt;http://www.yinyuetai.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;优酷 &lt;a href=&quot;http://www.youku.com&quot;&gt;http://www.youku.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;土豆 &lt;a href=&quot;http://www.tudou.com&quot;&gt;http://www.tudou.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，You-Get已经实现了youku-lixian全部功能的同等替代。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;http://pypi.python.org/pypi&quot;&gt;芝士商店（Cheeseshop）&lt;/a&gt;上架啦！&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://pypi.python.org/pypi/you-get/&quot;&gt;You-Get&lt;/a&gt;已经在&lt;a href=&quot;http://pypi.python.org/pypi&quot;&gt;PyPI（Cheeseshop）&lt;/a&gt;上&lt;a href=&quot;http://pypi.python.org/pypi/you-get/&quot;&gt;注册&lt;/a&gt;。以后可以直接通过&lt;a href=&quot;http://www.pip-installer.org/&quot;&gt;Pip&lt;/a&gt;或者&lt;a href=&quot;http://pypi.python.org/pypi/setuptools&quot;&gt;EasyInstall&lt;/a&gt;来进行安装和升级：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ pip install you-get

$ you-get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ easy_install you-get

$ you-get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你仍然可以通过从Git获取源码的方式来使用You-Get：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/you-get.git

$ cd you-get/
$ ./you-get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以下命令将You-Get安装到系统路径（与Pip安装等效）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ make install

$ you-get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;命令行的使用&lt;/h2&gt;

&lt;p&gt;请参考&lt;a href=&quot;https://github.com/soimort/you-get/blob/master/README.md#you-get---%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E&quot;&gt;中文说明&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;Python APIs的使用&lt;/h2&gt;

&lt;p&gt;这里有一个&lt;a href=&quot;https://github.com/soimort/you-get/blob/master/README.md#examples-for-developers&quot;&gt;简单的示例&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;技术细节：Vimeo视频的下载 / HTTP headers的正确伪造方法（误）&lt;/h2&gt;

&lt;p&gt;简略地介绍一下如何使用Python 3下载Vimeo视频的实现细节，感兴趣的可以看。&lt;/p&gt;

&lt;p&gt;Vimeo的视频地址格式主要有类似如下两种（以任意视频为例）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://vimeo.com/48070853&quot;&gt;http://vimeo.com/48070853&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://vimeo.com/channels/staffpicks/48070853&quot;&gt;http://vimeo.com/channels/staffpicks/48070853&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;无论哪种URL，最后的一串数字就是Vimeo视频的ID。用一行正则表达式匹配获取这个ID（令视频地址为变量&lt;code&gt;url&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;id = re.search(r&amp;#39;http://\w*vimeo.com[/\w]*/(\d+)$&amp;#39;, url).group(1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在相应的HTML页面中（令HTML内容存放于变量&lt;code&gt;html&lt;/code&gt;），我们需要抓取三个重要的JSON信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;signature = re.search(r&amp;#39;&amp;quot;signature&amp;quot;:&amp;quot;([^&amp;quot;]+)&amp;quot;&amp;#39;, html).group(1)
timestamp = re.search(r&amp;#39;&amp;quot;timestamp&amp;quot;:([^,]+)&amp;#39;, html).group(1)
title = re.search(r&amp;#39;&amp;quot;title&amp;quot;:&amp;quot;([^&amp;quot;]+)&amp;quot;&amp;#39;, html).group(1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;title&lt;/code&gt;即为视频的标题。其他两个变量值&lt;code&gt;signature&lt;/code&gt;和&lt;code&gt;timestamp&lt;/code&gt;用来和&lt;code&gt;id&lt;/code&gt;一同构成视频的真实地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;url = &amp;#39;http://player.vimeo.com/play_redirect?clip_id=%s&amp;amp;sig=%s&amp;amp;time=%s&amp;#39; \
% (id, signature, timestamp)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在这里得到的&lt;code&gt;signature&lt;/code&gt;是&lt;code&gt;80e1d7a8ee1e7fecce971566cbe94a09&lt;/code&gt;，&lt;code&gt;timestamp&lt;/code&gt;是&lt;code&gt;1346545369&lt;/code&gt;，加上视频的&lt;code&gt;id&lt;/code&gt;：&lt;code&gt;48070853&lt;/code&gt;，合成的&lt;code&gt;url&lt;/code&gt;是：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://player.vimeo.com/play_redirect?clip_id=48070853&amp;amp;sig=80e1d7a8ee1e7fecce971566cbe94a09&amp;amp;time=1346545369&quot;&gt;http://player.vimeo.com/play_redirect?clip_id=48070853&amp;amp;sig=80e1d7a8ee1e7fecce971566cbe94a09&amp;amp;time=1346545369&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是，这个地址根本就是无效的（既无法用Python进行下一步请求，也不能在浏览器中打开）。原因是，我们直接使用了Python默认的request header来获取HTML内容，而Vimeo采取的下载防范措施禁止我们这么做。所以，直接通过这种方式抓取的视频URL被封禁掉了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/znGur.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决的方法也很简单。子曰：使用伪造headers的人是邪恶的。现在我们就来用这种邪恶的手段抓取Vimeo上的视频地址，让服务器误以为我们的客户端是正常的浏览器，而不是某个不怀好意的Python脚本。&lt;/p&gt;

&lt;p&gt;先找到浏览器所使用的request headers：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ya6BS.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将其原封不动地照搬到Python里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;fake_headers = {
    &amp;#39;Accept&amp;#39;: &amp;#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&amp;#39;,
    &amp;#39;Accept-Charset&amp;#39;: &amp;#39;UTF-8,*;q=0.5&amp;#39;,
    &amp;#39;Accept-Encoding&amp;#39;: &amp;#39;gzip,deflate,sdch&amp;#39;,
    &amp;#39;Accept-Language&amp;#39;: &amp;#39;en-US,en;q=0.8&amp;#39;,
    &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0 (X11; Linux x86_64) \
AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.57 Safari/537.1&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在以后凡是向Vimeo发出HTTP请求时，我们只需发送这个假的&lt;code&gt;fake_headers&lt;/code&gt;就好了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;response = request.urlopen(request.Request(url, headers = fake_headers), None)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vimeo是我目前见到的唯一一个会根据浏览器的headers来封锁下载的网站。不过如你所见，对于真心想下载视频的人来说，这招基本上没用。。。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>You-Get：一个YouTube/优酷视频下载工具</title>
        <link href="http://www.soimort.org/posts/119" />
        <updated>2012-08-21T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/119/you-get</id>
        <content type="html">&lt;p&gt;以前一直在用youtube-dl下载YouTube的视频，用youku-lixian下载优酷视频，&lt;br&gt;
最近嫌调用两个独立的脚本太麻烦了，遂搞了一个同时支持YouTube和优酷的下载工具（目测是第一个）。&lt;/p&gt;

&lt;p&gt;先总结一下现有工具的优缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;youtube-dl只支持YouTube等国外网站。&lt;/li&gt;
&lt;li&gt;youtube-dl允许断点续传。&lt;/li&gt;
&lt;li&gt;youtube-dl功能超多，但是很多根本用不到。&lt;/li&gt;
&lt;li&gt;youku-lixian只支持优酷等国内网站。&lt;/li&gt;
&lt;li&gt;youku-lixian无断点续传功能。&lt;/li&gt;
&lt;li&gt;youku-lixian功能有限，但是基本够用。&lt;/li&gt;
&lt;li&gt;两者都使用Python 2。（Arch用户表示不太喜欢这个设定）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;You-Get：一个Python 3的YouTube/优酷视频下载工具&lt;/h2&gt;

&lt;p&gt;GitHub传送门：&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;https://github.com/soimort/you-get&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该脚本以iambus的&lt;a href=&quot;https://github.com/iambus/youku-lixian&quot;&gt;优酷下载脚本youku-lixian&lt;/a&gt;为基础，YouTube视频地址的抓取算法参考了&lt;a href=&quot;https://github.com/davidgaya/youtube_rb&quot;&gt;短小精悍的Ruby脚本youtube_rb&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加了对YouTube和Vimeo的支持&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现了断点续传&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑到某国的特殊国情，允许进行HTTP代理设置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全部代码使用Python 3改写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前根据本人需求，实现了对以下视频站点的支持，以后会继续增加（・∀・）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;YouTube &lt;a href=&quot;http://www.youtube.com&quot;&gt;http://www.youtube.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;音悦台 &lt;a href=&quot;http://www.yinyuetai.com&quot;&gt;http://www.yinyuetai.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;优酷 &lt;a href=&quot;http://www.youku.com&quot;&gt;http://www.youku.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;土豆 &lt;a href=&quot;http://www.tudou.com&quot;&gt;http://www.tudou.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（0.2版 添加支持）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vimeo &lt;a href=&quot;http://vimeo.com&quot;&gt;http://vimeo.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;AcFun &lt;a href=&quot;http://www.acfun.tv&quot;&gt;http://www.acfun.tv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;bilibili &lt;a href=&quot;http://www.bilibili.tv&quot;&gt;http://www.bilibili.tv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CNTV &lt;a href=&quot;http://www.cntv.cn&quot;&gt;http://www.cntv.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;爱奇艺 &lt;a href=&quot;http://www.iqiyi.com&quot;&gt;http://www.iqiyi.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;酷6网 &lt;a href=&quot;http://www.ku6.com&quot;&gt;http://www.ku6.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PPTV &lt;a href=&quot;http://www.pptv.com&quot;&gt;http://www.pptv.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新浪视频 &lt;a href=&quot;http://video.sina.com.cn&quot;&gt;http://video.sina.com.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;搜狐视频 &lt;a href=&quot;http://tv.sohu.com&quot;&gt;http://tv.sohu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;56网 &lt;a href=&quot;http://www.56.com&quot;&gt;http://www.56.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（0.2.1版 添加支持）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;凤凰视频 &lt;a href=&quot;http://v.ifeng.com&quot;&gt;http://v.ifeng.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（0.2.5版 添加支持）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dailymotion &lt;a href=&quot;http://dailymotion.com&quot;&gt;http://dailymotion.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（0.2.10版 添加支持）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Google+ &lt;a href=&quot;http://plus.google.com&quot;&gt;http://plus.google.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;安装方式&lt;/h3&gt;

&lt;h4&gt;1. 直接下载：&lt;a href=&quot;https://github.com/soimort/you-get/zipball/master&quot;&gt;https://github.com/soimort/you-get/zipball/master&lt;/a&gt;&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ unzip soimort-you-get-*.zip 
$ cd soimort-you-get-*/

$ ./you-get --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2. 从Git安装&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ git clone git://github.com/soimort/you-get.git
$ cd you-get/

$ ./you-get --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 通过&lt;a href=&quot;http://www.pip-installer.org/&quot;&gt;Pip&lt;/a&gt;安装&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ pip install you-get

$ you-get --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4. 通过&lt;a href=&quot;http://pypi.python.org/pypi/setuptools&quot;&gt;EasyInstall&lt;/a&gt;安装&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ easy_install you-get

$ you-get --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/kZi4s.png&quot; alt=&quot;Screenshot&quot;&gt;&lt;/p&gt;

&lt;h3&gt;如何下载视频&lt;/h3&gt;

&lt;p&gt;（以下命令均以Linux shell为例……Windows用户请自行脑补正确的命令格式）&lt;/p&gt;

&lt;p&gt;显示视频信息，但不进行下载（&lt;code&gt;-i&lt;/code&gt;或&lt;code&gt;--info&lt;/code&gt;选项）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -i http://www.yinyuetai.com/video/463772
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载视频：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get http://www.yinyuetai.com/video/463772
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载多个视频：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get http://www.yinyuetai.com/video/463772 http://www.yinyuetai.com/video/471500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若当前目录下已有与视频标题同名的文件，下载时会自动跳过。若有同名的&lt;code&gt;.download&lt;/code&gt;临时文件，程序会从上次中断处开始下载。
如要强制重新下载该视频，可使用&lt;code&gt;-f&lt;/code&gt;（&lt;code&gt;--force&lt;/code&gt;）选项：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -f http://www.yinyuetai.com/video/463772
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;（&lt;code&gt;--playlist&lt;/code&gt;）选项用于下载播放列表（只对某些网站适用）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -l http://www.youku.com/playlist_show/id_5344313.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注：从0.1.3以后的版本起，&lt;code&gt;-l&lt;/code&gt;选项不再必须。You-Get可以自动识别并处理播放列表的下载。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定视频文件的下载目录：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -o ~/Downloads http://www.yinyuetai.com/video/463772
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示详细帮助：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;如何设置代理&lt;/h3&gt;

&lt;p&gt;默认情况下，Python自动使用系统的代理配置。可以通过环境变量&lt;code&gt;http_proxy&lt;/code&gt;来设置系统的HTTP代理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt;（&lt;code&gt;--http-proxy&lt;/code&gt;）选项用于手动指定You-Get所使用的HTTP代理。例如：GoAgent的代理服务器是&lt;code&gt;http://127.0.0.1:8087&lt;/code&gt;，则使用该代理下载某YouTube视频的命令是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get -x 127.0.0.1:8087 http://www.youtube.com/watch?v=KbtO_Ayjw0M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows下的自由门等翻墙软件会自动设置系统全局代理，因此无需指定HTTP代理即可下载YouTube视频：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get http://www.youtube.com/watch?v=KbtO_Ayjw0M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不希望程序在下载过程中使用任何代理（包括系统的代理配置），可以显式地指定&lt;code&gt;--no-proxy&lt;/code&gt;选项：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./you-get --no-proxy http://v.youku.com/v_show/id_XMjI0ODc1NTc2.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;断点续传&lt;/h3&gt;

&lt;p&gt;下载未完成时意外中止（因为网络中断或程序被强行终止等），在目标路径中会有一个扩展名为&lt;code&gt;.download&lt;/code&gt;的临时文件。&lt;/p&gt;

&lt;p&gt;下次运行只要在目标路径中找到相应的&lt;code&gt;.download&lt;/code&gt;临时文件，程序会自动从中断处继续下载。（除非指定了&lt;code&gt;-f&lt;/code&gt;选项）&lt;/p&gt;

&lt;h3&gt;许可证&lt;/h3&gt;

&lt;p&gt;源码在MIT License下发布。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>代码页即地狱</title>
        <link href="http://www.soimort.org/posts/118" />
        <updated>2012-08-19T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/118/encoding</id>
        <content type="html">&lt;p&gt;最近，我在把一个Python 2的视频下载工具&lt;a href=&quot;https://github.com/iambus/youku-lixian&quot;&gt;youku-lixian&lt;/a&gt;改写成Python 3，并添加了自己需要的YouTube支持。&lt;/p&gt;

&lt;p&gt;在Linux下，事情进行得很顺利：所有的东西都用&lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;进行编码。Python 3里的str类型从2.x版本的ASCII字符串变成了Unicode字符串；我移除了原来代码里关于本地编码类型的判断处理部分。程序从抓取的页面上解析出视频标题部分的Unicode字符串，直接print()显示到标准输出，一切看起来很和谐。&lt;/p&gt;

&lt;p&gt;假定我抓取的这个视频标题是中文，叫做“你好，世界”。众所周知，得益于Python良好的Unicode支持，输出它只需要简单的一句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;print(&amp;#39;你好，世界&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;a href=&quot;http://en.windows7sins.org/&quot;&gt;天杀的Windows 7&lt;/a&gt;下测试这个程序时，麻烦就出现了。如果你想知道我为什么这么说，请继续看下去。&lt;/p&gt;

&lt;h1&gt;我所不了解的Windows&lt;/h1&gt;

&lt;p&gt;去年从学校拿到这台Dell笔记本时，Windows 7自然是预装在上面的。&lt;/p&gt;

&lt;p&gt;系统语言已经设置成了英语。很快，我对瑞典语键盘的布局感到极其不适应：它的标点符号位置与英语键盘布局有很大区别，分号、冒号、单引号双引号、斜杠反斜杠这些程序员司空见惯的符号，和美式英语键盘完全不同。于是，我把键盘布局换回了习惯的英语键盘，顺便把控制面板的“区域”选项也一概从瑞典换到了英语/美国。&lt;/p&gt;

&lt;p&gt;在很长一段时间里，除了界面是英文以外，它看起来和以往用的中文系统没什么区别：有默认的中文字体，输入法可以添加中文的。我平时用它做的，只有：上网，挂迅雷，拿IE登网银，玩Mirror&amp;#39;s Edge，几件事而已。&lt;/p&gt;

&lt;p&gt;文件系统是Unicode编码的，Web浏览器是支持Unicode的，偶尔用的文本编辑器也是一律设置成UTF-8的。而且我们知道，从Windows 2000起，Windows的内码实现是使用&lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16LE&lt;/a&gt;的。几乎让人快要忘了还有代码页这么一回事。&lt;/p&gt;

&lt;p&gt;可是，如果要在英文Windows系统的命令提示符里执行这个简单的输出Unicode文本的程序：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

if __name__ == &amp;#39;__main__&amp;#39;:
    print(&amp;#39;你好，世界&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python就会跳出来一段错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;  File &amp;quot;c:\Python32\lib\encodings\cp437.py&amp;quot;, line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_map)[0]
UnicodeEncodeError: &amp;#39;charmap&amp;#39; codec can&amp;#39;t encode characters in position 0-1:
character maps to &amp;lt;undefined&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;难道Python 3不是支持Unicode的吗？难道它不是跨平台的吗？&lt;/h1&gt;

&lt;p&gt;第一个问题，基本上是对的，Python 3确实支持Unicode，这种支持体现在它把所有的str字符串都作为Unicode处理这件事情上。&lt;/p&gt;

&lt;p&gt;第二个问题，不完全，跨平台的可移植性是有条件的。Python本身是支持Unicode，但是如果遇上了非Unicode的古董环境，那就一点办法也没有。&lt;/p&gt;

&lt;p&gt;什么叫“非Unicode的古董环境”呢……不，我说的不是DOS。这个东西，竟然就是Windows上的&lt;code&gt;cmd.exe&lt;/code&gt;，每个人或多或少都用过的命令行环境。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cmd.exe&lt;/code&gt;，从MinGW到Python，基本上每个Windows下需要接触命令行的开发人员都躲不过去的东西，微软怎么就不能把它做好些？窗口大小不能随心所欲改也就算了，不能全屏显示也就算了，字体大小屏幕缓冲设置各种限制也就算了，鼠标拖拽不方便也就算了，命令行补全补不全也就算了，你好歹能把默认编码改成用Unicode吧？一个破窗口从二十年前的3.x时代沿用到今天的Windows 7，从依赖DOS的&lt;code&gt;command.com&lt;/code&gt;到独立的&lt;code&gt;cmd.exe&lt;/code&gt;，尼玛这么多年了，也没见功能上有什么实质的改进，是不是在微软眼里所有的程序员都在拿个白花花的IDE“做你的code”、不需要命令行了？&lt;/p&gt;

&lt;p&gt;（在Windows已经完全使用UTF-16作为内码实现的今天，&lt;code&gt;cmd.exe&lt;/code&gt;仍然在使用系统默认的代码页，我所能想到的唯一理由就是为了保持和以前的non-Unicode程序兼容——不过这理由也太弱了吧）&lt;/p&gt;

&lt;p&gt;微软有功夫把Windows 8的界面做得花里胡哨，不过看样子他们是压根不打算把&lt;code&gt;cmd.exe&lt;/code&gt;这个东西做得更好用些。不继续喷下去了，说处理问题的经过：&lt;/p&gt;

&lt;p&gt;前面Python的错误信息里提到了个文件&lt;code&gt;cp437.py&lt;/code&gt;。既然是cp437什么的，那就一定是Python在试图把Unicode字符串转换成用于输出的437代码页（英语/美国）时出了错。&lt;/p&gt;

&lt;p&gt;为什么Python要把一个好端端的Unicode字符串转换成cp437呢？这很容易想通，因为程序是在&lt;code&gt;cmd.exe&lt;/code&gt;这个终端环境下执行的。在我的英文系统上，它的活动代码页是437（英语/美国）。从代码中的Unicode字符串到输出cp437的这一步转换，是由Python解释器来实现的，所以会由Python抛出一个错误，而不是直接在控制台输出一堆乱码。&lt;/p&gt;

&lt;p&gt;首先想到的解决方案，自然是改变当前&lt;code&gt;cmd.exe&lt;/code&gt;的活动代码页到UTF-8 Unicode：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;chcp.com 65001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不幸的是，这导致Python解释器直接崩溃了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Fatal Python error: Py_Initialize: can&amp;#39;t initialize sys standard streams
LookupError: unknown encoding: cp65001

This application has requested the Runtime to terminate it in an unusual way.
Please contact the application&amp;#39;s support team for more information.

LookupError: unknown encoding: cp65001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搜了一下才发现，Python 3.2目前&lt;a href=&quot;http://bugs.python.org/issue13216&quot;&gt;并不支持Windows上面的cp65001&lt;/a&gt;。话说65001代码页不就是UTF-8嘛（囧囧囧囧囧）&lt;/p&gt;

&lt;p&gt;与其说是不支持，不如说是bug更合适些。因为执行之后Windows就跳出一个警告框说“&lt;code&gt;python.exe&lt;/code&gt;已经停止响应”了……&lt;/p&gt;

&lt;p&gt;于是，试着改变代码页到GBK：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;chcp.com 936
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果却是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Invalid code page
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows声称这是一个无效的代码页。为什么？&lt;/p&gt;

&lt;h1&gt;编码是什么&lt;/h1&gt;

&lt;p&gt;好了，暂且忘记&lt;code&gt;cmd.exe&lt;/code&gt;诸如此类令人不愉快的东西，在&lt;a href=&quot;http://en.wikipedia.org/wiki/IDLE_(Python)&quot;&gt;IDLE&lt;/a&gt;上试一试。&lt;/p&gt;

&lt;p&gt;我不知道有多少Linux程序员写Python的时候会用到IDLE。对于这些习惯了终端+文本编辑器的用户来说，IDLE看起来是个无关紧要的附属品，也许它的定位只是用来帮助初学者入门的一个开发环境？&lt;/p&gt;

&lt;p&gt;不过，容易被人们忽略的一点是：IDLE本身是个跨平台的环境，这意味着它可以无条件支持Unicode（只要系统上有相应的字体），用它来解释执行程序不必受制于特定终端环境的拘束。这一点在Windows上很重要，因为&lt;code&gt;cmd.exe&lt;/code&gt;这玩意实在是太差劲了，所以估计很多人在Windows下交互执行Python的时候还是会选择IDLE的。&lt;/p&gt;

&lt;p&gt;进入IDLE。我们可能要关心一下这个Windows系统下面的默认编码方式是什么，Python 3里面有两个函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; sys.stdout.encoding; locale.getpreferredencoding()
&amp;#39;cp1252&amp;#39;
&amp;#39;cp1252&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个&lt;code&gt;sys.stdout.encoding&lt;/code&gt;是指标准输出的编码，第二个&lt;code&gt;locale.getpreferredencoding&lt;/code&gt;则是系统本地化设置的编码。两者是有区别的。现在我们看到，它们在当前环境下是相同的，都是默认的&lt;a href=&quot;http://en.wikipedia.org/wiki/Windows-1252&quot;&gt;cp1252&lt;/a&gt;，也就是传说中的“ANSI”代码页。&lt;/p&gt;

&lt;p&gt;恩，我们已经知道IDLE是一个完全跨平台的环境，所以在IDLE上输出Unicode字符可以得到和Linux环境下同样和谐的结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; print(&amp;#39;你好，世界&amp;#39;)
你好，世界
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便看看“你好，世界”的UTF-8编码和GBK是什么，如果强制用其他编码方式来解码又会得到怎样的结果（后面也许会用到）。可以看到，5个全角字符在UTF-8编码下是15个字节，每个字符占3 bytes；在GBK编码下是10个字节，每个字符占2 bytes。&lt;/p&gt;

&lt;p&gt;虽然没有什么实际的意义，不过还是可以注意到：UTF-8编码的字符是无法用GBK解码的，哪怕是乱码有时候也不行，因为可能会出现奇数字节长度，这在GBK下不合法；反之GBK编码字符亦无法用UTF-8解码，因为有无效字符值的存在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/F9igk.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;借助IDLE看到了“你好，世界”各种编码的详细情况。现在我们可以回到&lt;code&gt;cmd.exe&lt;/code&gt;里面看一看下面这段程序的运行结果了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys, locale

if __name__ == &amp;#39;__main__&amp;#39;:
    print(sys.stdout.encoding, locale.getpreferredencoding())

    try:
        print(&amp;#39;你好，世界&amp;#39;)
    except Exception as err:
        print(str(err))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先通过&lt;code&gt;chcp&lt;/code&gt;确认，&lt;code&gt;cmd.exe&lt;/code&gt;的当前活动代码页是437（英语/美国），而非IDLE里的1252（ANSI）。这是由于我的Windows里对non-Unicode程序的区域设置是“英语/美国”的缘故。&lt;/p&gt;

&lt;p&gt;程序运行的结果是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;cp437 cp1252
&amp;#39;charmap&amp;#39; codec can&amp;#39;t encode characters in position 0-4: 
character maps to &amp;lt;undefined&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到&lt;code&gt;sys.stdout.encoding&lt;/code&gt;实际上就是当前环境下活动代码页的值。&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt;没变，仍然是系统默认的cp1252。&lt;/p&gt;

&lt;p&gt;之后抛出的异常是在我们预料之中的，正如此前一样，Python尝试把Unicode字符串转换成cmd终端下的cp437代码页编码。而中文字符本来就是没有对应的cp437编码的，所以Python报错。&lt;/p&gt;

&lt;p&gt;Google一下&lt;code&gt;&amp;#39;charmap&amp;#39; codec can&amp;#39;t encode characters in position 0-4: character maps to &amp;lt;undefined&amp;gt;&lt;/code&gt;这个错误。在Stack Overflow上，有人提到了解决的方法：设置一个叫做&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;的环境变量。&lt;/p&gt;

&lt;h1&gt;PYTHONIOENCODING环境变量&lt;/h1&gt;

&lt;p&gt;所谓的&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;，既可以作为环境变量存在，也可以作为Python的命令行参数传递。它用于指定Python程序标准输入输出（stdin/stdout/stderr）的编码。（注意这个编码不是指源代码的编码，和Python程序开头常见的&lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt;是两码事）&lt;/p&gt;

&lt;h3&gt;在没有这个环境变量时&lt;/h3&gt;

&lt;p&gt;如前面所述，Python会试图把内部Unicode编码的字符串转化成当前执行程序的终端环境下所使用的编码方式（&lt;code&gt;sys.stdout.encoding&lt;/code&gt;）后输出。对于当前代码页437的&lt;code&gt;cmd.exe&lt;/code&gt;来说，把只含有英文数字的字符串转成cp437编码没有任何问题；但是一旦遇上了中文字符，英语/美国的437代码页里必然是找不到对应的编码的，于是Python就会报错。&lt;/p&gt;

&lt;p&gt;如果当前代码页设成65001，Python 3.2会崩溃，这是本身实现上的&lt;a href=&quot;http://bugs.python.org/issue13216&quot;&gt;问题&lt;/a&gt;。在最新的Python 3.3 beta中已经&lt;a href=&quot;http://docs.python.org/dev/whatsnew/3.3.html#codecs&quot;&gt;增加了对cp65001的支持&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;在设置了这个环境变量时&lt;/h3&gt;

&lt;p&gt;通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;set PYTHONIOENCODING=utf-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或（PowerShell下）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$env:PYTHONIOENCODING = &amp;quot;utf-8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;指定的编码方式会覆盖原来的&lt;code&gt;sys.stdout.encoding&lt;/code&gt;。如果将&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;设置为utf-8，那么Python在输出Unicode字符串的时候就会以UTF-8输出，相当于什么也不转换。&lt;/p&gt;

&lt;p&gt;再次执行该Python程序，这一次Python不再尝试自动转换Unicode的中文字符到cp437中的对应字符，程序成功运行，&lt;code&gt;sys.stdout.encoding&lt;/code&gt;变成了utf-8，字符串输出则是乱码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;utf-8 cp1252
Σ╜áσÑ╜∩╝îΣ╕ûτòî
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与我们之前在IDLE中将UTF-8编码的文本强制用cp437解码得到的结果是完全相同的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt;&amp;gt;&amp;gt; print(bytes(&amp;#39;你好，世界&amp;#39;, &amp;#39;utf-8&amp;#39;).decode(&amp;#39;cp437&amp;#39;))
Σ╜áσÑ╜∩╝îΣ╕ûτòî
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python直接把UTF-8编码的字符串输出到了cp437代码页的终端，相当于强制用cp437来解码UTF-8文本，产生了无意义的乱码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Y7OZ2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用文本编辑器写一个内容是“你好，世界”的文件，以UTF-8编码保存。在&lt;code&gt;cmd.exe&lt;/code&gt;下通过type显示，结果和上面是相同的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/8FdUd.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;cmd.exe和PowerShell ISE的微妙之处对比&lt;/h1&gt;

&lt;p&gt;在当前区域设置（英语/美国）下，两者执行&lt;code&gt;chcp.com&lt;/code&gt;显示的当前活动代码页都是437。&lt;/p&gt;

&lt;p&gt;只有cmd下Python的&lt;code&gt;sys.stdout.encoding&lt;/code&gt;默认是cp437（与活动代码页相同）；PowerShell ISE下&lt;code&gt;sys.stdout.encoding&lt;/code&gt;则是cp1252（ANSI）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;locale.getpreferredencoding&lt;/code&gt;永远是系统本身默认的cp1252，这是一个系统全局值。&lt;/p&gt;

&lt;p&gt;cmd无法输入中文，不能正确显示文件系统中的中文文件名；PowerShell ISE能够输入中文，能显示中文文件名。&lt;/p&gt;

&lt;p&gt;在缺少936代码页的情况下，两者都不能够通过执行脚本或type文件内容正确显示中文字符（无论是GBK还是UTF-8），会产生乱码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/7zYgy.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;为什么Windows会缺少GBK代码页？&lt;/h1&gt;

&lt;p&gt;回到最初的那个问题上来，为什么执行&lt;code&gt;chcp.com 936&lt;/code&gt;不能切换到GBK代码页？为什么&lt;code&gt;cmd.exe&lt;/code&gt;和PowerShell里不能正常显示中文？&lt;/p&gt;

&lt;p&gt;这个问题让我百思不得其解。花了几个小时找到了原因，简而言之：因为Windows的“区域和语言”设置不对。&lt;/p&gt;

&lt;p&gt;“Language for non-Unicode programs”这个选项不是简体中文，所以就不能用GBK，手动&lt;code&gt;chcp.com&lt;/code&gt;也会告诉你该代码页无效。所以必须要在控制面板里设置成简体中文，重启后才能生效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/0Jx06.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好吧，问题来了，为什么这里只能单选？如果我既想使用936（GBK）编码的应用程序，又想使用932（日语）编码的应用程序，难道每次都要在这里改完后再重启吗？为什么他们不能给一个详细的代码页列表让用户多选、需要时可以动态加载？&lt;/p&gt;

&lt;p&gt;Windows设计的龌龊之处就在这里。如果你不去设置system locale为中文并重启，所有non-Unicode程序里的中文字符集都是不会出现的，只能显示成一个方框，比如&lt;code&gt;cmd.exe&lt;/code&gt;里：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/KUdvc.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有Vim里（&lt;code&gt;set fileencodings=utf-8,gbk&lt;/code&gt;），GBK编码的文本和UTF-8编码的文本都一样无法显示。（按理说Vim应该不能算non-Unicode程序吧……谁知道呢？！）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Vth7D.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;改过&amp;quot;Language for non-Unicode programs”为中文并且重启系统之后，Vim立即显示正常：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LevWq.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再进&lt;code&gt;cmd.exe&lt;/code&gt;，默认活动代码页936。这段Python程序终于也能正确输出了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/7L01U.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也许Windows这种蛋疼的设计是因为考虑到英文用户一般不会需要多余的Unicode和代码页字符集，这么做可以节省系统启动时间？谁知道呢，Windows用户不是最喜欢拿所谓的“启动时间快”作为衡量系统性能的指标了吗……&lt;/p&gt;

&lt;p&gt;切换到cp65001（UTF-8 Unicode），&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;设置成utf-8，按理来说这种方式不应该出问题，但是这输出怎么看都不像是正常（如下图所示）。不想深究到底为什么了，总之Windows下面东西的复杂程度以我这种智商是永远都不能够理解的……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/x61ih.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Python除了标准输入输出，还有……&lt;/h1&gt;

&lt;h3&gt;文件名&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;open(&amp;#39;文件名测试&amp;#39;, &amp;#39;w&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python中对文件系统的操作基本上是不受默认编码影响的，只要&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;的结果是utf-8（现代Linux）或者mbcs（现代Windows NT系统上）。两者本质上都是Unicode编码。&lt;/p&gt;

&lt;h3&gt;文件输入输出&lt;/h3&gt;

&lt;p&gt;文件读写不属于标准I/O，因此和环境变量&lt;code&gt;PYTHONIOENCODING&lt;/code&gt;无关。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;for c in [&amp;#39;utf-8&amp;#39;, &amp;#39;gbk&amp;#39;]:
    with open(&amp;#39;test_%s.txt&amp;#39; % c, &amp;#39;w&amp;#39;, encoding=c) as output:
        try:
            output.write(&amp;#39;你好，世界\n&amp;#39;)
        except Exception as err:
            print(&amp;#39;\nWriting to file using %s:\n&amp;#39; % c, str(err))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于在open()中显式指定了中文编码方式（&lt;code&gt;encoding=&amp;#39;utf-8&amp;#39;&lt;/code&gt;或&lt;code&gt;encoding=&amp;#39;gbk&amp;#39;&lt;/code&gt;），输出“你好，世界”这样的中文文本在任何平台上都应该能够得到正确的结果。&lt;/p&gt;

&lt;p&gt;然而对于：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;with open(&amp;#39;test_default.txt&amp;#39;, &amp;#39;w&amp;#39;) as output:
    try:
        output.write(&amp;#39;你好，世界\n&amp;#39;)
    except Exception as err:
        print(&amp;#39;\nWriting to file using default encoding:\n&amp;#39;, str(err))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于没有指定编码方式，Python会自动使用系统默认的编码方式来进行输出。如果系统默认编码是cp437或cp1252，由于中文字符在这些代码页中显然不存在对应值，Python会抛出一个熟悉的错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;  File &amp;quot;c:\Python32\lib\encodings\cp437.py&amp;quot;, line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_map)[0]
UnicodeEncodeError: &amp;#39;charmap&amp;#39; codec can&amp;#39;t encode characters in position 0-1:
character maps to &amp;lt;undefined&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，当系统默认编码为cp936（GBK）时，无论&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;output.write(&amp;#39;你好，世界&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;print(&amp;#39;你好，世界&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;都可以正常工作。因为“你好，世界”这个Unicode字符串是可以被完全转换成GBK中的对应编码的。&lt;/p&gt;

&lt;h1&gt;一些总结和思考&lt;/h1&gt;

&lt;p&gt;虽然Python 3使用Unicode编码的字符串，但是在跨平台的程序中依然要取得系统的默认编码用于后续处理，因为并不是所有的终端环境都支持全部的Unicode字符集：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;if sys.stdout.isatty()
    default_encoding = sys.stdout.encoding
else
    default_encoding = locale.getpreferredencoding()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无论何时，不要随心所欲地用print()向stdout输出Unicode字符串。如果某个要输出的Unicode字符（比如，中文字）在系统默认编码的字符集（比如，代码页437）上没有，Python这时就会抛出一个错误。这其实在大部分时候并不是我们想看到的局面，我们总希望即使有时会输出一些无意义的乱码，程序整体上也能正确运行。拿视频下载工具的例子来说，即使由于终端的关系有时无法正确显示视频名称，这问题并不太严重，因为程序总是可以把抓取的视频内容写入正确的文件的。&lt;/p&gt;

&lt;p&gt;在程序中获取了系统默认的&lt;code&gt;default_encoding&lt;/code&gt;，我们就可以强制用它来对Unicode字符串进行编码，至少避免了Python在自动转码过程中可能会抛出的错误——虽然结果可能只是得到一堆乱码。另外一种处理方式是对于这样的字符串，我们决定根本不去输出它们。&lt;/p&gt;

&lt;p&gt;我们比较愿意看到的情况是：如果程序会输出且只会输出中文，而你假想中的Windows用户群所使用的代码页是936（GBK）——尽管在程序中使用Unicode字符串吧，这样做不会带来任何问题。&lt;/p&gt;

&lt;p&gt;但是，如果不能确定要处理的Unicode文本会限定在哪个代码页字符集的范围当中：中文？梵文？希伯来文？阿拉伯文？还是……火星文？这个时候就必须考虑到世界上还有“编码方式差异”这回事了。当然，最好的解决方式也许是：告诉用户，去他的代码页，去他的什么437、500、936、1252……这堆诡异的数字，去他的&lt;a href=&quot;http://en.wikipedia.org/wiki/Bush_hid_the_facts&quot;&gt;Bush hid the facts&lt;/a&gt;，扔掉设计上如此糟糕、编码方式如此混乱和不一致的Windows，转投一个&lt;a href=&quot;http://distrowatch.com/&quot;&gt;让生活更简单的操作系统&lt;/a&gt;吧。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>关于ICFP 2012编程赛的那点事情</title>
        <link href="http://www.soimort.org/posts/117" />
        <updated>2012-08-05T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/117/icfp</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;http://icfpcontest2012.wordpress.com/&quot;&gt;ICFP Programming Contest 2012&lt;/a&gt;的结果出来了。不出所料，第1轮惨遭淘汰。&lt;/p&gt;

&lt;p&gt;不过总算是混到了整整1200分，居然还不是最垫底，哥真是太感动了&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0013.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;221支参赛队提交了最终程序，拿到正分值的是194支，真的有人敢拿零分和负分的说（汗）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;(・U・)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/jeZiN.png&quot; alt=&quot;scoretable-full&quot;&gt;&lt;/p&gt;

&lt;p&gt;今年比赛的题目，简单地概括就是：操纵机器人在地底环境采矿。输入一个完全已知的由ASCII字符组成的地图（可能是标准的m×n矩形也可能是不规则形状什么的），地图上有许多叫做“lambda”的矿物（当然位置是已知的），机器人的初始位置也是给定在地图上的，你的任务就是要给出一串机器人行动的指令序列，使机器人依照这个指令序列所走的路径能够采完地图上所有矿点、并且最终抵达地图上的“升降井”位置以顺利完成整个采矿过程（在最理想的情况下）。机器人每采集一个矿点加25分，中途主动放弃的话每个采集到的矿点可以再额外增加25分，最终完成全部开采（抵达升降井）则每个矿点可以额外增加50分，当然作为代价，每执行一步指令要相应地扣除1分。&lt;/p&gt;

&lt;p&gt;当然啦，问题不可能设得这么没难度，才不会拿简简单单的动态规划来作比赛题呢。所以地图上的每个格子会有不同的地形，比如墙壁，比如泥土，比如石头，机器人的行动会造成各种后效性。泥土是可以被机器人钻开的，石头是可以被机器人推动的，石头下面如果没有别的物体支撑会以固定速率向下坠落，石头落到别的石头上因为无法支撑会滚向旁边，然后，如果机器人刚好在石头落下的时候处于下面格子的位置，就会被砸坏掉，采矿被迫终止并且得不到额外的加分。&lt;/p&gt;

&lt;p&gt;当然啦，即使这样问题还是太简单了，命题委员会（今年是University of St Andrews）于是充分发挥了一把苏格兰人的幽默感（黑色幽默？）：由于最近在苏格兰肆虐的洪水，在比赛开始后不久，我们的地下矿藏被水淹了！水位将以某给定的速率从地图下方开始上升，机器人在水下连续活动的时间由一个防水参数给定，超过这个时间仍然处于水下的机器人将会报废。&lt;/p&gt;

&lt;p&gt;当然啦，命题组还是觉得问题太简单了，于是在水灾的第二天，他们在地图里追加了一种叫做“蹦床”的元素。与其说是蹦床，不如说成是传送门更合适，当机器人走到一个蹦床的位置，它会被瞬间转移到地图上的另一个目标点。（宏观物质传输这不科学啊喂……）&lt;/p&gt;

&lt;p&gt;当然啦，命题组还是觉得……问题太简单了。于是接下来，地下矿藏里长出了一种奇葩的生物，叫做“Wadler的胡须”。这种生活在地底的诡异植物会以某个固定的速率疯长，每过一段时间就会向四周蔓延一格，这些被胡须占据的格子阻碍了机器人的行动，因此机器人必须使用有限的“Hutton的剃刀”来进行除草。一把剃刀只能使用一次，不过好在地图上也是分布有一些剃刀可以去拿的。（是不是有点像魔塔之类的游戏）&lt;/p&gt;

&lt;p&gt;一点小插曲，关于胡须和剃刀这两个名字：&lt;a href=&quot;http://homepages.inf.ed.ac.uk/wadler/&quot;&gt;Philip Wadler&lt;/a&gt;，Univ of Edinburgh的教授，是Haskell语言和XQuery的主要设计者之一；&lt;a href=&quot;http://www.cs.nott.ac.uk/%7Egmh/&quot;&gt;Graham Hutton&lt;/a&gt;，Univ of Nottingham的教授，&lt;a href=&quot;http://www.icfpconference.org/&quot;&gt;ICFP&lt;/a&gt;（The International Conference on Functional Programming，国际函数式编程会议）组委会的主席，那本《Programming in Haskell》的作者。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jlouisramblings.blogspot.com/2011/01/agda-musings-on-huttons-razor.html&quot;&gt;Hutton的剃刀（Hutton&amp;#39;s Razor）&lt;/a&gt;的概念（和名称）仿照自&lt;a href=&quot;http://en.wikipedia.org/wiki/Occam&amp;#x27;s_razor&quot;&gt;奥卡姆剃刀原理（Occam&amp;#39;s Razor）&lt;/a&gt;：“用较少的东西，同样可以做好的事情”。假定存在这么一种&lt;a href=&quot;http://professor-fish.blogspot.com/2011/01/tiny-bit-of-denotational-semantics.html&quot;&gt;极小化的编程语言&lt;/a&gt;，它由两种元素构成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;常量，包括从0开始的全部自然数；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个“&lt;code&gt;+&lt;/code&gt;”运算符，从而我们可以写出&lt;code&gt;(37 + 5) + 15 + (42 + 0)&lt;/code&gt;这样的语句。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;data Exp = Const Int
    | Add Exp Exp
eval :: Exp -&amp;gt; Int
eval (Const i) = i
eval (Add x y) = eval x + eval y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然，从定义来看，这并不是一种图灵完全的语言，在实际中几乎没有什么用处。但是通过必要的扩展，可以基于它一步步实现更多的算法。顾名思义，这个东西是Graham Hutton最早提出来的，用来让学生练习使用Haskell做语义分析。&lt;/p&gt;

&lt;p&gt;有了Hutton的剃刀，就有了&lt;a href=&quot;http://homepages.inf.ed.ac.uk/wadler/Pics/philtiebig.jpg&quot;&gt;Wadler的胡须（Wadler&amp;#39;s Beard）&lt;/a&gt;。这个，真的只是在调侃Wadler教授那标志性的大胡子而已……&lt;/p&gt;

&lt;p&gt;（貌似偏离主题了）&lt;/p&gt;

&lt;p&gt;当然啦，事情还没有完。命题组大概还是觉得，问题太简单了……在比赛第三天，一种叫做“高阶石（horock, higher-order rock）”的新矿物被发现了。它在通常形态下的性质与石头完全相同，唯一特别的是在从空中坠落并且落地之后，会释放出里面潜藏的lambda（大概可以类比成higher-order function？），然后就可以被机器人当作普通的矿物收集了。&lt;/p&gt;

&lt;p&gt;比赛分为Lighting division和Full division两部分。Lighting division相当于快速原型开发，想参加这个division评奖的队伍需要在比赛开始后24小时内提交原型程序（参加比赛的队伍可以自由选择参加或者不参加这个division），作为精神上的奖励，第一名队伍所用的语言将被宣布为“非常适合快速原型”的语言。Full division则是正式的比赛评奖，取前三名队伍，所用的语言分别被宣布为“挑剔黑客的编程工具最佳选择”“适合于许多方面应用的优秀工具”和“不太烂的编程语言”（基本上这个比赛的目的就是让优胜者拥有秀一下自己编程语言的bragging rights……）&lt;/p&gt;

&lt;p&gt;由此可见，比赛本身的精神鼓励大于物质奖励，而且比起函数式编程的学术主题，这个比赛更强调“编程工具”这一点，所以即使不使用函数式语言，甚至不使用函数式编程范式，都是完全允许的。评分方式是黑箱测试，无论提交二进制文件还是可执行的脚本都可以（源代码一般是不会看的），因此完全没有编程语言上的限制（和Google Code Jam一样）。&lt;/p&gt;

&lt;p&gt;每一轮的计分方式相同，比赛方选定五张地图（当然参赛队伍事先是不知道这些地图长什么样子的），每个队伍的程序需要跑这同样的五张地图，根据输出的解评分，按总分计算排名。每个程序的运行环境是一个单独的沙箱（虚拟机上的Debian），内存大小受限，硬盘空间受限，然后时间限制上是每张地图150秒，之后程序收到一个SIGINT信号，10秒后SIGKILL强制结束，如果仍然没有输出结果，则该地图按0分计算。&lt;/p&gt;

&lt;p&gt;大概是因为对效率要求高的原因，历年来比赛队伍的首选差不多都是ML或者Haskell，近年来更多地倾向于C++，选择Lisp/Scheme的可以说是少之又少。&lt;/p&gt;

&lt;p&gt;比赛前一天刚好看到一篇文章叫&lt;a href=&quot;http://prog21.dadgum.com/3.html&quot;&gt;Admitting that Functional Programming Can Be Awkward&lt;/a&gt;，觉得有点意思，顺手就&lt;a href=&quot;http://www.soimort.org/tech-blog/2012/07/12/functional-programming.html&quot;&gt;翻译过来&lt;/a&gt;了。文章里面举了一个例子是平面上的sprite游戏，作者的结论是这种涉及到复杂行为模拟和状态判断的应用，更加适合于依赖内存变量读写的过程式编程，并不适合函数式范式。这次的比赛，恰好也是一个类似的2D游戏问题求解。&lt;/p&gt;

&lt;p&gt;第一天，我尝试着用Standard ML写出一个原型，后来发现这么做有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ML里对二维数组的处理是极其繁琐的（从语法上）。如果我要定义一个函数，找出某个坐标周围邻近格子里某种元素的数目和位置，在C语言里面简简单单几层循环、取下标操作加上累加器变量就能清晰地解决的事情，在ML里需要函数调用层层嵌套，可读性会变得比较差。&lt;br&gt;
当然我相信ML是可以找到更加优雅可读（而且避免对副作用的依赖）的方案的，那就需要在类型系统上大作文章。要在比赛的几天中完成这些，无疑只会加重我的编程负担。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比起C，ML是非常high-level的语言。你不可能像在C中那样轻松地手动分配内存、赋值指针，不可能进行代码级别的时间和空间优化，一切都得交给编译器（MLton）来完成。&lt;br&gt;
在ML里，一段代码一旦写出来，就必然如公式般正确，剩下来的事情？优化，那种底层的事务是不应该在ML程序员的考虑范围内的。相比之下，C对于底层事务就有完全的控制权，当然作为代价，C语言：一、程序更难写，因为要纠缠与问题本质无关的细节实现；二、算法正确性难以从数学上证明，这是所有过程式语言的共同点。&lt;br&gt;
这种状态空间搜索的问题，对时间和空间的要求显然不会低，只有用C这样底层的语言来写才能保证最高的自由度。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后来发生的事情让我更加深刻地理解了“A C program is like a fast dance on a newly waxed dance floor by people carrying razors（一个C程序就像是一个身上带着剃刀的人在刚打过蜡的地板上跳快节奏的舞蹈）”这句话……&lt;/p&gt;

&lt;p&gt;再看一眼官方的5张地图，我的程序得分依次是：338，237，337，-3，291。&lt;/p&gt;

&lt;p&gt;啊咧，-3？&lt;/p&gt;

&lt;p&gt;我的算法几乎就是最原始的分支限界搜索找最优解，指令一开始Abort得0分，考虑到这个下限的保底解，程序怎么可能会得负分呢？&lt;/p&gt;

&lt;p&gt;（基于同样的理由，不太能理解为什么还有其他一些队伍也得了负分……）&lt;/p&gt;

&lt;p&gt;虽然觉得可能是地图的问题，但是并没有发现任何奇特之处。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;     ######
     #....#############
     #.**.. .. ..*@ \\#
     #.**..  .  ... \\#
     #.**..  .    . 3 #
######.\\......#****###
#**....*.......#    #
#\\...BL\\\....#    #
#A......*****..# 2\C#
######R.....###########
     ###.....*.....\\\#
       #\\\\#..1...\\\#
       #\\\\#......\\\#
       ################

Trampoline A targets 1
Trampoline B targets 2
Trampoline C targets 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是下载了这5张地图，在自己的机器上分别跑一遍150秒，拿自己的validator计分，结果如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full1.map 
RDRRRDDRDRDRRA
387
[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full2.map 
LLUURUUUUUURRA
237
[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full3.map 
RRUUULLUUUUURA
337
[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full4.map 
FATAL ERROR: illegal input
[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full5.map 
RRDDRRRRRRA
340
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二张和第三张地图的分值和官方结果一致，第一个和第五个略高于官方分值，要么是官方用的虚拟机配置比我低所以没能跑出更好的结果（今年测评用的虚拟机系统是32位x86）；要么就是我自己的validator有问题。暂时不去追究这些。然后第四张地图，我的输出解是：&lt;code&gt;FATAL ERROR: illegal input&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;说是此输入不合规范什么的，这不是我自己在处理地图时加的错误输出嘛！官方的测试系统显然是把它当作我解出来的指令序列来评分了（囧囧囧囧）&lt;/p&gt;

&lt;p&gt;调试之，问题出在蹦床的相关处理上：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3257709.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;这段代码的目的是当机器人到达蹦床位置时，找到传送目标点的坐标，然后把机器人移到该目标点的位置。这中间有一个对&lt;code&gt;c-&amp;gt;size&lt;/code&gt;的判断，因为一个蹦床必须和一个目标点对应，如果找到的目标点数目不为1，说明输入的原地图不合法，输出错误并终止程序。&lt;/p&gt;

&lt;p&gt;但是，不知道为什么&lt;code&gt;getCells&lt;/code&gt;返回的目标点总是2个：一个点位于&lt;code&gt;(18, 6)&lt;/code&gt;，一个点位于&lt;code&gt;(18, 14)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从地图上看来，&lt;code&gt;(18, 6)&lt;/code&gt;的值是ASCII字符&amp;#39;2&amp;#39;，确实是对应于蹦床B的目标点。不过&lt;code&gt;(18, 14)&lt;/code&gt;事实上是不存在于地图上的。地图上标有&amp;#39;2&amp;#39;的目标点，只有&lt;code&gt;(18, 6)&lt;/code&gt;一个而已。也就是说，难道是越界的数组下标访问的问题？但是为什么不是别的值刚刚好是&amp;#39;2&amp;#39;呢？&lt;/p&gt;

&lt;p&gt;观察越界访问的结果，看出了点端倪：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3257888.js?file=gistfile1.c&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;c-&amp;gt;elem[0]&lt;/code&gt;是&lt;code&gt;getCells&lt;/code&gt;返回的目标点之一的坐标值，&lt;code&gt;newMap-&amp;gt;elem[newMap-&amp;gt;height - c-&amp;gt;elem[0].y]&lt;/code&gt;这个字符串显示地图上该目标点所在行的完整内容，即：“&lt;code&gt;######\n&lt;/code&gt;”。&lt;/p&gt;

&lt;p&gt;该数组空间的最后一个字节是&lt;code&gt;newMap-&amp;gt;elem[newMap-&amp;gt;height - c-&amp;gt;elem[0].y][12] == &amp;#39;\0&amp;#39;&lt;/code&gt;，字符串结束。其后的下标引用都没有意义。由于编译器未定义的内存分配机制，在&lt;code&gt;newMap-&amp;gt;elem[0][13]&lt;/code&gt;后面本不存在的下标因为越界访问而指向了别的地方（实际上是&lt;code&gt;newMap-&amp;gt;elem[8][13]&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;于是找到了原因，应该是&lt;code&gt;getCells&lt;/code&gt;里面的越界下标访问造成了返回值的重复，实际上找到的两个目标点是同一个：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3257894.js?file=gistfile1.c&quot;&gt;&lt;/script&gt;

&lt;p&gt;造成这个bug是由于不规则形状的地图，在读取的时候某些行具有较短的长度，但在访问时却统一按最长行处理，数组下标越界的时候编译器又没报错，于是就造成了隐蔽的错误。比赛的时候只用了自己写的几个规则矩形地图做测试，于是这样的错误并不能及时发现。&lt;/p&gt;

&lt;p&gt;修改后的程序段：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3257907.js?file=gistfile1.c&quot;&gt;&lt;/script&gt;

&lt;p&gt;再次运行，找到个比-3稍微好一点的解……&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;[soimort@Seele icfp-2012]$ ./lifter &amp;lt; full4.map 
RRDDRRRDLLLA
389
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;算法部分暂时不想再回头看了，毫无亮点。因为比赛的时间仓促，命题方不断追加条件（于是要不断地改模拟），再加上一个人做做玩玩，到了最后一天下午才赶出来个能用的分支限界算法，编译通过，于是差不多就提交了。总的来说，这种比赛的形式还是很不错的，给出几天的时间用来编码，允许组队合作，比起Code Jam和TopCoder自由度高很多。命题方随时更改需求、最后根据算法接近最优解的程度给分而不是只有一个唯一解，这也更接近现实中的问题求解过程。(・U・)&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>Linux上的PSP模拟器：JPCSP的安装和使用</title>
        <link href="http://www.soimort.org/posts/116" />
        <updated>2012-07-27T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/116/jpcsp</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;http://jpcsp.org/&quot;&gt;JPCSP&lt;/a&gt;是当今最流行的开源PSP模拟器，支持Win 32/64 / Linux 32/64 / Mac OS X平台。&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;http://code.google.com/p/jpcsp/&quot;&gt;项目主页&lt;/a&gt;：JPCSP是使用Java写的，但是模拟PSP游戏已经可以达到满速（100%）。&lt;/p&gt;

&lt;p&gt;这里是我在Arch Linux（x86_64）上安装JPCSP的经过，使用了OpenJDK 7.0的JRE。尽管如此，使用较旧的OpenJDK 6或Oracle 的JRE也许可以回避安装方式一（从官网下载最新版本）中某些不必要的错误。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ sudo pacman -S jre7-openjdk --needed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;安装方式一：从官网下载最新版本&lt;/h1&gt;

&lt;p&gt;在JPCSP官网（&lt;a href=&quot;http://jpcsp.org/&quot;&gt;http://jpcsp.org/&lt;/a&gt;）上下载对应的Latest svn builds（Linux 64版本）。&lt;/p&gt;

&lt;p&gt;解压到任意文件夹，执行&lt;code&gt;start-linux-amd64.sh&lt;/code&gt;启动脚本：
    $ cd jpcsp-linux-amd64
    $ chmod +x start-linux-amd64.sh
    $ ./start-linux-amd64.sh&lt;/p&gt;

&lt;p&gt;模拟器不能正常运行。抛出如下异常：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Exception in thread &amp;quot;GUI&amp;quot; java.lang.UnsatisfiedLinkError:
no lwjgl in java.library.path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://lwjgl.org/&quot;&gt;LWJGL&lt;/a&gt;（Lightweight Java Game Library）按理说是已经包含在JPCSP里面的，无需再单独安装。在JPCSP安装路径的&lt;code&gt;lib/&lt;/code&gt;目录下面可以找到&lt;code&gt;lwjgl.jar&lt;/code&gt;、&lt;code&gt;lwjgl_util.jar&lt;/code&gt;两个JAR文件，&lt;code&gt;lib/linux-amd64/&lt;/code&gt;下面也有它的动态链接库（&lt;code&gt;liblwjgl64.so&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;去看LWJGL的wiki，只写了可能的错误是因为本地库的路径&lt;code&gt;-Djava.library.path=path/to/dir&lt;/code&gt;设置不正确。再去看&lt;code&gt;start-linux-amd64.sh&lt;/code&gt;的内容，可是java后面确实有&lt;code&gt;-Djava.library.path=lib/linux-amd64&lt;/code&gt;的选项啊？疑惑中……&lt;/p&gt;

&lt;p&gt;怀疑是因为动态链接库文件名的问题。建立三个对应的文件名不带“64”的符号链接&lt;code&gt;libjinput-linux.so&lt;/code&gt;、&lt;code&gt;liblwjgl.so&lt;/code&gt;、&lt;code&gt;libopenal.so&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ln -s lib/linux-amd64/libjinput-linux64.so lib/linux-amd64/libjinput-linux.so
$ ln -s lib/linux-amd64/liblwjgl64.so lib/linux-amd64/liblwjgl.so
$ ln -s lib/linux-amd64/libopenal64.so lib/linux-amd64/libopenal.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;果然，不再抛出该异常。但是又出现了新的状况：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Exception in thread &amp;quot;GUI&amp;quot; java.lang.UnsatisfiedLinkError:
/home/soimort/Programs/jpcsp-linux-amd64/lib/linux-amd64/liblwjgl.so:
libjawt.so: cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;libjawt.so&lt;/code&gt;是Java AWT Native Interface的动态链接库，按理说这东西是没理由不存在的啊……&lt;/p&gt;

&lt;p&gt;搜了一下，发现不少人遇到同样的LWJGL在Linux + OpenJDK 7下无法加载&lt;code&gt;libjawt.so&lt;/code&gt;的诡异问题：（OpenJDK 6下貌似正常）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;quot;libjawt.so&amp;quot; not loaded by Java 7

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/jdk7-dev/2011-August/002256.html&quot;&gt;http://mail.openjdk.java.net/pipermail/jdk7-dev/2011-August/002256.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Java issue: libjawt.so. No such file or directory

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.archlinux.org/viewtopic.php?id=124432&quot;&gt;https://bbs.archlinux.org/viewtopic.php?id=124432&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Urgent panic - JRE7 / LWJGL / Linux broken

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://lwjgl.org/forum/index.php/topic,4085.0.html&quot;&gt;http://lwjgl.org/forum/index.php/topic,4085.0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然不是很明白，但是似乎只能通过手动导出&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;环境变量来解决问题。找到&lt;code&gt;libjawt.so&lt;/code&gt;所在的文件夹（也就是JRE安装时动态链接库的所在路径），在我的系统上是&lt;code&gt;/usr/lib/jvm/java-7-openjdk/jre/lib/amd64/libjawt.so&lt;/code&gt;。然后：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ export LD_LIBRARY_PATH=/usr/lib/jvm/java-7-openjdk/jre/lib/amd64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可正常运行JPCSP。为了省去以后的麻烦，直接修改&lt;code&gt;start-linux-amd64.sh&lt;/code&gt;，在启动JPCSP之前加入此行内容：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;#!/bin/sh
export LD_LIBRARY_PATH=&amp;quot;/usr/lib/jvm/java-7-openjdk/jre/lib/amd64&amp;quot;
java -Xmx1024m -Xss2m -XX:MaxPermSize=128m -XX:ReservedCodeCacheSize=64m \
    -Djava.library.path=lib/linux-amd64 -jar bin/jpcsp.jar $@
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以正常运行JPCSP了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ ./start-linux-amd64.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;安装方式二：从AUR安装&lt;/h1&gt;

&lt;p&gt;到目前为止，AUR上的JPCSP版本仍然基于原来的&lt;a href=&quot;http://jogamp.org/jogl/www/&quot;&gt;JOGL&lt;/a&gt;（Java Bindings for the OpenGL API），而不是LWJGL，所以在JRE 7下运行不会发生&lt;code&gt;libjawt.so&lt;/code&gt;无法加载的错误。&lt;/p&gt;

&lt;p&gt;直接从AUR安装以下两个包即可：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jogl&lt;/strong&gt;: &lt;a href=&quot;https://aur.archlinux.org/packages.php?ID=54677&quot;&gt;https://aur.archlinux.org/packages.php?ID=54677&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jpcsp&lt;/strong&gt;: &lt;a href=&quot;https://aur.archlinux.org/packages.php?ID=29774&quot;&gt;https://aur.archlinux.org/packages.php?ID=29774&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装后可通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ jpcsp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来运行模拟器。&lt;/p&gt;

&lt;p&gt;初次运行时，如果控制台产生类似如下错误输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;log4j:ERROR Could not parse file [LogSettings.xml].
java.io.FileNotFoundException: /home/soimort/.jpcsp/LogSettings.xml
(No such file or directory)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是由于没有可用于保存本地配置文件的目录（普通用户没有安装位置&lt;code&gt;/opt/jpcsp&lt;/code&gt;下的写权限）。在用户主目录下创建&lt;code&gt;.jpcsp/&lt;/code&gt;目录并将&lt;code&gt;/opt/jpcsp/LogSettings.xml&lt;/code&gt;直接拷贝到此处即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ mkdir ~/.jpcsp
$ cp /opt/jpcsp/LogSettings.xml ~/.jpcsp/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;设置与使用&lt;/h1&gt;

&lt;p&gt;那啥。PSP是不能用鼠标来控制的。。。&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0013.gif&quot;/&gt;
所以要记住常用的键盘键位（当然如果有手柄就另当别论了）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;↑ / ↓ / ← / →: 光标键&lt;strong&gt;↑ / ↓ / ← / →&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;○ / × / □ / △: &lt;strong&gt;D / S / A / W&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;L / R: &lt;strong&gt;Q / E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;START: &lt;strong&gt;Enter&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SELECT: &lt;strong&gt;Space&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/m39Tc.png&quot; alt=&quot;Controls&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.iso&lt;/code&gt;镜像文件要放到JPCSP安装路径下的&lt;code&gt;umdimages/&lt;/code&gt;文件夹内。菜单File - Load UMD载入UMD游戏镜像。&lt;/p&gt;

&lt;p&gt;注意并不是所有的PSP游戏都能在模拟器下正常运行，即使能运行的镜像有的也需要使用第三方工具破解。当然破解镜像的方法不在本文范围之内。。。&lt;/p&gt;

&lt;p&gt;点击“Run”开始运行。&lt;/p&gt;

&lt;p&gt;在不做任何额外设置的情况下，模拟器的帧速有可能会卡到游戏根本无法进行。在我的Dell Latitude上（Intel四核Core i5 2540M 2.6GHz + 4GB RAM + 集成Intel HD Graphics 3000），一开始的选单画面仅有5～6 FPS&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0009.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/I1lzT.jpg&quot; alt=&quot;Video&quot;&gt;&lt;/p&gt;

&lt;p&gt;经过测试，发现选中“Enable saving GE screen to Textures instead of Memory”这一项可以有效提速。其它选项的设置在我的机器上对帧速基本没有明显影响。&lt;/p&gt;

&lt;p&gt;关于Video设置里面每个选项的具体含义，有两篇帖子可供参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.emunewz.net/forum/showthread.php?tid=6738&quot;&gt;http://www.emunewz.net/forum/showthread.php?tid=6738&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.emunewz.net/forum/showthread.php?tid=4262&amp;amp;pid=13327#pid13327&quot;&gt;http://www.emunewz.net/forum/showthread.php?tid=4262&amp;amp;pid=13327#pid13327&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按照论坛里的说法，这些选项是关于低阶PSP图像函数如何映射到OpenGL函数的设置，对性能的影响与具体的游戏具体的场景也有关系……所以说是个很微妙的东西。&lt;/p&gt;

&lt;p&gt;就拿《AKB 1/48》来说，经过上述选项的调整，在选单界面下FPS可以达到稳定的30左右：&lt;/p&gt;

&lt;p&gt;（呃。。。决定去攻略一下小石田先&amp;lt;3）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Hu6Nk.jpg&quot; alt=&quot;Menu_1&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/IR400.jpg&quot; alt=&quot;Menu_2&quot;&gt;&lt;/p&gt;

&lt;p&gt;但是在对话场景下就变得很不流畅，FPS降到了6左右，画面的切换延迟感明显。。。&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0012.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Video配置下面的Only GE graphics，Use Vertex Cache等等各种选项都尝试过了，对话场景的帧速依然没有明显的改善。&lt;/p&gt;

&lt;p&gt;好在这种场景下是不需要太高的帧速的。于是不如就慢慢欣赏吧&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0002.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/SBlwl.jpg&quot; alt=&quot;Dialog&quot;&gt;&lt;/p&gt;

&lt;p&gt;以上，模拟器设置的优化提速还有待研究。&lt;/p&gt;

&lt;p&gt;剩下来的一个问题是，《AKB 1/48》的镜像虽然包含效果音，但是对白、神告白的语音和BGM全没有（听不到萌音还有什么乐趣啊喂。。。）&lt;/p&gt;

&lt;p&gt;好几个G的语音包正在龟速下载中&lt;img src=&quot;http://static.tieba.baidu.com/tb/editor/images/jd/j_0013.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;BGM的播放貌似需要有SonicStage（只有Windows版本），这个问题如何解决以后再慢慢研究。。。&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>我的Linux/Unix不完全折腾史</title>
        <link href="http://www.soimort.org/posts/115" />
        <updated>2012-07-24T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/115/distros</id>
        <content type="html">&lt;h2&gt;曾经折腾过的发行版&lt;/h2&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenSolaris&quot;&gt;OpenSolaris&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;大一的时候因为参加ACM/ICPC而第一次接触到除了Windows以外的系统，因为当年北京赛的赞助商是Sun。&lt;/p&gt;

&lt;p&gt;也是第一次接触到开源软件，JDK，NetBeans这些半懂不懂的名词。&lt;/p&gt;

&lt;p&gt;北京赛后的讲座听了一堆关于Solaris的ZFS文件系统的好处，虽不懂但觉厉。结束后在场每人发一张OpenSolaris 2008.05的Live CD，第一次知道操作系统原来可以比Win XP的盗版碟还便宜。&lt;/p&gt;

&lt;p&gt;比赛结束之后偶尔还会在VirtualBox上折腾一阵。后来还装了MilaX，精简的Live CD发行版。&lt;/p&gt;

&lt;p&gt;其后几年见证了Sun的被收购，Oracle的种种劣行，以及OpenSolaris的无疾而终。&lt;/p&gt;

&lt;p&gt;如今基于开源版Solaris内核的社区项目还有OpenIndiana，Illumos和Nexenta。但是没有了Sun这样的大公司强推，感觉整个Solaris的用户群已经非常小众（尤其是在桌面这一块）。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenSUSE&quot;&gt;openSUSE&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我在VirtualBox上安装的第一个Linux系统。初学者友好的发行版之一。选择它的原因是因为看到某师兄在用。&lt;/p&gt;

&lt;p&gt;比起基于GNOME 2的OpenSolaris，当时装的openSUSE是使用KDE桌面的。不过它的漂亮界面并没给我留下什么深刻的印象，可能是因为笔记本性能问题，在虚拟机里面运行起来效果略卡。于是后来几乎就没再碰过。&lt;/p&gt;

&lt;p&gt;后来GNOME 3发布之后，曾经用基于openSUSE的Live CD尝试过新的GNOME。但是没有用它的打算。&lt;/p&gt;

&lt;p&gt;btw：openSUSE的安全策略在前一阵子被Linus喷过，因为它在用户执行一些最基本的日常任务时都会不胜其烦地要求输入密码。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Ubuntu_(operating_system)&quot;&gt;Ubuntu&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;第一次使用Wubi安装。&lt;/p&gt;

&lt;p&gt;初学者友好的发行版之一，基于Debian，但隐藏了许多底层细节，软件库的更新比Debian快。不知为何，它缺少吸引我的要素（大概是因为当时对GNOME 2无感），所以在安装之后就迅速地被我遗忘了。&lt;/p&gt;

&lt;p&gt;再次接触到Ubuntu就是在Unity发布之后了。在尝试了可是说是史上最难用的Unity之后，我决定放弃它。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Linux_Mint&quot;&gt;Linux Mint&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;第一次在硬盘分区上安装的发行版。&lt;/p&gt;

&lt;p&gt;初学者友好的发行版之一，基于Ubuntu。出于当时对“轻量级桌面”的追求，我用的是基于LXDE的版本。&lt;/p&gt;

&lt;p&gt;当时我没有继续用下去的理由是：1、进入桌面之后硬盘指示灯常闪，而且无从找到进程疯狂损耗硬盘的原因；2、LXDE很没有质感，鼠标点击窗口拖动觉得各种生硬。&lt;/p&gt;

&lt;p&gt;尽管如此，Linux Mint还是在我硬盘上停留了相当长一段时间。直到iGEM 2010期间，还偶尔进几次Mint用来编译Linux平台下的程序。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Chakra_Linux&quot;&gt;Chakra&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;初学者友好的发行版之一，基于Arch。&lt;/p&gt;

&lt;p&gt;在转移到Arch之前，Chakra显然是在我硬盘上停留时间最长的发行版之一。基本上从2011年年初到9月份之前都在折腾这个系统。&lt;/p&gt;

&lt;p&gt;使用Chakra的契机是试图在旧的HP笔记本上使用Arch失败，还没装X就经常内核启动莫名其妙地freeze。于是就发现了Chakra这个Live CD发行版，还有学校服务器上正好有KDEmod的源。&lt;/p&gt;

&lt;p&gt;Chakra的图形化安装界面是我见过最好的（没有之一），整个安装流程异常简单。&lt;/p&gt;

&lt;p&gt;基于KDE SC的桌面定制得非常华丽。&lt;/p&gt;

&lt;p&gt;当时Chakra和Arch的开发库还没有完全独立，因此想要的软件（SciTE编辑器）在Chakra的库里没有，可以直接拿Arch库里的过来安装。&lt;/p&gt;

&lt;p&gt;但是逐渐一些问题出现了：&lt;/p&gt;

&lt;p&gt;Chakra尚处于开发状态，很多东西还不稳定，有时候升级之后某些Bundle无法正常安装，双击安装之后就消失，新的桌面图标也没有出现，不知道安装去哪了。&lt;/p&gt;

&lt;p&gt;Bundle系统这个东西本身就很坑爹。下载好的一个Bundle文件双击之后就自动安装，安装之后该文件就自动消失，隐藏了这中间的底层细节，这是它严重背离了Arch哲学的地方。&lt;/p&gt;

&lt;p&gt;之所以需要Bundle这种东西，是因为Chakra试图做一个“纯粹KDE”的发行版，所以官方源里面只包含基于Qt的GUI程序，排斥一切GTK+程序。这也是个很坑爹的设定，因为许多GTK软件（Chromium，Firefox，GIMP，Inkscape）是难以找到功能相当的Qt替代品的。如果用户需要的只有一两个还好说，如果用户要用的GTK+程序多了，难道安装的每个Bundle里面都要包含各自的一套独立的GTK+库？&lt;/p&gt;

&lt;p&gt;Chakra和Arch的关系很不明朗。虽然Chakra至今为止仍然使用pacman作为包管理方式，但是Arch是完全滚动升级，Chakra不是。难以知道哪些Arch的软件包可以用在Chakra上，哪些不能。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/PC-BSD&quot;&gt;PC-BSD&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;基于FreeBSD+KDE的桌面BSD系统，DVD镜像看起来是个庞然大物。&lt;/p&gt;

&lt;p&gt;BSD在桌面领域的应用鲜为人知。不知道是显卡驱动的问题还是Xorg移植的问题，总觉得BSD下的KDE桌面较Chakra的KDE桌面卡不少。&lt;/p&gt;

&lt;p&gt;第一次接触到BSD的ports系统，体验了一把从编译到安装GNU octave需要七个多小时是什么概念。机器发热剧烈（很可能还是导致旧的HP笔记本后来显卡烧掉的间接原因……）。&lt;/p&gt;

&lt;p&gt;FreeBSD的bootloader自成一体，可以引导Windows但是几乎没有像样的界面，所以安装之后赶紧用GRUB替换然后chainloader到BSD分区。&lt;/p&gt;

&lt;p&gt;FreeBSD分区的文件系统更是自成一体，UFS2，在Linux下读写有困难。&lt;/p&gt;

&lt;p&gt;总结，BSD只适合服务器，就目前来看，的确不适合用来做桌面环境。遇到麻烦也诸多不便。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Slackware&quot;&gt;Slackware&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;最古老的发行版之一，项目主页的样式古老，开发方式古老，光盘镜像的发布风格古老，包管理方式古老。&lt;/p&gt;

&lt;p&gt;优点是架构简洁，对上游软件代码几乎不做额外的定制，采用类BSD风格的初始脚本。适合中高级用户DIY。以前包依赖关系的处理是个比较头疼的问题，所幸有slapt-get的出现。&lt;/p&gt;

&lt;p&gt;缺陷是如今比起其他发行版，更缺少相对活跃的社区，文档较为匮乏。完全采取封闭式开发，版本发布缓慢，官方软件库过于陈旧，且提供的桌面环境只有KDE。但稳定性和持久性的确是这种方式带来的一大好处，这是Gentoo和Arch所不能比拟的。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Slax&quot;&gt;Slax&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;本质上是基于Slackware的一个最小化定制Live CD。它是一个非常有趣的发行版。首先，它内置syslinux作为bootloader，镜像可以简单地拷贝到U盘或者移动硬盘的FAT32分区上，只要执行官方提供的脚本就能够写入MBR用来引导系统，完全不需要使用其他发行版制作Live USB所必需的UNetbootin等外部工具；其次，它镜像文件系统内的包是高度模块化的，如果只需要Slax Core，可以做到非常之小，即使再加上KDE 3桌面环境、Firefox和一些基础的开发工具，总计也不超过200M。&lt;/p&gt;

&lt;p&gt;除了Slax之外，由Slackware衍生来的还有其他一些有趣的轻量级Live CD，诸如SliTaz和Zenwalk。它们保持了Slackware的高度稳定性和可定制性，当然，也继承了Slackers的开发更新缓慢的特性。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Parted_Magic&quot;&gt;Parted Magic&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;已经不记得什么时候开始起用的Parted Magic了，这个发行版一直以来常驻U盘，用来做系统灾难时的数据抢救、GRUB恢复，当然还有折腾新系统前对硬盘进行各种分区准备工作。&lt;/p&gt;

&lt;p&gt;后来因为这个发行版更新得太频繁，不想每次更新都重写一次U盘镜像，于是把iso放在硬盘的一个分区里通过burg来引导。&lt;/p&gt;

&lt;p&gt;再后来就开始习惯在电脑上装双Linux，一个系统出问题了还有另一个，于是Parted Magic就很少再需要用到了。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Gentoo_Linux&quot;&gt;Gentoo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;拿到了学校的Dell四核笔记本后，我决定尝试Gentoo。&lt;/p&gt;

&lt;p&gt;Gentoo是基于源码的发行版，也是让我从真正意义上戒掉了对Windows依赖的第一个Linux发行版。之前用Chakra仅仅还是停留在“玩”的阶段，并没有真正用它来写代码和处理日常工作什么的。直到转移到Gentoo，才开始习惯了用Linux工作（或者不如说是习惯了用Openbox工作）。&lt;/p&gt;

&lt;p&gt;用Gentoo之前习惯了KDE这种重量级的桌面环境，WM只知道一个Fluxbox（之前在Slax下面弄的）。认识了一个德国人，用Arch+Openbox，才知道窗口管理器并不是什么已经淘汰的老古董，正好Gentoo的wiki上面有详尽的Openbox教程，于是开始接触Openbox，还有tint2、feh、conky、idesk、cairo-dock，一堆乱七八糟的组件。&lt;/p&gt;

&lt;p&gt;Gentoo下面没有太多现成的东西，但是也因此更容易把系统定制成符合自己习惯的工作方式。&lt;/p&gt;

&lt;p&gt;从Gentoo最初的stage3安装成功，到定制出适合自己的Openbox环境，再到通宵编译整套的KDE，整个过程不但是对机器性能的考验，更是对搜索和阅读文档能力的考验。&lt;/p&gt;

&lt;p&gt;在我看来Gentoo最突出的一点是有着强大的技术社群（Ubuntu衍生版用户的普遍水平是比不了的……）。这一点体现在文档上，于是有时候我在其他发行版下遇到问题，都会想到直接去翻Gentoo的wiki。&lt;/p&gt;

&lt;p&gt;用Gentoo时遇到的最大问题是Xorg偶尔假死，不明真相。屡次重新编译，翻遍各种文档，依然不能完全解决问题。&lt;/p&gt;

&lt;p&gt;在升级过一次gcc-lib后，系统被破坏，某些程序开始无法正常运行。试图从stage3恢复系统，结果发现要恢复一个损坏的肮脏系统比重装一个干净的系统麻烦得多。&lt;/p&gt;

&lt;p&gt;重装，又需要花费极大的时间代价，因为一切都得用新版本的gcc重新编译一遍。系统是用来干活的，不能整天为了编译一个不一定稳定还搞不好以后哪次更新又会被破坏掉的系统而折腾。于是索性放弃。&lt;/p&gt;

&lt;p&gt;无论如何，使用Gentoo的经历让人受益良多。任何一个想用Linux但是又指望别人手把手教他的新手都应该去自行装一遍Gentoo，才能真正领会RTFM和STFW的真谛。&lt;/p&gt;

&lt;p&gt;而且在折腾过Gentoo之后会发现，原来其他所有的发行版都是如此地user-friendly……&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;正在折腾的发行版&lt;/h2&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Arch_Linux&quot;&gt;Arch Linux&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;多年之前，我就曾经试图在旧的HP笔记本上安装Arch，结果却遇到了诡异的kernel freeze。这使得我对它的稳定性产生了极坏的印象。&lt;/p&gt;

&lt;p&gt;放弃Gentoo之后，我第一个想到的就是Arch。原因其一，机器已经不是当年的HP笔记本了，内核也不知升级了多少版本，我的运气应该不会好到再次碰上kernel freeze的地步；其二，反正之前用了那么久的Chakra，对pacman的包管理方式还算熟悉。&lt;/p&gt;

&lt;p&gt;起初，Arch看起来就像是“不用浪费时间编译的Gentoo”，安装过程异常简单。重新配置了类似以前的Openbox环境，也没有遇到过任何问题。一切看起来很好。&lt;/p&gt;

&lt;p&gt;Arch上的Openbox并没有用很久，因为我发现了GNOME 3。&lt;/p&gt;

&lt;p&gt;起初我并不喜欢GNOME 3，一半是因为网上铺天盖地的批评（比如无视桌面用户体验什么的），另一半是因为缺少任务栏和启动菜单的GNOME Shell确实让我心理上无法接受。然而，当我发现tint2可以与GNOME Shell神奇般地协同工作之后，我的看法改变了。&lt;/p&gt;

&lt;p&gt;GNOME很好地体现了简约主义的原则，没有多余的东西（除了没有任务栏这一点确实很让人不爽之外），可以设置的地方也相当有限。相比之下，你可以用KDE定制出一套非常复杂和华丽的界面，高仿上网本，再加上各种分页，面板，花里胡哨的小插件……&lt;/p&gt;

&lt;p&gt;其实不管是重量级的桌面环境还是轻量级的WM，最重要的是切换和拖动窗口的快捷程度和视觉效果。这是能直接影响到工作效率的因素。别的，对我来说都是浮云。&lt;/p&gt;

&lt;p&gt;Arch从去年年底用到现在，其间经历过若干次系统升级产生的问题（并且导致了我的3次重装系统）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年2月4日的&lt;code&gt;linux 3.2.3-1&lt;/code&gt;更新（不记得是不是内核的问题了……），导致启动时提示&lt;code&gt;INFO: rcu_preempt detected stalls on CPUs/tasks&lt;/code&gt;，然后系统freeze。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2月4日正巧是在布鲁塞尔参加FOSDEM的第一天。会场有无线网络，随手升级了一下系统（无聊的时候&lt;code&gt;pacman -Syu&lt;/code&gt;习惯成自然了……），于是就悲剧了。跑到会场外面的“hacker room”重装系统，异常欢乐。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年4月的&lt;code&gt;consolekit 0.4.6-1&lt;/code&gt;更新（正好是在Google Code Jam资格赛前一天），导致无法进入GNOME。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然很快这个bug就被修复并且放出了新的包，但是我重新安装之后，奇葩地依然进不了GNOME，就连GNOME删掉重装都不行。急于准备比赛，不找原因了，直接重装全系统。&lt;/p&gt;

&lt;p&gt;这次重装过程中还出了点有惊有险的意外，嗯，写USB镜像的时候&lt;a href=&quot;http://blog.soimort.org/2012/04/archcodejam.html&quot;&gt;移动硬盘分区表被Image Writer破坏了&lt;/a&gt;……&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年5月，&lt;code&gt;pulseaudio 2.0-1&lt;/code&gt;和&lt;code&gt;libpulse 2.0-1&lt;/code&gt;更新导致VLC播放器的视频和音轨不同步。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.archlinux.org/task/29906&quot;&gt;https://bugs.archlinux.org/task/29906&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.freedesktop.org/show_bug.cgi?id=50024&quot;&gt;https://bugs.freedesktop.org/show_bug.cgi?id=50024&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个上游库导致的问题，与Arch本身无关。我的解决方法是git二分找出了产生问题的commit，手动滚回去。此后用的一直都是自己构建的包。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年6月9日，&lt;code&gt;linux 3.3.8-1&lt;/code&gt;更新。自从这个版本的内核之后，我的Dell Latitude E6420再也不能关机和重启了（不管是&lt;code&gt;poweroff&lt;/code&gt;、&lt;code&gt;reboot&lt;/code&gt;还是&lt;code&gt;init 6&lt;/code&gt;）。试过了所有的内核参数（&lt;code&gt;reboot=pci&lt;/code&gt;之类），依然无解。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.archlinux.org/task/30136&quot;&gt;https://bugs.archlinux.org/task/30136&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugs.launchpad.net/ubuntu/+source/linux/+bug/780757&quot;&gt;https://bugs.launchpad.net/ubuntu/+source/linux/+bug/780757&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.kernel.org/show_bug.cgi?id=42542&quot;&gt;https://bugzilla.kernel.org/show_bug.cgi?id=42542&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是上游kernel的问题，与Arch无关。我没有像上次找到PulseAudio的问题一样成功git bisect，原因之一是Linux的代码库实在是过于庞大，从一个发布版本到下一个发布版本之间n多commit；原因之二是每次测试一旦失败则意味着要强制关机（好像kexec切换内核不能……），对机器伤害太大（这种具体机器环境相关的测试又不能在虚拟机下进行）。&lt;/p&gt;

&lt;p&gt;我的解决方案是降级到3.3.7的内核，从此直接忽略linux的更新。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年7月12日，为了准备ICFP需要安装VirtualBox，这个时候内核版本滞后带来的问题显示出来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;virtualbox-modules是与linux内核模块直接相关的，因此依赖于特定的内核版本。此时linux次版本号已经进入了3.4阶段，故virtualbox-modules的依赖是linux&amp;gt;=3.4和linux&amp;lt;3.5。&lt;/p&gt;

&lt;p&gt;如此一来，virtualbox就无法在我当前的系统（linux 3.3）上安装。而Arch Linux的官方库又不保留过期的软件包，因此唯一的解决方法是去Arch Rollback Machine上找旧版本的包，或者自己从PKGBUILD手动构建。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2012年7月14日，&lt;code&gt;glib 2.16.0-2&lt;/code&gt;升级，系统中原来&lt;code&gt;/lib&lt;/code&gt;目录的内容全部转移到&lt;code&gt;/usr/lib&lt;/code&gt;，&lt;code&gt;/lib&lt;/code&gt;代之以指向&lt;code&gt;/usr/lib&lt;/code&gt;的符号链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官方提供的升级方案是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Syu --ignore glibc
# pacman -Su
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果仍然出现冲突错误，说明&lt;code&gt;/lib&lt;/code&gt;中仍然有属于其他包（glibc之外的包）的文件，需要重新构建这些包把它们所使用的位置改到&lt;code&gt;/usr/lib&lt;/code&gt;。不能使用&lt;code&gt;--force&lt;/code&gt;选项强行升级，否则会破坏整个系统。&lt;/p&gt;

&lt;p&gt;没错，我当前的系统上是有这么一个包使用了&lt;code&gt;/lib&lt;/code&gt;。这就是&lt;code&gt;linux 3.3.7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最新的3.4.5版内核确实是使用了&lt;code&gt;/usr/lib&lt;/code&gt;来取代&lt;code&gt;/lib&lt;/code&gt;作为内核模块的位置，所以毫无疑问可以和新的glibc一同正常工作。我理应把&lt;code&gt;linux 3.3.7&lt;/code&gt;用类似的编译选项重新构建一遍。但是我当时正处于ICFP比赛当中，不可能有空去折腾这些。于是，我直接了忽略glibc这个包的更新。而且，我实在是看不出Arch开发团队把&lt;code&gt;/lib&lt;/code&gt;迁移到&lt;code&gt;/usr/lib&lt;/code&gt;有什么实质的意义。&lt;/p&gt;

&lt;p&gt;然后问题就来了：你希望保持某些版本的包不再更新因为它们相对稳定，但Arch却总是假设你使用的所有包永远都处于最新状态。也就是说，Arch的哲学是每个人都理应处于最前沿的bleeding edge，不接受旧版本包的bug报告、甚至不提供旧版本包的下载都是这种Arch哲学的体现。一个包做出了某种更新，所有依赖它的包都必须立即重新构建，如果你压住了一个非常底层的包（比如，有很多其他的包依赖于它）不进行更新，那么，事实上你就会越来越脱离Arch的开发主线，以后再进行任何更新都可能导致意料之外的问题。&lt;/p&gt;

&lt;p&gt;glibc就属于这种典型的情况。你永远无法计算Linux上面有多少软件包是依赖于glibc的。&lt;/p&gt;

&lt;p&gt;在忽略了&lt;code&gt;glibc 2.16.0-2&lt;/code&gt;的更新后不久，binutils也相应地升级了。仅仅给出了一条“启动时将从&lt;code&gt;/usr/lib/modules&lt;/code&gt;而非&lt;code&gt;/lib/modules&lt;/code&gt;读取”的提示，之后便升级成功。按理说，这个升级是完全依赖于&lt;code&gt;glib 2.16.0-2&lt;/code&gt;这一升级的，但是不知为何，并没有写入相应的依赖关系。果然，在重启系统时出错，无法读取内核模块。通过创建&lt;code&gt;/usr/lib/modules&lt;/code&gt;这个符号链接指向&lt;code&gt;/lib/modules&lt;/code&gt;，暂时解决了问题。&lt;/p&gt;

&lt;p&gt;更新的binutils依赖于&lt;code&gt;glibc 2.16.0-2&lt;/code&gt;的升级这一事实被我意识到了，然而，肯定还有其他的更新的包依赖于这个升级，我不可能全部意识到。事实上，问题很快就随之出现：在编译某些以前可以正常编译的程序时，蹦出来一堆GLIBC库相关的错误，于是我意识到，我需要把我的glibc升级到2.16.0-2了。&lt;/p&gt;

&lt;p&gt;为了升级glibc到2.16.0-2，我必须把linux的内核模块从&lt;code&gt;/lib/modules&lt;/code&gt;迁移到&lt;code&gt;/usr/lib/modules&lt;/code&gt;，由于&amp;gt;=3.3.8的内核在我的笔记本上都存在不能关机的问题，因此，我只能重新自行构建我的旧版本linux 3.3.7。但是，为了构建linux，我又必须要依赖于glibc，而事到如今凡是牵涉到glibc的程序，都无法成功编译。这样一来就形成了类似于Catch-22的一种状况。&lt;/p&gt;

&lt;p&gt;我试图退回glibc和所有依赖它的组件到过去的版本，结果发现有些依赖关系是很难逆转的。比如，gcc-libs依赖于glibc&amp;gt;=2.16，然后还有无数软件包依赖于gcc-libs（想都不用想也知道）。glibc本身也依赖于特定的linux-api-headers版本，比如，glibc 2.16.0依赖于linux-api-headers&amp;gt;=3.4。因此，几乎很难对glibc这个东西进行降级。&lt;/p&gt;

&lt;p&gt;退后不行，于是我只能尝试前进，希望新版本的内核解决了不能关机的问题。升级linux到官方的最新版本3.4.5-1（构建时已经使用了&lt;code&gt;/usr/lib/modules&lt;/code&gt;以代替&lt;code&gt;/lib/modules&lt;/code&gt;），glibc于是也就这样成功升级到了2.16.0-2。悲剧的是然后我发现，3.4.5的内核依然存在着不能关机的严重问题。不知道是不是之前升级的&lt;code&gt;kmod 9-2&lt;/code&gt;同样依赖于&lt;code&gt;glibc 2.16.0-2&lt;/code&gt;的更新，最后我更加悲剧地发现，试图重新退回安装linux 3.3.7，在生成内核模块的时候会报错。也就是说，事实上自从我忽略&lt;code&gt;glibc 2.16.0-2&lt;/code&gt;以来的一系列其它没有得到系统警告的更新，不仅使旧版本&lt;code&gt;glibc 2.16.0-1&lt;/code&gt;库有关的编译无法正常进行，也破坏了旧版本3.3.7内核模块的持续性。&lt;/p&gt;

&lt;p&gt;重启，内核模块错误，不能进入系统。于是，不得不进行第三次重装。&lt;/p&gt;

&lt;p&gt;经历过这次glibc的&lt;code&gt;/lib&lt;/code&gt;位置升级、相应一系列包的升级与旧版本linux不兼容所导致的灾难，我终于意识到了Arch这种滚动升级方式带来的稳定性缺陷，并且面临着两种选择：一、迁移到Debian或者Fedora的稳定版本，虽然可能每年发布新版本需要重装一次，但是比起玩Arch半年就因为升级出故障重装三次要好的多；二、借助Arch Rollback Machine，安装一个处于linux 3.3.7版本时间点的系统，软件包不是最新，但是也绝对算不上过时，至少可以先稳定地用上一阵子，不用再受到每天&lt;code&gt;pacman -Syu&lt;/code&gt;一次的诱惑，也不会在手头正忙得要死的时候因为无意升级了一下系统结果把Arch搞崩溃，不得不停下要做的事去修复（甚至重装）系统。&lt;/p&gt;

&lt;p&gt;最终，我选择了后一种。嗯。但是，事情还远没有结束。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;未来可能会折腾的发行版&lt;/h2&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Fedora_(operating_system)&quot;&gt;Fedora&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;实际上Fedora 16曾经在我的硬盘里呆过一段时间。不得不说，在我Arch内核崩溃无法启动的时候，作为硬盘上的备用系统它发挥过很大的作用。&lt;/p&gt;

&lt;p&gt;不过比较糟糕的是我装的是32位的Fedora，所以无法chroot进64位的Arch……结论是以后装双Linux要么都用32位，要么都用64位。&lt;/p&gt;

&lt;p&gt;Fedora的两点好处，一是同样具有强大的技术社群（如今Linux的很大一部分都是RedHat那帮人的贡献），可以和Gentoo、Arch和Debian相媲美；二是软件包更新很快（和Debian相比而言）。从我个人的角度来说，Fedora预设的桌面环境是GNOME 3，这也是一个额外的好处。（预设KDE的发行版我应该不会再产生兴趣了……）&lt;/p&gt;

&lt;p&gt;上一次Arch玩坏之后我曾经试图转向Fedora 17，图形化安装界面很舒服，结果安装过程进行中突然提示我“文件系统不能正确创建，需要在其他系统下进行修复”什么的，然后就自动帮我重启了（而且是在我把原来的硬盘分区连同&lt;code&gt;/boot&lt;/code&gt;都清干净了之后……）汗。对我来说这种“用户友好”可能做得有点过头了。&lt;/p&gt;

&lt;p&gt;结果还是没发现文件系统有什么问题，之后在同一个分区上装Arch好好的。暂时不会再考虑Fedora了。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Debian&quot;&gt;Debian&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;准备在下一次Arch崩溃之后换到Debian。（Debian也许是所有厌倦了无止尽折腾的用户的最终归宿？）&lt;/p&gt;

&lt;p&gt;唯一一次接触Debian是前一阵子参加ICFP的比赛，官方提供的用于测试程序的6.0 squeeze虚拟机镜像。（结果被很多参赛队伍抱怨Debian稳定版提供的包太老旧了……于是后来就改成了允许使用wheezy的软件库）&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>Arch Linux Rollback安装笔记</title>
        <link href="http://www.soimort.org/posts/114" />
        <updated>2012-07-23T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/114/arch-rollback</id>
        <content type="html">&lt;p&gt;本文依照我至今为止四次在Dell Latitude E6420笔记本上安装Arch Linux的过程中所记录的零碎笔记整理而成。&lt;/p&gt;

&lt;p&gt;本文之所以存在，目的是作为个人备忘，以便将来再次把系统玩崩溃重装时参考（毕竟纸上写的笔记不易整理和保存）。第一不追求什么逻辑性，第二不追求技术上的正确性。&lt;/p&gt;

&lt;p&gt;在本文写作时，Arch的&lt;a href=&quot;http://www.archlinux.org/news/install-media-20120715-released/&quot;&gt;2012.07.15版镜像&lt;/a&gt;刚好发布。但文中的安装方式依然基于&lt;a href=&quot;http://www.archlinux.org/news/20110819-installation-media/&quot;&gt;2011.08.19版镜像&lt;/a&gt;，原因很简单：自从Linux 3.3.7之后的内核，在Dell Latitude E6420上无法正常关机和重启，经验证内核参数&lt;code&gt;reboot=pci&lt;/code&gt;也不能解决该问题。2012.07.15包含3.4.4版的内核，故无法在我当前的笔记本上使用。&lt;/p&gt;

&lt;p&gt;但是，由于2011.08.19版的软件库略显陈旧，本文采取了使用rollback到3.3.8发布之前的时间点、即2012年6月8日的Arch软件库的安装方式。感谢伟大的&lt;a href=&quot;http://arm.konnichi.com/&quot;&gt;ARM（Arch Rollback Machine）&lt;/a&gt;为此提供了可能。&lt;/p&gt;

&lt;p&gt;需要注意的是，在初始安装阶段我仍然使用了2011.08.19提供的AIF（Arch Installation Framework）方式。在最新的2012.07.15光盘镜像中，官方已经放弃了对AIF的支持，取而代之以若干辅助安装的Bash脚本。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;1. 准备阶段&lt;/h2&gt;

&lt;h3&gt;1.1. 下载镜像文件&lt;/h3&gt;

&lt;p&gt;下载Arch的“Current Release”：2011.08.19的&lt;a href=&quot;http://www.archlinux.org/download/&quot;&gt;Core Image&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不能用Netinstall Image，因为在安装阶段有可能会意外地连不上Custom的ARM服务器，这样一来就只能通过官方的最新镜像来安装，于是后面降级就会遇到困难。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（注：随着2012.07.15的发布，如今所有archlinux-2011.08.19的iso文件都已经从官方源中消失了。）&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;1.2. 创建可引导的U盘&lt;/h3&gt;

&lt;p&gt;使用&lt;a href=&quot;http://www.linuxliveusb.com/&quot;&gt;LinuxLive USB Creator&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;UNetbootin现在变得不太靠谱，某些发行版的镜像写进去引导不了（这其中包括Arch），故不推荐。&lt;/p&gt;

&lt;p&gt;Win32 Image Writer和dd for windows具有极大的危险性，用来处理U盘没问题，如果用它来处理移动硬盘的某个分区可能会导致整个移动硬盘的分区表被破坏！（参见我的&lt;a href=&quot;http://blog.soimort.org/2012/04/archcodejam.html&quot;&gt;惨痛教训&lt;/a&gt;）LinuxLive和UNetbootin都可以用来写入镜像到单独的移动硬盘分区。&lt;/p&gt;

&lt;h3&gt;1.3. 重启，从U盘引导进入用于安装的核心系统&lt;/h3&gt;

&lt;hr&gt;

&lt;h2&gt;2. 初始安装阶段&lt;/h2&gt;

&lt;h3&gt;2.1. 卸载PC扬声器模块（可选）&lt;/h3&gt;

&lt;p&gt;就是控制台下每次按错键都会发出的“哔——哔”警告声，这玩意实在是太吵了。我每次都首先把它关掉。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# rmmod pcspkr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2. 改变键盘布局和控制台字体（可选）&lt;/h3&gt;

&lt;p&gt;如果一定要使用非英语的键盘布局（比如瑞典语键盘什么的），可以通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# km
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来设置。控制台字体这东西改不改个人觉得意义不大，反正文本终端下的点阵字体都一样丑。&lt;/p&gt;

&lt;h3&gt;2.3. 查看官方安装手册（可选）&lt;/h3&gt;

&lt;p&gt;Alt+F2打开新的虚拟控制台，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# less /usr/share/aif/docs/official_installation_guide_en
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Alt+F1返回原控制台。&lt;/p&gt;

&lt;h3&gt;2.4. 进入AIF安装框架&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# /arch/setup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Alt+F7可以随时查看安装过程中的控制台输出，Alt+F1返回。&lt;/p&gt;

&lt;h3&gt;2.5. Select source / 选择源&lt;/h3&gt;

&lt;p&gt;选择core-local一项即可。&lt;/p&gt;

&lt;h3&gt;2.6. Select editor / 选择编辑器&lt;/h3&gt;

&lt;p&gt;选择nano或vi。&lt;/p&gt;

&lt;h3&gt;2.7. Set clock / 设置时钟&lt;/h3&gt;

&lt;p&gt;为了避免不必要的混乱，推荐把Linux下的硬件时钟模式设置为UTC（时区设成自己当前的时区就可以），Windows下亦统一使用UTC作为当前时区（反正Windows不是有世界时钟的桌面小插件嘛）。&lt;/p&gt;

&lt;h3&gt;2.8. Prepare hard drive(s) / 准备硬盘&lt;/h3&gt;

&lt;p&gt;选择“3 Manually configure block devices, filesystems and mountpoints”。&lt;/p&gt;

&lt;p&gt;使用dev识别设备分区，好处是名称容易记住（&lt;code&gt;/dev/sda3&lt;/code&gt;之类），缺点是将来内核升级的时候设备名有可能会变化。&lt;/p&gt;

&lt;p&gt;uuid难以被人类记住，好处是它不会随着内核的升级改变（但重新格式化分区仍然会改变该分区的uuid）。使用label则意味着必须给每个分区定一个卷标且在将来不能轻易修改。&lt;/p&gt;

&lt;p&gt;选择用于安装Arch的硬盘分区和挂载点，最少仅需要一个用于挂载&lt;code&gt;/&lt;/code&gt;的分区。根据实际情况可以增加单独的&lt;code&gt;/boot&lt;/code&gt;、&lt;code&gt;/tmp&lt;/code&gt;、&lt;code&gt;/usr&lt;/code&gt;、&lt;code&gt;/var&lt;/code&gt;分区和swap交换分区。如果想要用作&lt;code&gt;/home&lt;/code&gt;的分区原来保存有重要数据的话，安全起见这里可以先不用设置&lt;code&gt;/home&lt;/code&gt;的挂载分区（以后再手动改fstab）。&lt;/p&gt;

&lt;p&gt;AIF里只能把已有的分区格式化。调整分区大小、划分新的分区等工作应当在安装前使用cfdisk、GParted等工具完成。&lt;/p&gt;

&lt;h3&gt;2.9. Select packages / 选择软件包&lt;/h3&gt;

&lt;h4&gt;2.9.1. Select bootloader / 选择启动引导器&lt;/h4&gt;

&lt;p&gt;选择bootloader，这里是GRUB Legacy和syslinux。先选GRUB Legacy，以后再升级。（如果以前的系统有单独的&lt;code&gt;/boot&lt;/code&gt;分区和现成的bootloader，则可跳过此步）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（注：最新的2012.07.15应该已经用GRUB 2取代了GRUB Legacy）&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;2.9.2. Select package groups / 选择软件包组&lt;/h4&gt;

&lt;p&gt;选择base。base-devel包含开发工具。先选，以后再升级。&lt;/p&gt;

&lt;h4&gt;2.9.3. Select packages / 选择软件包&lt;/h4&gt;

&lt;p&gt;不用选了直接确认。以后再安装。&lt;/p&gt;

&lt;h3&gt;2.10. Install packages / 安装软件包&lt;/h3&gt;

&lt;p&gt;等待。（安装过程很快）&lt;/p&gt;

&lt;h3&gt;2.11. Configure system / 配置系统&lt;/h3&gt;

&lt;h4&gt;2.11.1. /etc/rc.conf（系统基础设置）&lt;/h4&gt;

&lt;p&gt;比较重要的有两件事。一是设置HOSTNAME：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;HOSTNAME=&amp;quot;Foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常情况下使用动态地址分配（DHCP）上网，需要设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;interface=eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他的配置选项（如HARDWARECLOCK、TIMEZONE、LOCALE、KEYMAP、DAEMONS）已经自动生成，这里暂时无须修改。&lt;/p&gt;

&lt;h4&gt;2.11.2. /etc/fstab（文件系统挂载点）&lt;/h4&gt;

&lt;p&gt;假定某分区设备名为&lt;code&gt;/dev/sda9&lt;/code&gt;，使用ext4文件系统，挂载到&lt;code&gt;/home&lt;/code&gt;，则增加一行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;/dev/sda9 /home ext4 defaults 0 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.11.3. /etc/mkinitcpio.conf&lt;/h4&gt;

&lt;p&gt;暂时无须修改。&lt;/p&gt;

&lt;h4&gt;2.11.4. /etc/modprobe.d/modprobe.conf（内核模块黑名单）&lt;/h4&gt;

&lt;p&gt;暂时无须修改。也可以直接在这一步里屏蔽掉不想要的内核模块（例如pcspkr）。&lt;/p&gt;

&lt;h4&gt;2.11.5. /etc/resolv.conf&lt;/h4&gt;

&lt;p&gt;若使用DHCP则无须修改。dhcpcd每次会自动写入相应的DNS服务器地址。&lt;/p&gt;

&lt;h4&gt;2.11.6. /etc/hosts&lt;/h4&gt;

&lt;p&gt;已经自动生成，最好确认一下这里的hostname与前面&lt;code&gt;/etc/rc.conf&lt;/code&gt;中的设置是否一致。&lt;/p&gt;

&lt;h4&gt;2.11.7. /etc/locale.gen（本地化设置）&lt;/h4&gt;

&lt;p&gt;通过去除注释选择想要的本地化类型（用于glibc等支持本地化的软件包）。&lt;/p&gt;

&lt;p&gt;可以在以后再修改并使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# locale-gen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成。通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# locale -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看所有当前可用的本地化类型。&lt;/p&gt;

&lt;h4&gt;2.11.8. /etc/pacman.conf（Pacman设置）&lt;/h4&gt;

&lt;p&gt;这里暂时不要做任何修改（后面会对pacman进行升级）。&lt;/p&gt;

&lt;h4&gt;2.11.9. /etc/pacman.d/mirrorlist（镜像设置）&lt;/h4&gt;

&lt;p&gt;这一步非常重要。注释掉其他所有行，添加一行ARM的源地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;Server = http://arm.konnichi.com/2012/06/08/$repo/os/$arch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;http://arm.konnichi.com&lt;/code&gt;后面的URL显示了想要rollback到的时间点。&lt;/p&gt;

&lt;h4&gt;2.11.10. 设置root密码&lt;/h4&gt;

&lt;h3&gt;2.12. Install bootloader / 安装启动引导器&lt;/h3&gt;

&lt;p&gt;若使用GRUB Legacy，&lt;code&gt;/boot/grub/menu.lst&lt;/code&gt;会被自动生成，只需确认一下即可。&lt;/p&gt;

&lt;p&gt;安装到&lt;code&gt;/dev/sda&lt;/code&gt;（硬盘设备）。&lt;/p&gt;

&lt;h3&gt;2.13. 重启，引导进入硬盘上的Arch系统&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;3. 升级阶段&lt;/h2&gt;

&lt;h3&gt;3.1. 检测网络是否正常（适用于DHCP）&lt;/h3&gt;

&lt;p&gt;检测IP地址：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# ip addr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检测网络连通：（是否能连接上ARM的服务器）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# ping -c 3 arm.konnichi.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如遇到问题可以使用&lt;code&gt;# /etc/rc.d/network restart&lt;/code&gt;和&lt;code&gt;# dhcpcd eth0&lt;/code&gt;重启网络（如果之前&lt;code&gt;/etc/rc.conf&lt;/code&gt;设置正确，&lt;code&gt;interface=eth0&lt;/code&gt;，MODULES中包含有network一项，则dhcpcd应当能够正常工作）&lt;/p&gt;

&lt;h3&gt;3.2. 开始升级软件包&lt;/h3&gt;

&lt;p&gt;由于当前系统的软件包过于老旧，全系统升级的命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Syu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会导致一些依赖性问题，故不要使用。我们将逐一升级系统中的软件包。&lt;/p&gt;

&lt;h3&gt;3.3. 升级pacman数据库&lt;/h3&gt;

&lt;p&gt;首先执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Syy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从ARM获取目标时间点的软件包数据库。&lt;/p&gt;

&lt;h3&gt;3.4. 升级pacman&lt;/h3&gt;

&lt;p&gt;然后便可以升级pacman自身：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Sf pacman
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此命令会同时升级glibc、linux-api-headers等依赖库。-f命令行参数是必须的。&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;/etc/pacman.conf.pacnew&lt;/code&gt;生成则拿它覆盖掉原有的&lt;code&gt;/etc/pacman.conf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官方的说明提示是通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman-key --init
# pacman-key --populate archlinux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来创建初始密钥。这并不适用于我们从ARM获取的软件包，所以为了避开Pacman 4这套新引入的签名验证机制，直接在&lt;code&gt;/etc/pacman.conf&lt;/code&gt;里使用如下配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;SigLevel = Optional TrustAll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时通过去除注释打开&lt;code&gt;[multilib]&lt;/code&gt;（如果在x86_64的Arch下需要用到32位库的话，multilib里的许多包至关重要）。&lt;/p&gt;

&lt;p&gt;重新执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Syy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以获取属于multilib的软件包数据库。&lt;/p&gt;

&lt;h3&gt;3.5. 升级kmod&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S kmod
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以取代原有的module-init-tools。&lt;/p&gt;

&lt;h3&gt;3.6. 升级systemd-tools&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Sf systemd-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以取代原有的udev。此命令会同时升级hwid等依赖库。-f命令行参数是必须的。&lt;/p&gt;

&lt;h3&gt;3.7. 升级initscripts&lt;/h3&gt;

&lt;p&gt;通过升级kmod和systemd-tools，我们已经完成了对initscripts依赖的升级。&lt;/p&gt;

&lt;p&gt;现在升级&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Sf initscripts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启之后Linux启动阶段sysctl会提示出现奇怪的“&lt;code&gt;-p/etc/sysctl.conf&lt;/code&gt;参数错误”。&lt;/p&gt;

&lt;p&gt;这个问题仿佛是从&lt;code&gt;initscripts-2012.05.1-1&lt;/code&gt;开始引入的，直到&lt;code&gt;initscripts-2012.05.1-3&lt;/code&gt;都存在。经检查，发现问题出在&lt;code&gt;/usr/lib/initscripts/arch-sysctl&lt;/code&gt;里面的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;sysctl -q -p&amp;quot;$path&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然原来应该是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;sysctl -q -p &amp;quot;$path&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;和&lt;code&gt;&amp;quot;$path&amp;quot;&lt;/code&gt;之间不知何故少了一个空格（之前的版本一直是有的，不知道为什么到了2012.05.1之后就消失了）。&lt;/p&gt;

&lt;p&gt;解决方法是不要使用当前时间点（2012.06.08）的&lt;code&gt;initscripts-2012.05.1-3&lt;/code&gt;，而使用更新后（2012.06.10）的&lt;code&gt;initscripts-2012.06.1-1&lt;/code&gt;来作升级：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -U http://arm.konnichi.com/2012/06/10/core/os/x86_64/initscripts-2012.06.1-1-any.pkg.tar.xz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级后用&lt;code&gt;/etc/rc.conf.pacnew&lt;/code&gt;来取代原来的&lt;code&gt;/etc/rc.conf&lt;/code&gt;（原来的设置要手动保留）。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;/etc/rc.conf&lt;/code&gt;中的LOCALE设置不再生效，新的LOCALE设置需要在&lt;code&gt;/etc/locale.conf&lt;/code&gt;中进行。&lt;/p&gt;

&lt;h3&gt;3.8. 升级filesystem&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Sf filesystem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.9. 升级linux-firmware&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S linux-firmware
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.10. 升级mkinitscpio&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Sf mkinitcpio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此命令会同时升级util-linux等依赖库。-f命令行参数是必须的。&lt;/p&gt;

&lt;h3&gt;3.11. 升级linux&lt;/h3&gt;

&lt;p&gt;升级mkinitscpio完成后，接下来便可以进行linux内核的升级（旧版本的mkinitscpio无法用于较新的linux，会导致生成内核模块错误无法启动）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.12. 升级其他软件包&lt;/h3&gt;

&lt;p&gt;剩余的软件包可以直接进行全系统升级（dhcpcd除外）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -Syu --ignore dhcpcd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.13. 可能的错误：dhcpcd无法连接IPv4&lt;/h3&gt;

&lt;p&gt;较新版本的dhcpcd会直接使用IPv6，导致用户在仅支持IPv4的情形下无法正常连接到网络。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;dhcpcd[*]: eth0: sending IPv6 Router Solicitation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code&gt;# ip addr&lt;/code&gt;命令显示的eth0没有分配到IPv4地址（inet）。&lt;/p&gt;

&lt;p&gt;如果前一步不慎升级了dhcpcd，则降级到旧版本的dhcpcd可以解决该问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -U http://arm.konnichi.com/2011/08/19/core/os/x86_64/dhcpcd-5.2.12-1-x86_64.pkg.tar.xz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能需要在有网络连接的电脑上手动下载该软件包。&lt;/p&gt;

&lt;h3&gt;3.14. 可能的错误：启动时syslog-ng提示找不到/usr/lib/libpcre.so.0&lt;/h3&gt;

&lt;p&gt;这是由于使用了较旧的pcre库所致。进行了包括pcre在内的全系统升级后重启应该可以消除该错误提示。&lt;/p&gt;

&lt;h3&gt;3.15. 可能的错误：启动时/etc/rc.sysinit提示mountpoint: command not found&lt;/h3&gt;

&lt;p&gt;这是一个非常诡异的错误，在网上可以搜到不少类似的情况，我自己也遇到过两次。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/bin/mountpoint&lt;/code&gt;是包含在util-linux包内的文件，这个包之前是安装过的，在全系统升级之前&lt;code&gt;/bin/mountpoint&lt;/code&gt;也经确认是存在的，但升级之后有可能会神秘消失。原因不明，疑似升级某个包（怀疑是sysvinit？）时导致的bug。&lt;/p&gt;

&lt;p&gt;解决方法是重新安装一遍util-linux：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S util-linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.16. 升级到GRUB 2&lt;/h3&gt;

&lt;p&gt;可以直接使用当前时间点extra库的grub2-bios包进行升级（会移除已有的grub包）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S grub2-bios
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用最新的grub-bios进行升级（已移到core库）。手动从镜像下载grub-bios、grub-common、freetype2和fuse这四个包进行安装（后两个包属于extra库）。&lt;/p&gt;

&lt;h3&gt;3.17. 安装GRUB 2&lt;/h3&gt;

&lt;p&gt;升级到GRUB 2必须执行以下的手动安装步骤（即使&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;已经存在）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# grub-mkconfig -o /boot/grub/grub.cfg
# grub-install /dev/sda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要对GRUB进行配置（例如添加Windows引导选项，修改GRUB颜色、背景主题），可以修改&lt;code&gt;/etc/default/grub&lt;/code&gt;和&lt;code&gt;/etc/grub.d/40_custom&lt;/code&gt;这两个文件，然后通过执行&lt;code&gt;# grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt;重新生成新的&lt;code&gt;grub.cfg&lt;/code&gt;。不要直接去修改&lt;code&gt;grub.cfg&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;3.18. 重启，确认GRUB 2引导正常&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此，得到了一个较新的最小化系统。&lt;/p&gt;

&lt;h3&gt;3.19. 可能的错误：GRUB进入引导界面前一闪而过的错误提示：error: file &amp;#39;/boot/grub/locale/en.mo.gz&amp;#39; not found&lt;/h3&gt;

&lt;p&gt;直接拷贝如下文件即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# cp /boot/grub/locale/en@quot.mo /boot/grub/locale/en_US.mo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.20. 附：GRUB的手动引导&lt;/h3&gt;

&lt;p&gt;如果忘记在GRUB 2中写入某OS的引导选项或者引导选项错误，需要手动引导则可以简单地使用类似如下命令（假设要引导的是位于分区表第5个分区上的Arch Linux）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt; insmod ext2
&amp;gt; set root=&amp;#39;hd0,msdos5&amp;#39;
&amp;gt; linux /boot/vmlinuz-linux
&amp;gt; initrd /boot/initramfs-linux.img
&amp;gt; boot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若要引导的是位于分区表的第2个分区上的Windows：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt; insmod ntfs
&amp;gt; set root=&amp;#39;hd0,msdos2&amp;#39;
&amp;gt; chainloader +1
&amp;gt; boot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若使用GRUB Legacy，与之类似（注意GRUB Legacy的设备编号从0开始，即第2个分区实际上是&lt;code&gt;(hd0,1)&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;&amp;gt; root (hd0,1)
&amp;gt; chainloader +1
&amp;gt; boot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;4. 配置阶段&lt;/h2&gt;

&lt;h3&gt;4.1. 添加控制台下的鼠标支持（可选）&lt;/h3&gt;

&lt;p&gt;如果需要经常在控制台下进行工作，添加鼠标支持可能会比较有用。&lt;/p&gt;

&lt;p&gt;安装GPM：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S gpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时在&lt;code&gt;/etc/rc.conf&lt;/code&gt;中添加相应启动守护进程：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;DAEMONS=(... gpm)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2. 设置模块黑名单（可选）&lt;/h3&gt;

&lt;p&gt;有些内核模块可能并不总是我们需要的。对于我而言，PC扬声器和触摸板属于“完全没用”之列。（PC扬声器的报警声很烦人；触摸板会严重干扰键盘输入）&lt;/p&gt;

&lt;p&gt;我曾经花了很长时间寻找我的笔记本上触摸板属于哪个驱动，结果发现是psmouse模块。&lt;/p&gt;

&lt;p&gt;以前可以通过&lt;code&gt;/etc/rc.conf&lt;/code&gt;中的MODULES变量屏蔽模块。现在唯一的方式是在&lt;code&gt;/etc/modprobe.d/modprobe.conf&lt;/code&gt;（如果没有则创建）中设置黑名单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;blacklist pcspkr
blacklist psmouse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将来临时需要用到这些模块时，可以手动加载：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# modprobe psmouse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要时再卸载：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# rmmod psmouse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.3. NTFS分区的读写支持&lt;/h3&gt;

&lt;p&gt;安装NTFS-3G：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S ntfs-3g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;/etc/fstab&lt;/code&gt;中挂载NTFS分区时，应当使用ntfs-3g而不是ntfs。&lt;/p&gt;

&lt;h3&gt;4.4. 添加用户、设置权限&lt;/h3&gt;

&lt;p&gt;总是用root账户来执行日常操作是不可取的。应当添加一个自己的用户：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# adduser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意把用户添加到合适的组（audio, games, lp, optical, power, scanner, storage, video, wheel）。&lt;/p&gt;

&lt;p&gt;如果忘记添加到某个组，以后可以直接编辑&lt;code&gt;/etc/group&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后为了使用户可以执行sudo操作，还需安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S sudo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# visudo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来编辑用户的sudo权限（实际上是&lt;code&gt;/etc/sudoers&lt;/code&gt;这个文件）。可以将&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;root ALL=(ALL) ALL
%wheel ALL=(ALL) ALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两行去注释。&lt;/p&gt;

&lt;p&gt;注意：非root用户执行某些程序必须使用sudo，否则不会报错但无法正常使用，例如util-linux中的fdisk、cfdisk。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;5. 桌面阶段&lt;/h2&gt;

&lt;h3&gt;5.1. 安装常用字体&lt;/h3&gt;

&lt;p&gt;安装一些常用的字体（后者“文泉驿正黑”提供必要的中文支持）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S ttf-dejavu wqy-zenhei
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以安装opendesktop-fonts等其他字体。&lt;/p&gt;

&lt;h3&gt;5.2. 安装显卡驱动、3D支持和Xorg&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S xf86-video-intel mesa mesa-demos xorg-server xorg-xinit xorg-utils xorg-server-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以直接安装Xorg全部组件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S xorg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了测试X，需要有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S xorg-twm xorg-xclock xterm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# startx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# xinit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入TWM窗口管理器，测试X是否运行正常。&lt;/p&gt;

&lt;p&gt;如果当前用户主目录下有&lt;code&gt;~/.xinitrc&lt;/code&gt;，则启动时会读取此文件内容。xinit可以向该脚本传递参数。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;# exit&lt;/code&gt;或&lt;code&gt;# pkill X&lt;/code&gt;退出X。（后者会报出一个运行错误）&lt;/p&gt;

&lt;h3&gt;5.3. 安装声卡设备驱动&lt;/h3&gt;

&lt;p&gt;默认的Arch内核构建里已经包含了ALSA，故一般没有必要再安装它。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S alsa-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装后通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# alsamixer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来取消静音。可以使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# speaker-test -c 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行测试。&lt;/p&gt;

&lt;h3&gt;5.4. 安装电源管理框架&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S pm-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用于在命令行下休眠和进入省电模式。&lt;/p&gt;

&lt;h3&gt;5.5. 安装Openbox桌面管理器（可选）&lt;/h3&gt;

&lt;p&gt;安装Openbox：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S openbox
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Openbox的配置位于&lt;code&gt;~/.config/openbox&lt;/code&gt;下的&lt;code&gt;menu.xml&lt;/code&gt;、&lt;code&gt;rc.xml&lt;/code&gt;、&lt;code&gt;autostart&lt;/code&gt;三个文件。&lt;/p&gt;

&lt;p&gt;其他配置桌面可能会用到的组件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S obconf obmenu menumaker openbox-themes xcompmgr xscreensaver feh conky tint2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tint2的图形化配置程序tint2conf需要pygtk：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S pygtk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装D-Bus和ConsoleKit：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S dbus consolekit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;必须在&lt;code&gt;/etc/rc.conf&lt;/code&gt;中添加相应的守护进程：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;DAEMONS=(... dbus)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建&lt;code&gt;~/.xinitrc&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;tint2 &amp;amp;
exec ck-launch-session dbus-launch --sh-syntax --exit-with-session openbox-session
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# startx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# xinit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入Openbox（附带启动tint2）。&lt;/p&gt;

&lt;h3&gt;5.6. 安装GNOME（可选）&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S gnome gnome-extra
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要想在系统启动完毕后自动进入图形界面，修改&lt;code&gt;/etc/inittab&lt;/code&gt;中的运行级即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# Boot to console
#id:3:initdefault:
# Boot to X11
id:5:initdefault:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且设置登录管理器为GDM：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;x:respawn:/usr/sbin/gdm -nodaemon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要在GDM启动时同时启动其他组件（例如tint2），则在&lt;code&gt;~/.xprofile&lt;/code&gt;中（注意不是&lt;code&gt;~/.xinitrc&lt;/code&gt;）添加：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;tint2 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.7. 安装PolicyKit和NetworkManager&lt;/h3&gt;

&lt;p&gt;若使用Openbox：安装polkit和networkmanager以在桌面环境下取代network管理网络：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S networkmanager
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;polkit作为依赖会被自动安装。&lt;/p&gt;

&lt;p&gt;若使用GNOME，则networkmanager（和dbus、polkit）很可能已经作为依赖被安装。&lt;/p&gt;

&lt;p&gt;需要手动在&lt;code&gt;/etc/rc.conf&lt;/code&gt;中删除network守护进程，添加：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;DAEMONS=(... dbus networkmanager)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意networkmanager必须出现在dbus之后。&lt;/p&gt;

&lt;h3&gt;5.8. 调整键盘映射（可选）&lt;/h3&gt;

&lt;p&gt;有时候可能需要修改键盘上某些键的位置。&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# xmodmap -pke &amp;gt; ~/.Xmodmap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成映射表文件并进行修改。&lt;/p&gt;

&lt;p&gt;若使用Openbox，在&lt;code&gt;~/.xinitrc&lt;/code&gt;中启动窗口管理器的命令前添加一行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;xmodmap $HOME/.Xmodmap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若使用GNOME，则xmodmap会在进入X时自动应用用户主目录下的&lt;code&gt;~/.Xmodmap&lt;/code&gt;映射表。&lt;/p&gt;

&lt;h3&gt;5.9. 安装iBus输入法&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;# pacman -S ibus ibus-qt ibus-pinyin ibus-anthy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若使用Openbox，在&lt;code&gt;~/.xinitrc&lt;/code&gt;中启动窗口管理器前添加一行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;ibus-daemon -x -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若使用GNOME，则ibus-daemon会在进入X时自动启动，不需要修改任何配置文件。&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;6. 常见问题&lt;/h2&gt;

&lt;h4&gt;Linux下写入NTFS分区里的内容在重启进入Windows后消失了&lt;/h4&gt;

&lt;p&gt;Windows休眠到硬盘后，不要在Linux下对相应的NTFS分区进行写操作。&lt;/p&gt;

&lt;h4&gt;启动时sdhci-pci提示“Invalid iomem size. You may experience problems.”&lt;/h4&gt;

&lt;p&gt;最简单的解决办法是禁用sdhci和sdhci_pci模块，在&lt;code&gt;/etc/modprobe.d/modprobe.conf&lt;/code&gt;中添加黑名单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;blacklist sdhci
blacklist sdhci_pci
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;禁用IPv6&lt;/h4&gt;

&lt;p&gt;在内核加载时直接禁用。在&lt;code&gt;/etc/modprobe.d/modprobe.conf&lt;/code&gt;中添加一行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;alias net-pf-10 off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;明明是可执行文件双击后却没反应，命令行下执行却提示文件找不到&lt;/h4&gt;

&lt;p&gt;如果权限没问题的话，这可能是试图在x86_64系统上执行32位程序却缺少相应库所导致的。&lt;/p&gt;

&lt;p&gt;用ldd查看该文件是否“not a dynamic executable”。如果是，安装multilib中的各种32位库，也可以直接安装wine（wine的依赖关系基本包含了所有常用的32位库）。&lt;/p&gt;

&lt;h4&gt;RAR格式文件打不开&lt;/h4&gt;

&lt;p&gt;安装p7zip。&lt;/p&gt;

&lt;h4&gt;需要更多有用的GNOME设置&lt;/h4&gt;

&lt;p&gt;安装gnome-tweak-tool。&lt;/p&gt;

&lt;h4&gt;GDM和GNOME使用X11光标而不是GNOME的光标样式&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;/usr/share/icons/default/index.theme&lt;/code&gt;中写入：（如果不存在则创建）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;[Icon Theme]
Inherits=Adwaita
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接从AUR安装&lt;a href=&quot;https://aur.archlinux.org/packages.php?ID=52925&quot;&gt;gnome-cursors-fix&lt;/a&gt;这个包。&lt;/p&gt;

&lt;h4&gt;iBus输入法不能输入，总是显示“No input window”&lt;/h4&gt;

&lt;p&gt;记得要在ibus-setup的Preferences - Input Method中手动添加已安装的输入法（它们不会自动出现在列表中），然后重启iBus。&lt;/p&gt;

&lt;h4&gt;GNOME集成的即时通讯工具不能用，总是显示一个叉&lt;/h4&gt;

&lt;p&gt;安装telepathy。&lt;/p&gt;

&lt;h4&gt;从GNOME登录Google帐号的时候总提示密码错误&lt;/h4&gt;

&lt;p&gt;说明你开通了Google的双步验证机制。不要使用Google帐号的密码，而使用Google提供的Application-specific password就好了。（其实App Engine和Google Talk也都是使用这个密码的）&lt;/p&gt;

&lt;h4&gt;浏览器无法播放Flash&lt;/h4&gt;

&lt;p&gt;安装flashplugin。&lt;/p&gt;

&lt;p&gt;适用于Chromium和Firefox，但是不知为何GNOME Web并不支持。&lt;/p&gt;

&lt;h4&gt;某些CJK字体无法正常显示出来&lt;/h4&gt;

&lt;p&gt;安装opendesktop-fonts。注意：会覆盖原来的文泉驿字体。&lt;/p&gt;

&lt;h4&gt;VLC播放视频时画面和音轨略不同步&lt;/h4&gt;

&lt;p&gt;这是PulseAudio自2.0以来引入的一个bug（特性？），目前好像只针对VLC存在，其他播放器正常。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bugs.freedesktop.org/show_bug.cgi?id=50024&quot;&gt;https://bugs.freedesktop.org/show_bug.cgi?id=50024&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以退回到2.0以前的pulseaudio和libpulse，或者使用我自己的一个PulseAudio fork：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/pulseaudio-vlc-friendly&quot;&gt;https://github.com/soimort/pulseaudio-vlc-friendly&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;GitHub网页上的字体貌似比起以前有明显的锯齿失真（？）&lt;/h4&gt;

&lt;p&gt;但愿这不是我的错觉。&lt;/p&gt;

&lt;p&gt;降级ttf-freefont到版本20100919-2。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>关于Richard Stallman的若干惊人事实</title>
        <link href="http://www.soimort.org/posts/113" />
        <updated>2012-07-19T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/113/rms-facts</id>
        <content type="html">&lt;p&gt;今天在GNU Octave里无意把算阶乘的&lt;code&gt;factorial()&lt;/code&gt;弄成了&lt;code&gt;fact()&lt;/code&gt;，于是发现混进来了神马奇怪的东西：&lt;/p&gt;

&lt;p&gt;“关于世界上最伟大的黑客的惊人事实”，搜索了一下发现这些段子来自一个网站叫&lt;a href=&quot;http://stallmanfacts.com/&quot;&gt;stallmanfacts.com&lt;/a&gt;。目睹了整个事件的刘先生称从未见过这么无聊的网站……&lt;/p&gt;

&lt;p&gt;以下内容均来源于该处，版权不知道归谁所有。（括号内是翻译君自带吐槽）&lt;/p&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RMS means &amp;quot;RMS Means Stallman&amp;quot;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman不洗澡是因为水力发电公司运行的是专有软件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的胡子是由括号构成的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman从来不用洗澡；他只需要运行“make clean”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman通过把一切都变得free而解决了旅行推销员问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Richard Stallman被惹恼时，他不是咒骂，而是递归诅咒（recurses）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的左手和右手分别命名为“(”和“)”。&lt;br&gt;
&lt;em&gt;（mort: Lisp程序员有勤劳的双手……）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman用Emacs写出了Emacs的第一版。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些人检查他们的电脑里是否有病毒。病毒检查他们的电脑里是否有Richard Stallman。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在一间普通的客厅里有1242件物体可以被RMS用来写一个操作系统，包括这房间本身。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman可以用telnet进入魔多。&lt;br&gt;
&lt;em&gt;（mort: 然后发送一个请求 GET /The\&lt;/em&gt;Ring http/1.1）_&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman从不理发，因为没有GNU/剪刀。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的读法是“GNU slash Stallman”。&lt;br&gt;
&lt;em&gt;（mort: 不要忘了Stallman是基于glibc才能运行的啊魂淡！）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Richard Stallman还是个学数手指的小毛孩时，他总是从0开始数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Stallman不去kill一个进程，他只想看它是否胆敢继续运行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Richard Stallman指向（point at）一台Windows电脑时，它就会出现段错误。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman最初的话语是syscalls（系统调用）。&lt;br&gt;
&lt;em&gt;（mort: 据考证&amp;quot;Let there be light&amp;quot;是上帝fork()出来的最初的子进程）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Stallman之所以存在是因为他把自己编译成了生命体。&lt;br&gt;
&lt;em&gt;（mort: 这到底要如何bootstrap？）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman是他自己在Emacs里用Lisp语言编写成的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman能够通过Emacs的ssh客户端程序连接到任何大脑。&lt;br&gt;
&lt;em&gt;（mort: Ghost in the Shell……未来的公安9课靠你们了……）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Richard Stallman使用浮点数时，它们便没有舍入误差。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RMS不用维护代码。他注视着它们，直到它们带着敬仰改正自己的错误。&lt;br&gt;
&lt;em&gt;（mort: 开源运动史的《旧约：出埃及记》）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman不对开源项目作出贡献；开源项目对Richard Stallman作出贡献。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的胡须里面不是下巴，而是另一撮胡须。如此递归直至无穷。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman曾经得过猪流感，但是该病毒很快被GPL污染并且同化了。&lt;br&gt;
&lt;em&gt;（mort: 看来GPL是种卫星病毒……）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无论何时世界上有人写出一个“Hello, world”程序，Richard Stallman总以“Hello”回应。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman从不编译，他只要闭上眼睛，就能看见编译器优化时二进制位之间的能量流动被创造出来……&lt;br&gt;
&lt;em&gt;（mort: 拉普拉斯妖= =）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果Richard Stallman有一个1GB的内存，你有一个1GB的内存，那么Richard Stallman拥有比你更多的内存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Richard Stallman执行&lt;code&gt;ps -e&lt;/code&gt;时，你的名字会出现。&lt;br&gt;
&lt;em&gt;（mort: 他果然就是矩阵的architect……）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从来就没有软件开发过程这回事，只有被Richard Stallman允许存在的一些程序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的DNA中包含调试符号。尽管他从不需要它们。&lt;br&gt;
&lt;em&gt;（mort: 个人最喜欢的一句）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman的医生能通过CVS采集他的血样。&lt;br&gt;
&lt;em&gt;（mort: 建议改用Git，不然万一中心服务器挂了怎么办？）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Richard Stallman来说，多项式时间就是&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman将会使可口可乐在GPL协议下公布他们的配方。&lt;br&gt;
&lt;em&gt;（mort: 希望天朝食物的化学成分能尽早实现开源化）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman不需要用鼠标或键盘来操作计算机。他只要凝视着它，直到它完成想要的工作。&lt;br&gt;
&lt;em&gt;（mort: Do not try to master the computer - that&amp;#39;s impossible. Instead, only try to realize the truth: there is no computer.）&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Richard Stallman就是图灵测试的解答。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】承认吧，函数式编程可能是笨拙的</title>
        <link href="http://www.soimort.org/posts/112" />
        <updated>2012-07-12T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/112/functional-programming</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://prog21.dadgum.com/3.html&quot;&gt;Admitting that Functional Programming Can Be Awkward&lt;/a&gt;
by &lt;a href=&quot;http://prog21.dadgum.com/&quot;&gt;James Hague&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;我起初对函数式编程产生兴趣的原因是，它看上去是如此地有悖于常识。&lt;/p&gt;

&lt;p&gt;想当年，我还是一个典型的自学成才式程序员，已经学会了BASIC、之后是6502汇编语言，用来实现我自己的游戏设计。我拿起了1985年8月号的那期&lt;a href=&quot;http://en.wikipedia.org/wiki/Byte_(magazine)&quot;&gt;《字节》&lt;/a&gt;杂志，阅读关于那时相当新潮的Amiga个人电脑。那期杂志恰好也是关于&lt;a href=&quot;http://en.wikipedia.org/wiki/Declarative_language&quot;&gt;声明式语言&lt;/a&gt;的一期，刊登了&lt;a href=&quot;http://en.wikipedia.org/wiki/John_Backus&quot;&gt;Backus&lt;/a&gt;那篇著名的&lt;a href=&quot;http://www.stanford.edu/class/cs242/readings/backus.pdf&quot;&gt;图灵奖演说&lt;/a&gt;的全文，以及一篇&lt;a href=&quot;http://en.wikipedia.org/wiki/Hope_(programming_language)&quot;&gt;Hope语言&lt;/a&gt;的教程，同其他文章一起。&lt;/p&gt;

&lt;p&gt;对于一个Atari 800游戏程序员来说，读这样的材料确确实实相当让人抓狂。我理解了其中的仅仅一部分，完全略过了其他的大块内容，但一个关键的要点激发了我的遐想：不使用可修改的变量而进行编程。那怎么可能做到？我无法在不向内存中存储任何值的情况下写出哪怕最简单的游戏。正是这种看似的“不可能”吸引了我，正如我当初听说汇编语言太难以至于大部分人无法掌握的时候一样。不过，鉴于我已经领略到了杂志上无数一行行用汇编语言写成的游戏代码、并从中学会了编写我自己的游戏，函数式编程却并没有类似这样的直接应用实例。它让我感到惊讶，但我并没有立即去使用它。&lt;/p&gt;

&lt;p&gt;多年之后，当我第一次学习Haskell、Standard ML、最后是Erlang的教程时，我终于了解到了不修改变量的编程方式是怎样运作的。从小的方面讲，这很简单。在1985年尚且显得怪异的东西如今已经变得稀松平常了：垃圾收集；使用复杂数据结构而不用担心内存分配；比C或Pascal拥有更少&lt;a href=&quot;http://en.wikipedia.org/wiki/Bookkeeping_code&quot;&gt;bookkeeping code&lt;/a&gt;的语言；但所谓的“非破坏性更新”——至今仍然——显得有点棘手。&lt;/p&gt;

&lt;p&gt;一件毋庸置疑的事实是，世界上有数以万计的视频游戏使用了命令式编程风格开发，也许只有那么一小撮——甚至可能是屈指可数的——游戏是使用纯粹的函数式风格编写的。当然，是有用Lisp编写的游戏，还有一些是OCaml语言爱好者的得意之作，但它们从未是以函数式风格写成的。在这些语言中，你可以相当轻松地写出命令式的代码。这么做的理由很简单：如何用函数式风格编写各类复杂的应用程序，并不是那么一目了然的一件事。&lt;/p&gt;

&lt;p&gt;通常，我能够解决数据对象之间的依赖关系，而且常常能够找到函数式方法背后内在的简朴性。但是对于其他情况下的应用……嗯，它们将成为难解之谜。用C语言可以稍带混乱但不失高效地解决的地方，纯粹的函数式解决方案要么根本找不到、要么尚需要不少精力方能理清。在这种时候，我感到我像是在和整个系统进行艰苦卓绝的斗争，于是我意识到了为什么它是一条更少被人所选择涉足的道路。不相信是吗？依然认为函数式的纯粹永远是解决问题的不二法门？请看以下简单的例子。&lt;/p&gt;

&lt;p&gt;在这之前，我曾经写过一个马马虎虎算是成功的Mac游戏，叫做Bumbler。在本质上，它与那种常见的标准类型的&lt;a href=&quot;http://en.wikipedia.org/wiki/Sprite_(computer_graphics)&quot;&gt;sprite游戏&lt;/a&gt;并没有什么不同：众多独立的物件，执行着一些控制行为的代码并且能够互相之间进行交互。这一类代码用纯函数式方法写起来很简单。一只蚂蚁，用一个坐标表示，在屏幕上以直线前进，撞上了屏幕边缘就被删除。这很容易看作一个函数。一小块数据被输入，输出则是另一些数据。&lt;/p&gt;

&lt;p&gt;但是行为和互动可能远比这要复杂得多。可能会有一只昆虫去追逐别的昆虫，所以你必须向它传递一个当前存在实体的列表。可能会有一只昆虫能够影响到其他昆虫的繁殖率，当然，你不能直接去修改繁殖率的数值，所以你必须设法返回这类数据。可能会有一只昆虫含住卵就能把它们变成别的什么东西，所以现在需要有一个行为函数能够操纵实体的列表并且做出修改，但你却不被允许去那么做。可能会有一只昆虫能够改变物理环境（也就是，游戏的背景）并且繁殖更多的昆虫。以上的每一种情形实际上都比听起来还要复杂，因为有如此多的计数器、阈值和限制值需要进行管理，加上各种事件发生时的音效播放，整个数据流程无论如何也不能说是一目了然的。&lt;/p&gt;

&lt;p&gt;有趣的是，用C语言来实现这些不过是小事一桩。只需要一些递增，一些条件判断，直接调用播放音效的例程和繁殖昆虫的函数，从全局计数器和状态变量的池中进行读写。如果就纯粹的函数式方法来说，我相信这一数据流程&lt;em&gt;可能&lt;/em&gt;是令人费解的……如果假设一切事物都完美地在计划中进行、所有的行为都提前有所定义的话。更棘手的是，如果你接过一个单纯的运动函数，说：“好，我现在想做的是，当这个物件从屏幕边缘反弹三次以后，让它对其他的物件施加引力影响。”是的，（用函数式方法）可以做到。想要像C语言一样实现得直截了当？没门。&lt;/p&gt;

&lt;p&gt;这里是一种选择：承认函数式编程对于某些问题来说是个错误的范式。没错。我可以打这个赌。但也许是因为几乎从没有人思考过这方面的问题，函数式编程正在吸引着纯粹主义者和那些固执地沉迷于其中的学生。在上面这个游戏的例子当中，有些问题是可以解决的，它们只是需要借助不同的途径。另外一些问题，我不知道如何解决，或者说至少没有找到如同循序渐进的C代码一样直截了当的解决方案。总之你看着办吧……反正我是承认了，函数式编程在某些情况下是笨拙的。在其他时候，它依然极其有用。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>【译文】不可能的全盘理解</title>
        <link href="http://www.soimort.org/posts/111" />
        <updated>2012-07-12T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/111/a-complete-understanding</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://prog21.dadgum.com/129.html&quot;&gt;A Complete Understanding is No Longer Possible&lt;/a&gt;
by &lt;a href=&quot;http://prog21.dadgum.com/&quot;&gt;James Hague&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;不妨假想一下，你刚买了一台MacBook Air，你的目标是要成为你的机器的主宰者，试图理解它在各个层次上是怎样运作的。&lt;/p&gt;

&lt;p&gt;Amit Singh的&lt;a href=&quot;http://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542&quot;&gt;《深入Mac OS X：系统方法（Mac OS X Internals: A System Approach）》&lt;/a&gt;是一个很好的出发点。比起编程，它更多的是关于操作系统的所有组件如何结合在一起的深度探讨：固件的作用，启动时事件的发生序列，设备驱动程序是做什么的，等等。在1680页的厚度上，它并非一本轻松的消夏读物。&lt;/p&gt;

&lt;p&gt;要想真正地理解硬件，Intel慷慨地为我们提供了免费的&lt;a href=&quot;http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html/&quot;&gt;七卷套文档&lt;/a&gt;。为了尽量保持简单，我仅仅推荐其中的&lt;a href=&quot;http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html&quot;&gt;《Intel 64和IA-32体系软件开发者手册第1卷：基础架构（Intel 64 and IA-32 Architectures Software Developer&amp;#39;s Manual Volume 1: Basic Architecture）》&lt;/a&gt;（550页）和描述了指令集的两卷（分别是684页和704页）。&lt;/p&gt;

&lt;p&gt;Objective-C是OS X所使用的编程语言。谢天谢地，我们有Apple提供的简洁的&lt;a href=&quot;http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjectiveC/ObjC.pdf&quot;&gt;《Objective-C程序设计语言（The Objective-C Programming Language）》&lt;/a&gt;（137页）。&lt;/p&gt;

&lt;p&gt;当然，Objective-C是C语言的一个超集，所以你同样应当过一遍第二版的&lt;a href=&quot;http://www.amazon.com/C-Programming-Language-2nd-Ed/dp/0131103709&quot;&gt;《C程序设计语言（The C Programming Language）》&lt;/a&gt;（274页）。&lt;/p&gt;

&lt;p&gt;现在，我们将要开始接触OS X的核心API了。&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaFundamentals.pdf&quot;&gt;《Cocoa基础指南（Cocoa Fundamentals Guide）》&lt;/a&gt;有239页，&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/AppKitObjC.pdf&quot;&gt;《应用程序套件框架（Application Kit Framework Reference）》&lt;/a&gt;则是只5069页的巨兽。它的用处在于对每个API调用都提供了详尽的档案式的说明。适可而止地，关于Cocoa文档的部分我将就此打住，虽然关于绘图、Core Audio、Core Animation和其他一打东西还有更多有用的书籍。&lt;/p&gt;

&lt;p&gt;哦，等等，OpenGL并没有包含在Cocoa里面，所以784页的&lt;a href=&quot;http://www.amazon.com/OpenGL-Reference-Manual-Official-Document/dp/032117383X&quot;&gt;《OpenGL参考手册（OpenGL Reference Manual）》&lt;/a&gt;在等着你。然后是另外800页的&lt;a href=&quot;http://www.amazon.com/OpenGL-Shading-Language-Randi-Rost/dp/0321637631&quot;&gt;《OpenGL着色语言（OpenGL Shading Language）》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;以上的全部一共是10921页——只差79页就到11万页了。我已经忽略了那些数以百计的系统组件的man帮助页和Xcode文档。而且，我还没有涉及到那些让你能够用OpenGL做出一些有趣玩意的图形学技巧，以及怎样写出好的C和Objective-C代码或者其他任何与面向对象设计相关的东西，还有……&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>【多图慎入】自由门、HTTP劫持和浏览器缓存</title>
        <link href="http://www.soimort.org/posts/110" />
        <updated>2012-06-26T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/110/freegate</id>
        <content type="html">&lt;p&gt;首先交代一下事件发生背景：作为一只用不起收费VPN的穷屌丝，我在国内期间仍然使用免费的轮子系列翻墙代理软件（如，自由门）浏览墙外网站。（goagent不能看外链的youtube视频）&lt;/p&gt;

&lt;p&gt;今天刷Tumblr的时候，发现自己刚发的帖子里好像混进去了神马奇怪的东西：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/75VmK.png&quot; width=&quot;100%&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我第一想到的就是：曾经干净清新的Tumblr终于也沦陷为无良小广告的丧尸了么。&lt;/p&gt;

&lt;p&gt;但是，在Dashboard里查看了我刚才发的原帖子的Markdown/HTML后，并没有找到任何可疑的内容。&lt;/p&gt;

&lt;p&gt;轻博客自身的HTML模板是我自己亲手定制的，所以也不可能会成为植入广告的来源。&lt;/p&gt;

&lt;p&gt;那么，这个无良小广告到底从何而来的呢？&lt;/p&gt;

&lt;p&gt;第一件要做的事情当然就是检查源代码嗯。&lt;/p&gt;

&lt;p&gt;起初我没有在HTML的前半部分发现任何异常（或者至少说，没有找到类似&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;这种可疑的最有可能植入广告的东西）……于是目光自然就定格到了页面的最后一部分，&lt;code&gt;&amp;lt;!-- BEGIN TUMBLR CODE --&amp;gt;&lt;/code&gt;后面的&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;元素上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6pSZF.png&quot; width=&quot;100%&quot; alt=&quot;12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很显然，这个&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;只可能是Tumblr自身提供的工具栏，也就是当本人登录Tumblr之后页面右上角显示的“Customize” “Dashboard”导航按钮（因为这是页面上唯一能够识别出Tumblr的外观元素）&lt;/p&gt;

&lt;p&gt;于是试着点开源链接之后，是怎样的效果呢……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1K2sa.png&quot; width=&quot;100%&quot; alt=&quot;13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;果然是Tumblr的导航按钮，但是，正中莫名其妙地多出了一个硕大的Google Ads广告！&lt;/p&gt;

&lt;p&gt;这个页面的源码想必很简单，现在来看一看……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ExRVP.png&quot; width=&quot;100%&quot; alt=&quot;14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;感谢Tumblr前端工程师良好的缩进风格，我很快就找到了这么几行违和感强烈的代码。一个&lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;居中标签包着一个Google Ads的script。恶心人的广告就是寄身在这里的。&lt;/p&gt;

&lt;p&gt;这段总计11行没有缩进的代码怎么看都不可能来自于Tumblr，那么它到底又是从何而来的呢？&lt;/p&gt;

&lt;p&gt;因为排除了是Tumblr的原因，我忽然想到去查一下自己的博客主页是不是也如此。果了个然，在页面里发现了同样的无良小广告元素：（类似地也是嵌入在Blogger自身导航栏&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;的内容里面的）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/hRZwR.png&quot; width=&quot;100%&quot; alt=&quot;16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;甚至在Blogger的编辑界面里也有这货：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/QCfCW.png&quot; width=&quot;100%&quot; alt=&quot;17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和被污染的Tumblr页面对比一下，是完全相同的11行代码。这段天杀的代码如下:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2988586.js?file=gistfile1.html&quot;&gt;&lt;/script&gt;

&lt;p&gt;而且比较一下就可以发现，这段&lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;代码如出一辙，总是紧接在正常页面HTML的&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素后面出现，以达到任何网页一打开正上方居中皆是一个斗大的嵌入广告想看不到都不行的强烈视觉效果……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Oa7UP.png&quot; width=&quot;100%&quot; alt=&quot;18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了慎重起见，我把所有主流的浏览器试了一遍（嘛，对于前端开发来说这些是必须有的）：Chrome，Firefox，Safari，IE，Opera，还有一个最干净的开发版Chromium。所有的都出现了无良小广告，基本上排除了是流氓软件插件篡改HTML的可能性。&lt;/p&gt;

&lt;p&gt;好吧，你污染我的主页倒也罢了，竟然连大小姐的博客也不放过……不可饶恕！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/QNUVY.png&quot; width=&quot;100%&quot; alt=&quot;21&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP劫持，我还真的完全没接触过。倒也不是说以前上网从来没遇到过，不过估计遇到的时候我还处于在家占着一根电话线拨号上网的时代，Win 98+IE上新浪雅虎21cn，哪里懂什么HTML什么HTTP劫持，反正一样是广告满天飞。之后就一直多年逍遥在教育网和国外ISP上了。&lt;/p&gt;

&lt;p&gt;国内ISP现在已经无良到这种程度了？HTTP劫持嘛，依我的想象力最严重就是搞个&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;加个广告包上去，竟然还有功夫写个算法把&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素识别出来然后“人性化”地把广告代码居中再插到最前面好让用户一打开页面第一眼就能看到？&lt;/p&gt;

&lt;p&gt;当然，我首先怀疑到的自然是一直开着的的自由门代理。关掉自由门之后再刷新Chrome和Safari，果然，Tumblr和主页（www.soimort.org）上镶嵌的无良小广告消失了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ANe2A.png&quot; width=&quot;100%&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/rfJxo.png&quot; width=&quot;100%&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但令人费解的是，Firefox和IE无论怎样刷新多少次，依然是返回被劫持之后受污染的页面。（注意到嵌入广告的大部分被我那个设置了z-index的导航栏压在下面了……垃圾广告程序员你们的技术水平还不够过硬啊残念残念lol）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XcyJ8.png&quot; width=&quot;100%&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qI7u2.png&quot; width=&quot;100%&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/IPfoz.png&quot; width=&quot;100%&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;乍一看有点略诡异。莫非这个流氓程序还会根据HTTP headers的User Agent选择性劫持HTML植入广告？&lt;/p&gt;

&lt;p&gt;还有，既然关了自由门的代理还存在这种情况，难道说真的是无良ISP在某个环节劫持了HTTP？&lt;/p&gt;

&lt;p&gt;自由门是通过&lt;a href=&quot;http://127.0.0.1:8580&quot;&gt;127.0.0.1:8580&lt;/a&gt;这个SOCKS代理服务器访问外部网络的，像traceroute这类基于ICMP协议的工具压根查不出什么东西。（traceroute不走代理）&lt;/p&gt;

&lt;p&gt;所以说想查到自由门用的外部服务器IP对于我这种网络小白来说压力略大……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/KDxKc.png&quot; width=&quot;100%&quot; alt=&quot;0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嘛，我只是一个web designer而不是hacker，虽然对于网络方面一窍不通，不过以前做前端设计的经验告诉我很有可能是浏览器缓存的问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3D2xi.png&quot; width=&quot;100%&quot; alt=&quot;22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;于是清空之……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3F92s.png&quot; width=&quot;100%&quot; alt=&quot;25&quot; /&gt;&lt;/p&gt;

&lt;p&gt;竟然真的不见了。（汗--||）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/DucpM.png&quot; width=&quot;100%&quot; alt=&quot;23&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对比一下有缓存和没缓存时候的区别：之前有缓存时，服务器返回的Status是304 Not Modified：（此时浏览器直接从本地缓存中取出页面来渲染）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/YD4GO.png&quot; width=&quot;100%&quot; alt=&quot;31&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在清除缓存之后，服务器返回的Status是200 OK：（此时由于本地没有缓存，浏览器GET远程服务器、下载得到新的页面）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1CMsQ.png&quot; width=&quot;100%&quot; alt=&quot;33&quot; /&gt;&lt;/p&gt;

&lt;p&gt;于是来简要总结一下原因：&lt;/p&gt;

&lt;p&gt;在我们的浏览器第一次访问某个网页时，服务器返回的HTTP Response Headers中包含一个Last-Modified的参数，标示该页面最近一次更新的时间。这时HTTP返回的状态码是200（OK），浏览器将GET来的页面渲染，同时存入缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/vs54d.png&quot; width=&quot;100%&quot; alt=&quot;34&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当浏览器再次访问该网页时（比如，一次刷新），浏览器会在发送的HTTP Request Headers中加上一个“If-Modified-Since”参数，这个参数就是上一次得到的该页面的最近更新时间（Last-Modified参数）。而服务器端会把这个时间同自己的最近更新时间作比较，如果两者一致，说明客户端自从上一次访问以来服务器端的文件并没有任何修改，于是直接返回状态码304（Not Modified）。浏览器得到这个状态码，就直接把本地缓存里的页面拿出来渲染，节约了带宽和用户等待的时间。&lt;/p&gt;

&lt;p&gt;如此，HTTP的请求/响应headers决定了页面的缓存状态，这就是浏览器的缓存机制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wWvtJ.png&quot; width=&quot;100%&quot; alt=&quot;35&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述貌似奇怪的现象，正是浏览器这种缓存机制造成的问题：&lt;/p&gt;

&lt;p&gt;前面说过，HTTP劫持的代码注入是自由门的无良代理服务器加上去的，和托管俺主页（&lt;a href=&quot;http://www.soimort.org&quot;&gt;www.soimort.org&lt;/a&gt;）的服务器（&lt;a href=&quot;http://pages.github.com&quot;&gt;pages.github.com&lt;/a&gt;）没有一丝一毫关系。&lt;/p&gt;

&lt;p&gt;于是，被小广告代码污染的HTML之前被下载、渲染、存到本地缓存，关闭了劫持HTTP的无良代理之后刷新访问，服务器上原有的内容并没有改变，它对于“最终到达用户的数据”的正确性不负责，也不可能知道途中数据被篡改与否，只知道根据浏览器发出的请求（“If-Modified-Since”）和自身状态（“Last-Modified”）作出判断，返回一个状态为304（Not Modified）的Response Headers。既然缓存没有过期，浏览器于是又把包含有无良小广告的HTML从本地缓存里拿出来渲染了，而非重新从远程服务器下载原来的页面（如果没有缓存的话，这个时候由于没有通过从事HTTP劫持勾当的代理，下载得到的显然应该是“干净”的页面）……这就造成了“关掉无良代理仍然有注入广告”的假象。&lt;/p&gt;

&lt;p&gt;经历了这次HTTP劫持事件，总结几点：&lt;/p&gt;

&lt;p&gt;首先，最直接地，自由门如今已经沦为轮子组织的摇钱树了，或者，像我一样使用该系列软件翻墙的全国人民，都已经沦为轮子组织的人肉摇钱树了……（这么说应该不过分吧）&lt;/p&gt;

&lt;p&gt;毕竟是免费软件，所以，从道义上说，你不能指责他“流氓”，反正你爱用不用。既然许多人都在用，植入广告也许是个理所当然的盈利方式。（这一点上稍微比国内某些你付了钱给他还要劫持你HTTP投放广告的土匪ISP稍微好那么一些，当然至于到底好多少我也不好说）&lt;/p&gt;

&lt;p&gt;更重要的是，通过自由门这类代理软件翻墙上网，访问未加密的HTTP连接，基本上是没有任何隐私性可言的。他能够劫持正常的HTML注入广告，当然也完全可以监控你的一切连接、你在网上的一举一动。&lt;/p&gt;

&lt;p&gt;虽然他宣称是保护用户隐私安全的，但其实不过是你把通过国内ISP那些有可能导致被有关部门查水表的那些记录，全部放到了他的眼皮底下而已。所以，这只是个取决于你更信任哪一方的问题。&lt;/p&gt;

&lt;p&gt;我的哲学是：不作恶。除了自己以外，不能轻信其他任何人不会作恶。所以，改天有空，还是在GAE或者AWS上面搭个自己的代理吧。&lt;/p&gt;

&lt;p&gt;(・U・)&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>【译文】Linux的成功源于自私和信任</title>
        <link href="http://www.soimort.org/posts/109" />
        <updated>2012-06-24T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/109/linux-succeeded</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://www.bbc.com/news/technology-18419231&quot;&gt;Linus Torvalds: Linux succeeded thanks to selfishness and trust&lt;/a&gt;
by Leo Kelion&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;Linux的创造者Linus Torvalds摘取了由芬兰技术科学院颁发的千禧年科技奖，以及作为奖金的600000欧元（相当于756000美元或486000英镑）支票。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;他被授予该奖的理由是他创造了最初的Linux操作系统，并且长期以来决定着Linux内核应该做出哪些方面的修改——以通过代码让软件和硬件协同工作。&lt;/p&gt;

&lt;p&gt;今天，各种各样基于Linux的操作系统驱动着世界上无数的服务器、TV机顶盒、智能电话、平板电脑、网络路由器、个人电脑以及超级电脑。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在该奖项宣布之前，Torvalds先生罕见地接受了一次BBC的采访。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当你1991年在Usenet新闻组上发布关于最初的系统内核的消息时，你当时预想到接下来会发生的事情是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我想你的问题是假定我在这之前做好了某种程度的计划，但实际上那并不存在。在我公布原始的内核代码时，我对于未来并没有什么特别的预期；发布它的动力很大程度上只是想要告诉大家“嗨，来看看我做出了什么。”&lt;/p&gt;

&lt;p&gt;我当时绝对没有奢望会有别人来帮助我完成这个项目，但我期望能得到一些针对项目完成度的意见反馈，并且能够搜集到一些在别人看来不错的想法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux的成功很大程度上归功于它的开源本质。你认为是什么使得人们愿意在没有物质奖励的情况下投入时间参与其中？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实际上在许多方面，我认为开源的真正意义在于：允许每个人变得“自私”，而非试图让所有人都为了一致的公共利益来做贡献。&lt;/p&gt;

&lt;p&gt;换言之，我从来都不把开源看作那种夸大其辞的“让我们围着篝火唱起兄弟之歌，让这个世界变得更美好。”不，开源只有当每个人都出于各自自私的目的而来为之付出努力时，才会真正地发展壮大起来。&lt;/p&gt;

&lt;p&gt;话虽如此，在当下，这些自私的目的绝不仅仅是单纯地为了“经济奖赏”。&lt;/p&gt;

&lt;p&gt;最早这些参与Linux开发的人，他们的“自私”目的无非就是为了满足自己捣鼓新奇玩意的爱好。这也曾经是我做Linux的理由——编程是我的乐趣——一种真正的激情——而学会怎样控制硬件则是我的“自私”目的。到后来我发现，并非只有我一个人抱有这种目的。&lt;/p&gt;

&lt;p&gt;在那些规模较大的、开设了计算机科学系的大学里面，也会有不少人对类似的东西感兴趣。&lt;/p&gt;

&lt;p&gt;对于那些人来说，完全从零开始编写自己的操作系统可能显得有点疯狂，但肯定会有人对摆弄、折腾硬件设备产生兴趣，如果他们足够兴致盎然的话，他们就会开始捣鼓这个操作系统，提出改进的建议，而且最终自行实现这些改进并回馈给我。&lt;/p&gt;

&lt;p&gt;版权模式可以保护这一类人。假如你是一个操作系统的爱好者，你听说了这个项目，如果你感到自己贡献的劳动可能会从某种意义上成为“冤大头”，你肯定不会乐意加入，但是由于GPL v2许可证的采用，这就不是一个问题了。&lt;/p&gt;

&lt;p&gt;GPL v2许可证的基本属性是一种非常简单明了的“以眼还眼”模式。我给予你我所做的改进成果，但作为回报，你必须承诺：你也会把你所做的改进成果给予他人。&lt;/p&gt;

&lt;p&gt;它是一个从骨子里公平的许可证，你用不着担心别人会从你的劳动成果中“揩油”。&lt;/p&gt;

&lt;p&gt;令许多人感到惊讶的是，这种“公平性”的概念实际适用的范围可以扩展到非常之广。&lt;/p&gt;

&lt;p&gt;当然，很多公司最初对这种他们闻所未闻的许可证持强烈的怀疑态度，有时候这种怀疑甚至会翻上一番，个中缘由在于自由软件阵营的一部分人极端地反对商业化、恨不得那些公司一夜之间就把所有东西全部变成自由软件。&lt;/p&gt;

&lt;p&gt;但是说真的，整个“以眼还眼”的模型并不只是适用于个人意义上的公平，它的公平性同样也适用于公司规模、乃至全球规模。&lt;/p&gt;

&lt;p&gt;一旦个人和公司克服了这道障碍——改口将它称作“开放源码”，并且澄清了它绝非是某种反商业化行动这一事实——事态就开始欣欣向荣起来了。&lt;/p&gt;

&lt;p&gt;事情最终演变成了这样，如果竞争对手不投入与你同等的努力，他们就不能获得和你同等的收益：如果他们不参与项目的贡献，他们就不能够影响项目前进的方向，并且他们在相应的对技术的认识和理解上将远远落在后面。&lt;/p&gt;

&lt;p&gt;因此，积极地参与其中是大有好处的——你不能总是沿着别人的工作亦步亦趋。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来自80个国家的7800名开发者参与贡献了最近一个版本的Linux内核。由于它变得越来越复杂，这是否会导致新人要想加入开发变得愈加困难？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内核肯定是变得更加复杂了，而且绝对会有那种新的开发者不想一上来就碰到的难啃的核心部分。&lt;/p&gt;

&lt;p&gt;当那些之前没有一定良好记录的新人向内核提交补丁时，社区里的人们会变得比较紧张——尤其是涉及那些复杂部分的、例如VM子系统的代码。&lt;/p&gt;

&lt;p&gt;所以说，比起15年以前，如今要想成为一名合格的核心开发者肯定是变得更困难了。&lt;/p&gt;

&lt;p&gt;与此同时，我认为参与内核开发其实还是比较容易的一件事，如果你不用一上来就直接去搞最复杂的核心部分的话。事实上，我差不多每三个月发布一个新版本的内核，每次发布通常都有1000人以上参与了开发，也就是说，我们肯定不缺少贡献者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你之前提到过，你不可能亲自去把所有提交的代码在所有的硬件上都检查一遍——在这样的开源项目当中，信任所导致的问题可能会有多大？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;哦，信任是最重要的东西。同时它也是条双行道。&lt;/p&gt;

&lt;p&gt;并不只是我应当信任那些子部分的负责人能够把事情做对，相应地，他们也应该能够信任我会保持公平公正、做出正确的选择。&lt;/p&gt;

&lt;p&gt;我们的意见并不总是一致，有时候争论会愈演愈烈，在一天的结束时，你甚至都可能感到不太喜欢对方，如果你至少相信别人不是故意要和你抬杠的话。&lt;/p&gt;

&lt;p&gt;举个实际的例子，这种信任问题也正是我从来不曾想要为一个商业Linux公司工作的原因。&lt;/p&gt;

&lt;p&gt;我单纯是不想给人们留下一种存有偏见的印象——我要人们能够信任我的公正性，不仅仅是因为这些年来他们看着我始终如一地维护着内核，更因为他们知道，我并不会藉由支持某个Linux公司甚于另一个公司而从中谋取自身利益。&lt;/p&gt;

&lt;p&gt;最近一段时间以来，我开始全职投身于Linux的维护开发，而且这是份拿薪水的工作，但在这之前我并没有这么做，直到我找到了一种方式能让我自身保持明显的中立，通过一个本身并不出售Linux产品的工业界非营利机构。&lt;/p&gt;

&lt;p&gt;即使如此，为了避免不必要的误解，我们实际上还签订了这样的合同，其中白纸黑字规定了：雇佣我并不意味着Linux基金会能够干涉我的做法。&lt;/p&gt;

&lt;p&gt;所以准确的说，由于我如此重视这类信任问题，我有着一份也许你闻所未闻的最稀奇的雇佣合同。&lt;/p&gt;

&lt;p&gt;基本上，合同中有一段是关于我应当做什么的——可以归结为，我所做的一切都必须是开源的——而合同的剩余部分，则说明了我所工作的公司无权对我施加任何影响。&lt;/p&gt;

&lt;p&gt;“信任”并不等于绝对中立，或者类似的东西；它是某种程度的可预见性，知道你不会被别人玩弄于股掌之上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux在许多IT领域如智能电话、服务器上日趋流行，但它从未在桌面领域取得类似的突破——你认为这可能在将来发生吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我认为要想占据消费市场，你确实需要有一定的预装度。从Android可以看到，Linux的确可以成为一个不错的消费产品。所以消费市场本身并不一定是什么难啃的硬核桃，“你需要被硬件产品预装”才是个大问题。&lt;/p&gt;

&lt;p&gt;在笔记本和桌面市场上，我们没有任何公司成功地采取了这种策略。不要误会我的意思——这样的做法确实不大容易。&lt;/p&gt;

&lt;p&gt;虽说如此，我也不会放弃希望。号称“全能Web浏览器”的消费产品开始介入市场，或多或少正在使这一切变得现实，Google的Chrome操作系统（Chromebox和Chromebooks）很显然在朝着这方面发展。&lt;/p&gt;

&lt;p&gt;因此我仍然充满期待。对我来说，桌面Linux是我最初的出发点，而且说起来，桌面Linux至今仍然是我主要使用的操作系统——尽管我还有其他的Linux设备，包括一个Android手机——所以就个人来说，我也很乐意看到Linux同样能占据一部分的桌面市场。&lt;/p&gt;

&lt;p&gt;不过与此同时，看到它在其他市场大获成功，的确是值得高兴的一件事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Steve Ballmer曾经形容Linux是一种“癌症”，但在最近几个月里，我们听说微软发布了Skype的Linux版本，现在它又开始提供基于Linux的Azure云服务平台——这是否让你有所欣慰？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;嗯，可以说微软至少从某种程度上停止了敌视Linux，这一点还是让人安心的。所有那些“癌症”和“非美国式”之类的叫法只会让人感到难堪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最近基于Linux的Raspberry Pi项目的启动，引起了很多人的注意。你希望它能够激发起下一代程序员的兴趣，以使他们将来能够能为Linux的贡献者吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我自己就是从“捣鼓电脑”这样的背景走过来的，所以是的，我理所当然地认为Raspberry Pi这类东西大有意义：试图让更多的人来捣鼓电脑、玩出各种花样。&lt;/p&gt;

&lt;p&gt;让计算机足够廉价使得你不仅可以负担得起较大批量的硬件花销，可能更重要的是，你更可以负担得起失败的代价。&lt;/p&gt;

&lt;p&gt;之所以这么说，是因为我怀疑这类设备最终会落到很多儿童手中，但他们中的很多人只是稍微玩玩而已，很快就会完全失去了兴趣。&lt;/p&gt;

&lt;p&gt;但这样做完全没有问题。如果它足够便宜，你能够负担得起许多个“不感兴趣”事例的代价，直到最终激发起了一个极其罕见的“感兴趣”的事例。&lt;/p&gt;

&lt;p&gt;所以我实际上认为，如果你把这些平台做得足够廉价——廉价到了可以“随手扔掉”的程度，从某种意义上说——这种浪费可以成为一件好事，因为这也许意味着你最终发现了一些珍稀的、平时难以注意到的天才。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你在家里工作——当工作中必须专心于非常抽象的概念时，避免被家庭生活分心到底有多难？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;哦，我知道对于某些人来说这可能很难。但这对我来说从来就不是一个问题。&lt;/p&gt;

&lt;p&gt;相对而言计算机对我更具吸引力，基本上我常常会忘我地专注于自己的事情，加上我本来就不是一个十分热衷于社交的人。&lt;/p&gt;

&lt;p&gt;拥有了自己的家庭看起来并没有改变我的这种性格特征。&lt;/p&gt;

&lt;p&gt;我会很乐意地坐在电脑前一整天，如果我正在工作当中，孩子们的骚扰使我分心的话，搞不好就是一顿臭骂。&lt;/p&gt;

&lt;p&gt;换句话说：个性中被看作导致社交方面失败的缺陷，当然也可以发展成为你的某种优点。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>【译文】对非实用编程的赞美</title>
        <link href="http://www.soimort.org/posts/108" />
        <updated>2012-06-22T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/108/impractical-programming</id>
        <content type="html">&lt;p&gt;Original Article: &lt;a href=&quot;http://www.niemanlab.org/2011/11/in-praise-of-impractical-programming/&quot;&gt;In Praise of Impractical Programming&lt;/a&gt;
by &lt;a href=&quot;http://www.niemanlab.org/author/jharris/&quot;&gt;Jacob Harris&lt;/a&gt;&lt;br&gt;
(Chinese Translation by &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort Yao&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;如今对于非专业的程序员来说，书写代码和创造出实用的东西变得愈加容易了，这是一件好事。但这并非意味着那些古怪、异想天开却优雅的非实用手段应该被我们所遗忘。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;尽管如今已成为某种文化的柱石，我仍然会记得我第一次看见那本厚书时的情形——一本封面上画着一个巫师的书——有关一所魔法学校，在那里奇迹总能由知道正确咒语的人变戏法般地创造出来。没错，我要说的这本书就是&lt;a href=&quot;http://mitpress.mit.edu/sicp/&quot;&gt;《计算机程序的构造和解释（Structure and Interpretation of Computer Programs）》&lt;/a&gt;。有&lt;a href=&quot;http://en.wikipedia.org/wiki/Harry_Potter&quot;&gt;另外一本书也提到了咒语&lt;/a&gt;，但&lt;a href=&quot;http://catb.org/jargon/html/W/Wizard-Book.html&quot;&gt;“巫师书”&lt;/a&gt;是一本确确实实教授魔法的书。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.niemanlab.org/images/wizard-book-programming.jpg&quot; alt=&quot;SICP&quot;&gt;&lt;/p&gt;

&lt;p&gt;在过去的若干年里，我一直在一个新闻部门的编辑部里从事软件开发工作，在那里，对于我这类程序员的看法已经逐渐由&lt;a href=&quot;http://nymag.com/news/features/all-new/53344/&quot;&gt;“新奇的奢侈品”&lt;/a&gt;改观为&lt;a href=&quot;http://www.newsnerdjobs.com/&quot;&gt;“不可或缺的必需品”&lt;/a&gt;。认识到这一点之后，一些新闻学院现在已经开设了程序设计课程，教会学生诸如数据库和Web框架之类的实用技能。看着这一代网络黑客式的新闻记者让人不禁感到心里发毛——然而，我希望我们还能够从这些课程中挤出一些空间，留给一点小小的魔法。&lt;/p&gt;

&lt;p&gt;学会编程是一项重要的技能；学会怎样&lt;em&gt;成为&lt;/em&gt;一名程序员则需要另一种迥异的训练。因此，我要感谢一个真正的非实用的入门级导引——我的第一门编程课，&lt;a href=&quot;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/&quot;&gt;MIT的6.001&lt;/a&gt;，它将一种非常不实用的语言&lt;a href=&quot;http://groups.csail.mit.edu/mac/projects/scheme/&quot;&gt;Scheme&lt;/a&gt;用来作为教学语言。&lt;/p&gt;

&lt;p&gt;Scheme是&lt;a href=&quot;http://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;（LISt Processing，表处理）、这门老当益壮并被设计用于人工智能理论工作语言的一个学术风格方言。在初学者的眼中，Lisp看起来像是一些里外颠倒的句子、被嵌置在数量多到足以令人发疯的括号当中。但最终，你会把它视作天使的语言，因为它并非被狭隘地设计用于某一个专门领域的用途如矩阵处理或实现操作系统的。Lisp设计的初衷是用来表示符号（并且涵盖了&lt;a href=&quot;http://www.paulgraham.com/diff.html&quot;&gt;其他语言中缺少的一些重要特征&lt;/a&gt;），这意味着它能够用于表达一切事物。因为Scheme的核心符号集是出了名的匮乏，学生常常需要白手起家、从简单的结构一步步构筑起更加高级的结构，因而能够从中提高自身。&lt;/p&gt;

&lt;p&gt;在整个学期的开始，学会怎样理解和使用过程（procedures）已经充分；而在结束时，我们已能够随意地处理无限的数据流、模拟计算机芯片的工作流程。极富挑战性的一课出现在学年的中期，我们完成了一项看似悖论式的练习任务：用Scheme实现一个Scheme自身的解释器。适可而止地，这个&lt;a href=&quot;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1&quot;&gt;自循环解释器&lt;/a&gt;的相关介绍并未占用过多课时，它只是作为MIT Scheme的一个傻瓜式启发入门存在，通过化装、闪罐的烟火和最后每个人得到的一个&lt;a href=&quot;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-945-adventures-in-advanced-symbolic-programming-spring-2009/6-945s09.jpg&quot;&gt;印有“Scheme”标志的纽扣&lt;/a&gt;来纪念我们的成就。到了学期末，我已经完全着迷于这门课了。&lt;/p&gt;

&lt;p&gt;但是，在实际的编程工作中，我的技能并没有任何增长；关键问题在于，我所学的那些东西仅仅属于理论范畴。这也是为什么非实用的入门编程课在绝大多数大学里如此滞销的原因。如果学生只修习一门程序设计课程，教授希望他们在结束时能够做出一些实在的东西。即便是MIT自己，也在2009年&lt;a href=&quot;http://mitadmissions.org/blogs/entry/the_end_of_an_era_1&quot;&gt;放弃了这种神秘主义符号式的Lambda演算传道&lt;/a&gt;，取而代之的是一门简化的、基于Python和机器人学的编程导论课，旨在为那些将来可能并非专攻计算机科学的学生们而准备。这种做法所基于的理由是，编程本身的形式自从上个世纪80年代以来有所改变；开发者已经不再需要自己从零开始构建整个系统；&lt;a href=&quot;http://www.wisdomandwonder.com/link/2110/why-mit-switched-from-scheme-to-python&quot;&gt;如今他们只需借助现有的各种库就能够轻松实现某种任务&lt;/a&gt;。对于如今大部分的编程工作来说，这是真的——但我总不禁沮丧地回想起（莎士比亚的戏剧《暴风雨》里）&lt;a href=&quot;http://shakespeare.mit.edu/tempest/tempest.5.1.html&quot;&gt;普洛斯彼罗是如何放弃他的魔法的&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;至今，我仍然感受到6.001（以及MIT其他那些优美但不甚实用的CS课程）让我成为了一个更好的程序员。它那非实用的方式迫使我去理解计算机科学的广阔世界，而非仅仅着眼于一个狭窄的应用领域，例如构建一个网站或者学会SQL。这可能是个不太具有说服力的论点，但至少&lt;a href=&quot;http://lispers.org/&quot;&gt;我有很多好的辩论伙伴&lt;/a&gt;；照常，&lt;a href=&quot;http://www.paulgraham.com/avg.html&quot;&gt;Paul Graham对于此观点的表达比我更好&lt;/a&gt;。我也许已经有好几年没写过Scheme程序了——实际上，我用的是和你一样的实用编程工具。但我并不只是把它们当成锤子那样来使用：我知道它们的形式是怎样演变来的，以及怎样改造它们以适应新的问题。我认为这正是“非实用编程”所教给我的东西。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.niemanlab.org/images/seven-languages-seven-weeks.jpg&quot; alt=&quot;Seven Languages in Seven Weeks&quot;&gt;&lt;/p&gt;

&lt;p&gt;我并不坚持主张新闻学院应该把珍贵而难得的计算机科学学分花费在异想天开的编程入门上。但如果你想要在作为程序员的方面获得进步，你需要去尝试走一些非实用的弯路。如果你不知道如何编程，选择一门实用的语言是有益的；如今像&lt;a href=&quot;http://greenteapress.com/thinkpython/thinkpython.html&quot;&gt;Python&lt;/a&gt;、&lt;a href=&quot;http://pine.fm/LearnToProgram/&quot;&gt;Ruby&lt;/a&gt;和&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;JavaScript&lt;/a&gt;这些语言都有很好的教程。但在此之后，不妨尝试学习一门与你用来工作的语言完全不同的程序语言。&lt;a href=&quot;http://clojure.org/&quot;&gt;Clojure&lt;/a&gt;是一门相当酷的现代LISP方言。你甚至可以同时对好几种语言进行一次走马观花式的&lt;a href=&quot;http://pragprog.com/book/btlang/seven-languages-in-seven-weeks&quot;&gt;壮游&lt;/a&gt;。从另一方面来说，你最终应当学习C，并且通过阅读源码了解你最喜爱的语言是怎样实现的。阅读那些你喜欢的、你讨厌的库及工具的源代码。做一些系谱学的调研——了解你所喜爱的程序语言是从其他哪些语言演化而来的（例如，Ruby借鉴了Smalltalk、Eiffel、Lisp、Perl，以及&lt;a href=&quot;http://en.wikipedia.org/wiki/CLU_(programming_language)&quot;&gt;CLU&lt;/a&gt;的一项至关重要的特性）。学习怎样写一个解析器。学习算法。学习操作系统是怎样运作的。开始一些任意的项目；为一些任意的项目&lt;a href=&quot;http://github.com/&quot;&gt;创建自己的分支&lt;/a&gt;。总是保持在写代码的状态。忽略我的建议并提出你自己的观点。然后做出突破。&lt;/p&gt;

&lt;p&gt;最关键的是要在你几乎一无所知的领域里大胆探索，不带任何功利的目的。成为一个非实用主义者。投下你的咒语吧。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>Code Jam 2012 剩余的杯具总结</title>
        <link href="http://www.soimort.org/posts/107" />
        <updated>2012-05-09T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/107/gcj-r1</id>
        <content type="html">&lt;h2&gt;Code Jam 2012 剩余的杯具总结&lt;/h2&gt;

&lt;h3&gt;Round 1B - Problem A. Safety in Numbers&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1836486/dashboard#s=p0&amp;amp;a=0&quot;&gt;http://code.google.com/codejam/contest/1836486/dashboard#s=p0&amp;amp;a=0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;纯粹是在考察浮点数计算，和不等式推导。&lt;/p&gt;

&lt;p&gt;最关键的坑人点是要注意排除出现负值的情况。（当然这也就是唯一的难点了。这题小数据集正确率很低，不到50%）&lt;/p&gt;

&lt;p&gt;一个判断条件写错了，导致在某些情况下会出现负数解。小数据集侥幸过了，大数据集看都没看就直接提交，于是杯具。&lt;/p&gt;

&lt;p&gt;改一个语句就能通过的这种题还真是残念得不行啊。。。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2644309.js?file=gistfile1.scala&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Round 1B - Problem C. Equal Sums&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1836486/dashboard#s=p2&amp;amp;a=0&quot;&gt;http://code.google.com/codejam/contest/1836486/dashboard#s=p2&amp;amp;a=0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我承认我只想到最原始的穷举。。。&lt;/p&gt;

&lt;p&gt;生成集合的幂集然后逐个枚举求和，用一个hash map来保存以前的结果。&lt;/p&gt;

&lt;p&gt;但是，枚举的顺序是有讲究的（！）&lt;/p&gt;

&lt;p&gt;如果只是盲目地通过生成从0到2^n-1 的二进制序列来枚举幂集（我采用的方法），大数据集肯定会超时。&lt;/p&gt;

&lt;p&gt;官方给出的解析是根据和&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C&quot;&gt;生日悖论&lt;/a&gt;类似的推导，一个基数为500的集合，对于其所有基数为6的子集而言，所有子集的求和结果均不相同的概率非常之小，所以只需要首先枚举基数为6的那些子集（因为只需要找到一组解，在找到两个和相同的子集之后，算法就可以结束）。（这就是密码学上的所谓&lt;em&gt;生日攻击&lt;/em&gt;）&lt;/p&gt;

&lt;p&gt;以下是我的穷举法（大数据超时）。根据官方的解答，写一个不会超时的版本应该不难。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2644369.js?file=gistfile1.java&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Round 1C - Problem A. Diamond Inheritance&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1781488/dashboard#s=p0&amp;amp;a=0&quot;&gt;http://code.google.com/codejam/contest/1781488/dashboard#s=p0&amp;amp;a=0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不想再说什么了，最基本的BFS，花了我无穷多的时间，充分反映了我的算法实现能力是多么的渣。&lt;/p&gt;

&lt;p&gt;亏我这题还是用的Ruby（要是再回到中学时代做信息学竞赛的时候让我用C甚至Pascal写估计得写崩溃了。。。）&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2644578.js?file=gistfile1.rb&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Round 1C - Problem C. Box Factory&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1781488/dashboard#s=p2&amp;amp;a=0&quot;&gt;http://code.google.com/codejam/contest/1781488/dashboard#s=p2&amp;amp;a=0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;动态规划，并不算太复杂。具体解法略（反正俺也没在比赛时间内做出来。。。）&lt;/p&gt;

&lt;p&gt;本着一题一语言的原则，我选择了OCaml，结果因为在A题上实在是花了太多时间，加之对OCaml的List操作不熟悉，所以(´д`;)&lt;/p&gt;

&lt;h3&gt;Code Jam 2012，结束了。明年再来过。&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.go-hero.net/jam/12/name/soimort&quot;&gt;http://www.go-hero.net/jam/12/name/soimort&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;恩，考虑到无数混迹于TopCoder、UVa、SPOJ和POJ和……的ACM大神的存在，2500 * 3 -&amp;gt; 七千到八千名之间大概也就是我的真实水平了。&lt;/p&gt;

&lt;p&gt;我没有做过TopCoder（因为不喜欢它的UI，和编程语言限制）。然后很恶心SPOJ的广告（当然不做SPOJ的一个主要原因是虽然它支持很多非主流编程语言，却又不及时维护更新版本，然后时间限制还一视同仁，搞到最后觉得还是不如用C++最靠谱。。。汗）。倒是很喜欢Code Jam和Project Euler这种data driven的方式，一直在想要是能有这么一个算法竞赛的OJ就好了。&lt;/p&gt;

&lt;p&gt;把问题抽象成算法模型的能力一直是我的一个瓶颈。（经常是一道题已经有几百号人提交了我还在纸上写写画画没开始编码）&lt;/p&gt;

&lt;p&gt;然后就是各种坑爹的低级失误（今年Round 1A的A题large，B题，Round 1B的A题large），代码只有那么一点点小错误当时改掉一行就能通过了但比赛过程中就是发现不了= =||&lt;/p&gt;

&lt;p&gt;好吧，不管怎么说，Code Jam 2012算是结束了。可以去做点别的事情了。&lt;/p&gt;

&lt;p&gt;明年再来过。&lt;/p&gt;
</content>
    </entry>
    
    
    
    <entry>
        <title>Code Jam 2012 Round 1A 反思</title>
        <link href="http://www.soimort.org/posts/106" />
        <updated>2012-04-28T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/106/gcj-r1a</id>
        <content type="html">&lt;h2&gt;Code Jam 2012 Round 1A 反思&lt;/h2&gt;

&lt;h3&gt;Problem A. Password Problem&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1645485/dashboard#s=p0&quot;&gt;http://code.google.com/codejam/contest/1645485/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第一题纯模拟，我最不擅长的类型之一，光是理解题意就耗了20分钟(´д`;)&lt;/p&gt;

&lt;p&gt;其实就是计算n个数学期望找出其中的最小值……&lt;/p&gt;

&lt;p&gt;我居然极端脑残的把明显是O(n)的算法写成了O(n^2 )（见如下代码）。。。然后大数据点就超时了（第9个case无论如何也不能在8分钟内跑出来）。。。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2517492.js?file=gistfile1.groovy&quot;&gt;&lt;/script&gt;

&lt;p&gt;当时觉得应该是Groovy处理大文件的时候坏掉了（毕竟是脚本执行效率并不高），比赛结束回头一看，发现完全是自己坏掉了。。。&lt;/p&gt;

&lt;p&gt;以下是正解，从循环体里去掉了不必要的累乘（大数据秒出结果）&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2517494.js?file=gistfile1.groovy&quot;&gt;&lt;/script&gt;

&lt;p&gt;怀疑这题如果用C写O(n^2 )也许能过，不过如果那样做的话，我可能永远都不会知道把一个本该是O(n)的算法搞成了O(n^2 )。&lt;/p&gt;

&lt;h3&gt;Problem B. Kingdom Rush&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1645485/dashboard#s=p1&quot;&gt;http://code.google.com/codejam/contest/1645485/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正确地使用了贪心法。&lt;/p&gt;

&lt;p&gt;我的低级失误是没有意识到完成2星计分时已经完成1星的关卡只能加1分，统统都按加2分算了……&lt;/p&gt;

&lt;p&gt;这个甚至在我手算测试数据的时候就已经搞错了，所以直到比赛结束都没有找到症结所在。&lt;/p&gt;

&lt;p&gt;事后证明只要在原来的代码上改一行就能解决问题，如下：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2517534.js?file=gistfile1.java&quot;&gt;&lt;/script&gt;

&lt;p&gt;以上。如果没有在做连续两题的时候脑子都坏掉的话，本来还是可以晋级的(；д；)&lt;/p&gt;

&lt;p&gt;三题中的前两题基本上不是考算法，更多是考理解题意能力和头脑的清晰程度。&lt;/p&gt;

&lt;p&gt;当然，还有我完全不具备的代码实现速度。（大概唯一比较有自信的地方只是自认为代码写得比大多数人整洁而已(´д`;)&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>Code Jam 2012 资格赛 解题报告</title>
        <link href="http://www.soimort.org/posts/105" />
        <updated>2012-04-16T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/105/gcj-qr</id>
        <content type="html">&lt;h2&gt;Code Jam 2012 资格赛 解题报告&lt;/h2&gt;

&lt;h3&gt;Problem A. Speaking in Tongues&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1460488/dashboard#s=p0&quot;&gt;http://code.google.com/codejam/contest/1460488/dashboard#s=p0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Code Jam资格赛历年来最水的一道水题，字符替换。&lt;/p&gt;

&lt;p&gt;我的做法是人肉分析输入输出样例之间的字符映射关系。（不知道有没有人用代码来做这事）&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2401276.js?file=a.dart&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Problem B. Dancing With the Googlers&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1460488/dashboard#s=p1&quot;&gt;http://code.google.com/codejam/contest/1460488/dashboard#s=p1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直接贪心法，把有限的&lt;strong&gt;s&lt;/strong&gt;个“surprising triplets”机会尽可能分配给那些在surprising情形下best score能够达到&lt;strong&gt;p&lt;/strong&gt;、否则达不到&lt;strong&gt;p&lt;/strong&gt;的Googlers。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2401349.js?file=gistfile1.hs&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Problem C. Recycled Numbers&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1460488/dashboard#s=p2&quot;&gt;http://code.google.com/codejam/contest/1460488/dashboard#s=p2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;典型的Project Euler风格。从数据规模来看穷举完全可以承受，没必要用查找表什么的。（反正Code Jam又不是OJ判题）&lt;/p&gt;

&lt;p&gt;注意消除重复的情况。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/2401419.js?file=gistfile1.py&quot;&gt;&lt;/script&gt;

&lt;h3&gt;Problem D. Hall of Mirrors&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://code.google.com/codejam/contest/1460488/dashboard#s=p3&quot;&gt;http://code.google.com/codejam/contest/1460488/dashboard#s=p3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这次资格赛中唯一一道不水的题……而且相当有技术含量。（从Correct的人数来看，小数据集555人，大数据集186人。前面三题的正确数都在10000以上。。。）&lt;/p&gt;

&lt;p&gt;计算几何中的镜面反射模拟+枚举策略。&lt;/p&gt;

&lt;p&gt;看过官网上的分析就知道，这策略其实很简单，只是实现起来略麻烦。&lt;/p&gt;

&lt;p&gt;我的C++实现太臃肿（600多行），而且大数据集还是做错的。不贴出来了。&lt;/p&gt;
</content>
    </entry>
    
    
    
    
    
    
    
    
    
    <entry>
        <title>版本控制系统入门 (II). Git</title>
        <link href="http://www.soimort.org/posts/104" />
        <updated>2011-12-30T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/104/scm-2_zh</id>
        <content type="html">&lt;h2&gt;0. 版本控制：从集中式到分布式&lt;/h2&gt;
&lt;p&gt;与集中式版本控制系统的客户端-服务器（Client/Server, C/S）模式相异，分布式版本控制系统（Distributed Version Control System, DVCS）采取一种端对端（peer-to-peer, P2P）的对等模式。每个节点（peer）的工作拷贝均是一个完全等效的仓储，而非仅有唯一的一个供客户端同步的“中心”仓储。分布式版本控制通过节点之间交换补丁（patch）来实现。这使得它与集中式版本控制系统存在着许多本质上的差别：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;不存在一份默认的、权威的“标准”代码拷贝；只有相互之间对等的工作拷贝。&lt;/li&gt;
	&lt;li&gt;常规的操作（如提交、查看历史和回滚更改）速度非常之快，因为不需要同存放中心仓储的远程服务器进行通信。仅仅当对其他节点推入（push）或拖出（pull）变更时才需要网络通信。&lt;/li&gt;
	&lt;li&gt;每一份工作拷贝均是一份有效的完整代码库，其功能与原仓储完全等同。它包含变化的全部历史，可以用以恢复任意的历史数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式版本控制还具备以下若干重要的特征：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;可以同时存在多个“中心”仓储。&lt;/li&gt;
	&lt;li&gt;来自不同仓储的代码依据信任网络（web of trust）进行合并，一些主要考虑的因素包括：历史贡献和修改代码的质量。&lt;/li&gt;
	&lt;li&gt;允许存在不同的开发模型。例如：开发/发布分支模型或者类似于指挥官/副官的组织结构模型。这在大型的软件项目中可以形成高效的责任机制。&lt;/li&gt;
	&lt;li&gt;“副官”是拥有动态决定哪些分支用于合并的特权的项目成员。&lt;/li&gt;
	&lt;li&gt;在大部分操作中，无需网络连接。&lt;/li&gt;
	&lt;li&gt;提交变更或从远程仓储获取变更时，允许单独的一组“同步”操作。&lt;/li&gt;
	&lt;li&gt;因为变更是单独存放在小的数据单元里的，自动地从不同版本中合并变化变得有可能，即使变化已经被添加到了两个或更多的分支当中。&lt;/li&gt;
	&lt;li&gt;典型的分布式版本控制系统基于存储目录树，用以取代过去的独立文件存储。这使得改变文件的名字和位置、移动代码的某一部分到不同的文件中均变得更加容易了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1. Git基本操作&lt;/h2&gt;
&lt;h3&gt;1.1. 用户设置&lt;/h3&gt;
&lt;p&gt;设置全局用户名与邮箱：&lt;br /&gt;
&lt;code&gt;$ git config --global user.name &quot;Firstname Lastname&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git config --global user.email your_email&lt;/code&gt;&lt;code&gt;@youremail.com&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;1.2. 获取一个git库并创建一个补丁&lt;/h3&gt;
&lt;p&gt;克隆远程git库到本地当前路径下的hello-world目录：&lt;br /&gt;
&lt;code&gt;$ git clone git://github.com/git/hello-world.git hello-world&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ cd hello-world&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ (edit files)&lt;/code&gt;&lt;br /&gt;
向本地git库中添加文件：&lt;br /&gt;
&lt;code&gt;$ git add (files)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从本地git库中删除文件：&lt;br /&gt;
&lt;code&gt;$ git rm (files)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git rm -r (directories)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改本地git库中文件后，查看所更改的内容：&lt;br /&gt;
&lt;code&gt;$ git diff --cached&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交更改到本地git库：&lt;br /&gt;
&lt;code&gt;$ git commit -m 'Explain what I changed'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可直接添加所有文件，并提交更改到本地git库：&lt;br /&gt;
&lt;code&gt;$ git commit -a -m 'Explain what I changed'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建一个补丁（patch）：&lt;br /&gt;
&lt;code&gt;$ git format-patch origin/master&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;1.3. 创建一个本地git库&lt;/h3&gt;
&lt;p&gt;将一个现有的本地目录初始化为git库：&lt;br /&gt;
&lt;code&gt;$ cd (project-directory)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ (add some files)&lt;/code&gt;&lt;br /&gt;
添加当前目录中所有文件到git库：&lt;br /&gt;
&lt;code&gt;$ git add .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交更改到本地git库：&lt;br /&gt;
&lt;code&gt;$ git commit -m 'Initial commit'&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;1.4. 团队协作&lt;/h3&gt;
&lt;p&gt;获取远程git库的最新版本，且合并到本地（这实际上包含git fetch和git merge）：&lt;br /&gt;
&lt;code&gt;$ git pull&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交所有更改到远程git库：&lt;br /&gt;
&lt;code&gt;$ git push&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;1.5. 查看日志&lt;/h3&gt;
&lt;p&gt;查看当前git库状态：&lt;br /&gt;
&lt;code&gt;$ git status&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显示所有提交日志：&lt;br /&gt;
&lt;code&gt;$ git log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;显示所有提交日志，以及每次提交的具体变化：&lt;br /&gt;
&lt;code&gt;$ git log -p&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;2. 项目托管平台的使用（以GitHub为例）&lt;/h2&gt;
&lt;h3&gt;2.1. GitHub初始设置&lt;/h3&gt;
&lt;p&gt;检查SSH密钥是否存在，若已存在，则备份旧的密钥并删除：&lt;br /&gt;
&lt;code&gt;$ cd ~/.ssh&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ ls&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;config id_rsa id_rsa.pub known_hosts&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ mkdir key_backup&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ cp id_rsa* key_backup&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ rm id_rsa*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置自己的密钥短语（passphrase），生成一对新的SSH密钥：&lt;br /&gt;
&lt;code&gt;$ ssh-keygen -t rsa -C &quot;your_email&lt;/code&gt;&lt;code&gt;@youremail.com&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加SSH公钥到GitHub：&lt;br /&gt;
在GitHub页面上点击Account Settings &amp;gt; &lt;span class=&quot;caps&quot;&gt;SSH&lt;/span&gt; Public Keys &amp;gt; Add another public key，添加id_rsa.pub文件里的所有内容（SSH公钥）。&lt;/p&gt;
&lt;p&gt;确认SSH认证：&lt;br /&gt;
&lt;code&gt;$ ssh -T git&lt;/code&gt;&lt;code&gt;@github.com&lt;/code&gt;&lt;br /&gt;
输入yes确认连接，并输入自己的密码短语。显示如下：&lt;br /&gt;
&lt;code&gt;Hi username! You've successfully authenticated, but GitHub does not provide shell access.&lt;/code&gt;&lt;br /&gt;
表明已正确认证SSH密钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 如果以后修改了SSH密钥后提示如下错误信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Agent admitted failure to sign using the key.
Permission denied (publickey).
fatal: The remote end hung up unexpectedly&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你需要手动添加自己的SSH密钥：&lt;br /&gt;
&lt;code&gt;$ ssh-add ~/.ssh/id_rsa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在本地设置自己的全局用户名与邮箱（同前）：&lt;br /&gt;
&lt;code&gt;$ git config --global user.name &quot;Firstname Lastname&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git config --global user.email your_email&lt;/code&gt;&lt;code&gt;@youremail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;允许单独地为某个git库设置另外的用户名与邮箱：&lt;br /&gt;
&lt;code&gt;$ cd my_other_repo&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git config user.name &quot;Different Name&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git config user.email your_email&lt;/code&gt;&lt;code&gt;@youremail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置令牌（token）：一些工具并非使用SSH连接GitHub。为了使这些工具能够正常工作，需要找到并设置自己的API令牌。&lt;br /&gt;
在GitHub页面上点击Account Settings &amp;gt; Account Admin，找到自己的API Token。&lt;br /&gt;
设置全局用户名和令牌：&lt;br /&gt;
&lt;code&gt;$ git config --global github.user username&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git config --global github.token 0123456789yourf0123456789token&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 如果更改了GitHub的账号密码，一个新的令牌将会被生成，需要重新在命令行下设置。&lt;/p&gt;
&lt;h3&gt;2.2. 创建一个新的仓储（repository, repo）&lt;/h3&gt;
&lt;p&gt;在GitHub页面上点击New Repository，创建一个新的仓储。&lt;/p&gt;
&lt;p&gt;在本地创建一个git库，并新建一个README文件：&lt;br /&gt;
&lt;code&gt;$ mkdir ~/Hello-World&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ cd ~/Hello-World&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git init&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ touch README&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加README文件并提交到本地git库：&lt;br /&gt;
&lt;code&gt;$ git add README&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git commit -m 'first commit'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加远程端“origin”，提交所有更改到远程端“origin”的master分支：&lt;br /&gt;
&lt;code&gt;$ git remote add origin git&lt;/code&gt;&lt;code&gt;@github.com:username/Hello-World.git&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git push -u origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看远程端信息：&lt;br /&gt;
&lt;code&gt;$ git remote -v&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2.3. 分叉（fork）一个已有的仓储&lt;/h3&gt;
&lt;p&gt;在GitHub项目页面上点击&amp;quot;Fork&amp;quot;。&lt;/p&gt;
&lt;p&gt;复制远程git库到本地（分叉产生的仓储自动为“origin”远程端）：&lt;br /&gt;
&lt;code&gt;$ git clone git&lt;/code&gt;&lt;code&gt;@github.com:username/Spoon-Knife.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;添加远程端“upstream”，用于追踪上游仓储：&lt;br /&gt;
&lt;code&gt;$ cd Spoon-Knife&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git remote add upstream git://github.com/octocat/Spoon-Knife.git&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git fetch upstream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交所有更改到远程端“origin”的master分支：&lt;br /&gt;
&lt;code&gt;$ git push origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取来自上游仓储（远程端“upstream”）的更改：&lt;br /&gt;
&lt;code&gt;$ git fetch upstream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将上游（远程端“upstream”）的master分支合并到本地：&lt;br /&gt;
&lt;code&gt;$ git merge upstream/master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可直接获取来自上游仓储的更改且合并到本地：&lt;br /&gt;
&lt;code&gt;$ git pull upstream&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2.4. 使用分支（branch）进行工作&lt;/h3&gt;
&lt;p&gt;创建一个新的分支：&lt;br /&gt;
&lt;code&gt;$ git branch mybranch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用分支进行工作：&lt;br /&gt;
&lt;code&gt;$ git checkout mybranch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可直接创建一个新的分支并使用其工作：&lt;br /&gt;
&lt;code&gt;$ git checkout -b mybranch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在不同分支之间切换：&lt;br /&gt;
&lt;code&gt;$ git checkout master&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ git checkout mybranch&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2.5. 三种常见的Git地址&lt;/h3&gt;
&lt;ol&gt;
	&lt;li&gt;Git：
	&lt;ul&gt;
		&lt;li&gt;&lt;code&gt;git&lt;/code&gt; @ &lt;code&gt;github.com:username/Hello-World.git&lt;/code&gt;&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
	&lt;li&gt;HTTPS（443），用于Git默认端口（9418）受限时：
	&lt;ul&gt;
		&lt;li&gt;&lt;code&gt;https://soimort&lt;/code&gt;&lt;code&gt;@github.com/username/Hello-World.git&lt;/code&gt;&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
	&lt;li&gt;Git Read-Only，用于没有写权限的远程git库：
	&lt;ul&gt;
		&lt;li&gt;&lt;code&gt;git://github.com/username/Hello-World.git&lt;/code&gt;&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3. 其他流行的分布式版本控制系统&lt;/h2&gt;
&lt;h3&gt;3.1. Mercurial&lt;/h3&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mercurial&quot;&gt;[Wikipedia: Mercurial]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://mercurial.selenic.com/&quot;&gt;[Mercurial]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.2. Bazaar&lt;/h3&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bazaar_(software)&quot;&gt;[Wikipedia: Bazaar]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://bazaar.canonical.com/en/&quot;&gt;[Bazaar]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Distributed_Version_Control_System&quot;&gt;[Wikipedia: &lt;span class=&quot;caps&quot;&gt;DVCS&lt;/span&gt;]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Git_(software)&quot;&gt;[Wikipedia: Git]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://git-scm.com/&quot;&gt;[Git]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://book.git-scm.com/book.pdf&quot; title=&quot;PDF format&quot;&gt;Git Community Book&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://git.or.cz/index.html&quot;&gt;Git – Fast Version Control System&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://hoth.entp.com/output/git_for_designers.html&quot;&gt;Git for Designers&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://eagain.net/articles/git-for-computer-scientists/&quot;&gt;Git for Computer Scientists&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://progit.org/book/&quot;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://progit.org/book/zh/&quot;&gt;Pro Git（简体中文）&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/&quot;&gt;Git Magic&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/&quot;&gt;Git Magic（简体中文）&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://ftp.newartisans.com/pub/git.from.bottom.up.pdf&quot; title=&quot;PDF format&quot;&gt;Git from the bottom up&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://blog.enjoyrails.com/2008/12/31/git%E4%B8%80%E5%88%86%E9%92%9F%E6%95%99%E7%A8%8B/&quot;&gt;Git一分钟教程（简体中文）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://help.github.com/&quot;&gt;GitHub Help&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://help.github.com/win-set-up-git/&quot;&gt;GitHub Help &amp;#8211; Set Up Git&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://help.github.com/create-a-repo/&quot;&gt;GitHub Help &amp;#8211; Create A Repository&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://help.github.com/fork-a-repo/&quot;&gt;GitHub Help &amp;#8211; Fork A Repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    </entry>
    
    
    
    
    
    
    
    <entry>
        <title>版本控制系统入门 (I). Subversion</title>
        <link href="http://www.soimort.org/posts/103" />
        <updated>2011-12-30T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/103/scm-1_zh</id>
        <content type="html">&lt;h2&gt;0. 预备知识&lt;/h2&gt;
&lt;p&gt;本文讲解软件开发中常用的软件配置管理（Software Configuration Management, SCM）工具，即版本控制系统（Version Control System, VCS）。读者需要具备一定的实际开发经验，并且熟悉Linux或类Unix系统下的命令行操作。&lt;/p&gt;
&lt;h2&gt;1. 为何需要配置管理？&lt;/h2&gt;
&lt;p&gt;配置管理（Configuration Management, CM）是一种用于“管理变化”的工具。让我们假设有两名技术文档员Bob和Susan，他们同时参与了一个技术手册的更新维护工作。在一次例会上，经理给他们两人各分配了更新同一个文档中不同章节的任务。&lt;/p&gt;
&lt;p&gt;这个技术手册存放在一个Bob和Susan都能够访问的服务器上。在没有任何配置管理工具，也没有人为地进行适当的进度协调时，会产生一些问题。一种避免出现问题的手段是，存储该文档的服务器经过设置，使得Bob和Susan无法在同一时间打开这份文档进行工作。但这显然会降低这项工作的效率。&lt;/p&gt;
&lt;p&gt;当存储用的服务器允许该文档同时被Bob和Susan打开并进行写操作时，更加危险的情形出现了。以下是可能会发生的状况：&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Bob在他的计算机上打开了文档的一个拷贝，更新属于他任务的一部分章节。&lt;/li&gt;
	&lt;li&gt;Susan在她的计算机上打开了文档的一个拷贝，更新属于她任务的另一部分章节。&lt;/li&gt;
	&lt;li&gt;Bob完成了他的更改，在存储服务器上写入了该文档。&lt;/li&gt;
	&lt;li&gt;Susan完成了她的更改，在存储服务器上写入了该文档。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图显示了当该文档的拷贝没有被适当地控制协调时，将会产生的问题。当Susan保存她自己的更改时，她同时也覆盖了之前由Bob所做的那些更改！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://code.google.com/edu/images/cm1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这正是配置管理系统大显身手的场合。借助于配置管理系统，Bob和Susan都可以“ &lt;strong&gt;签出（check out）&lt;/strong&gt; ”他们自己的一份技术文档的拷贝并进行工作。当Bob将他的更改重新“ &lt;strong&gt;签入（check in）&lt;/strong&gt; ”回系统时，系统知道Susan也已经签出了她的一份拷贝。之后当Susan签入她的更改时，系统会自动分析Bob和Susan所分别做出的更改并且 &lt;strong&gt;合并（merge）&lt;/strong&gt; 两份拷贝，创建出一个新的版本。&lt;/p&gt;
&lt;p&gt;除了管理并发的更改之外，配置管理系统还有其他若干有用的功能。很多系统将每个文件自创建起的所有历史版本都进行了存档。在以上维护技术手册的案例中，这项功能非常有用，因为用户在针对技术手册的内容向软件维护人员提问时，可能正使用着某个较旧版本的文档。配置管理系统允许维护者访问处于过去某个时间点状态的文件，看到用户所见的实际版本。&lt;/p&gt;
&lt;p&gt;配置管理系统在控制软件源代码的更改时尤其有用。这类系统被称作软件配置管理（Software Configuration Management, SCM）系统。在一个大型的软件项目库中通常存在着大量的独立的源代码文件，并且同时由庞大的工程师团队开发和维护，显然软件配置管理系统在这里将起到至关重要的作用。&lt;/p&gt;
&lt;h2&gt;2. 软件配置管理&lt;/h2&gt;
&lt;p&gt;软件配置管理系统基于一个简单的原理：所有文件的决定性内容被统一存放在一个中心仓储里，人们可以“签出”这些文件的拷贝到本地机，利用这些拷贝独立地进行工作，当完成工作后“签入”回中心仓储。软件配置管理系统将会追踪和管理每一个对“唯一的”主版本所作的修改。&lt;/p&gt;
&lt;p&gt;几乎所有现代的软件配置管理系统均提供以下的功能：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;并发（concurrency）管理&lt;/li&gt;
	&lt;li&gt;版本化&lt;/li&gt;
	&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.1. 并发管理&lt;/h3&gt;
&lt;p&gt;并发管理指一人以上同时编辑一份文件。对于较大的软件仓储，我们经常希望能够做到这一点，但这可能带来一些问题。&lt;/p&gt;
&lt;p&gt;考虑软件开发中的一个简单例子：假定我们允许工程师同时修改中心仓储中的同一份源代码文件。客户端1和客户端2的工程师同时需要对一份文件做出更改：&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;客户端1打开了bar.cpp。&lt;/li&gt;
	&lt;li&gt;客户端2打开了bar.cpp。&lt;/li&gt;
	&lt;li&gt;客户端1修改了文件并且写入仓储。&lt;/li&gt;
	&lt;li&gt;客户端2修改了文件并且写入仓储，这覆盖了客户端1做出的更改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，我们并不想看到这种情形发生。即使我们通过限制两个工程师必须利用自己的本地拷贝进行工作以避免发生覆盖的危险，这两份独立的拷贝最终也必须被协调为一致。为了解决这个问题，大部分软件配置管理系统允许多个工程师签出一份文件的拷贝（&amp;quot;sync&amp;quot;或&amp;quot;update&amp;quot;）并根据需要做出修改，系统在这些文件被签入回仓储（&amp;quot;submit&amp;quot;或&amp;quot;commit&amp;quot;）后执行某种特定的算法，用以最终合并这些更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://code.google.com/edu/images/sync.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这些算法可以从简单（直接询问工程师如何解决冲突）到复杂（自动决定如何合并发生冲突的更改，除非遇到系统无法处理的情形）。&lt;/p&gt;
&lt;h3&gt;2.2. 版本化&lt;/h3&gt;
&lt;p&gt;版本化指追踪并保存文件的变化以供重新生成（或“回滚”到）某个文件的任意早期版本。这通过在每个文件被签入仓储时生成一个存档拷贝，或记录每个文件的每一次具体变化来实现。在任意时刻，我们可以使用这些存档或变化信息来生成一个较早的版本。版本系统也可以生成日志报告，包含谁于何时签入了这些变化、以及具体的变化等信息。&lt;/p&gt;
&lt;h3&gt;2.3. 同步&lt;/h3&gt;
&lt;p&gt;对于某些软件配置管理系统而言，仅仅能从仓储中签入或签出独立的单个文件。更加先进的系统允许一次同时签出多个文件。工程师签出他们自己的一份完整的（或部分的）仓储的拷贝，并利用其需要的文件进行工作。之后他们定期地提交自己的修改回主仓储，并且更新他们自己的拷贝以及时地获取其他工程师做出的修改。这一过程称作同步或更新。&lt;/p&gt;
&lt;h2&gt;3. 版本控制中的常见概念&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;strong&gt;修订（revision）&lt;/strong&gt; : 对于一个或一组文件作出的更改。在一个持续开发的项目中，一个修订相当于项目当前的一个“快照（snapshot）”。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;仓储（repository）&lt;/strong&gt; : 版本控制系统存储一个项目及其全部修订历史记录的主拷贝。每个项目均有且仅有一个仓储。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;工作拷贝（working copy）&lt;/strong&gt; : 工程师实际用于工作并修改的本地项目拷贝。对于每个工程师而言，可以同时存在多份工作拷贝。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;签出（check out）&lt;/strong&gt; : 从仓储请求获得一份工作拷贝。一份工作拷贝刚被签出时的状态与项目的当前状态完全等同。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;提交（commit）&lt;/strong&gt; : 将工作拷贝中的更改提交至中心仓储。又叫 &lt;strong&gt;签入（check in）&lt;/strong&gt; 或 &lt;strong&gt;submit&lt;/strong&gt; 。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;签入（check in）&lt;/strong&gt; : 将工作拷贝中的更改提交至中心仓储。又叫 &lt;strong&gt;提交（commit）&lt;/strong&gt; 或 &lt;strong&gt;submit&lt;/strong&gt; 。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;更新（update）&lt;/strong&gt; : 将其他人在仓储中所做的更改同步更新至自己的工作拷贝，或者仅仅检查工作拷贝是否存在未提交的更改。这与前面提到过的 &lt;strong&gt;同步（sync）&lt;/strong&gt; 概念相同。因此，更新/同步将保证本地工作拷贝与仓储及时保持同步状态。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;合并（merge）&lt;/strong&gt; : 将工作拷贝中的更改与仓储中的更改合并，创建出一个新的版本。注意：两份更改在合并过程中可能会产生冲突。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;冲突（conflict）&lt;/strong&gt; : 当两个工程师试着提交对于同一文件中同一部分的更改时发生。版本控制系统将作出提示，然后由工程师自行决定如何解决冲突。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;日志信息（log message）&lt;/strong&gt; :&lt;br /&gt;
提交一个修订时附加的一段文本注释，描述了所作出的变更。日志信息可以显示出一个项目开发历史进展的大致状况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. Subversion简介&lt;/h2&gt;
&lt;p&gt;Subversion（缩写SVN）是一个流行的开源版本控制系统。它具备上述的全部功能。Subversion由另一个早期的集中式版本控制系统CVS演变而来，其目的是最终取代CVS，提供一套更为强大的版本控制机制。&lt;/p&gt;
&lt;p&gt;对于可能发生的冲突，SVN遵循一种极简单的方法论：冲突总是在两个或更多工程师对于源代码的同一部分作出不同更改、并且都提交了更改的情形下发生。SVN所做的仅仅是警告工程师有一个冲突发生了——如何解决则必须由工程师自行决定。&lt;/p&gt;
&lt;p&gt;在指定的目录中创建一个仓储，使用 &lt;code&gt;svn import&lt;/code&gt; 命令导入已有目录中的内容到项目仓储：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/project -m &quot;Initial import&quot;
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/foobar.h
Committed revision 1.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;svn list&lt;/code&gt; 命令可以查看仓储目录内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn list file:///usr/local/svn/newrepos/project
bar.c
foo.c
subdir/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面的 &lt;code&gt;svn import&lt;/code&gt; 命令并未实际创建任何工作拷贝。如要签出一份工作拷贝，需要执行 &lt;code&gt;svn checkout&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn checkout file:///usr/local/svn/newrepos/project
A    foo.c
A    bar.c
A    subdir
A    subdir/foobar.h
.
Checked out revision 215.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你已经有了一份工作拷贝，可以修改其中的文件和目录了！工作拷贝与文件系统中其他普通的目录一样，可以在其中任意添加、编辑或移动文件，甚至可以删除整个工作拷贝。注意，如果在工作拷贝中复制或移动文件，必须使用 &lt;code&gt;svn copy&lt;/code&gt; 和 &lt;code&gt;svn move&lt;/code&gt; 命令代替正常的操作系统命令。添加一个新文件使用 &lt;code&gt;svn add&lt;/code&gt; ，删除一个文件使用 &lt;code&gt;svn delete&lt;/code&gt; 。如果你所要做的只是编辑，只需直接打开文件编辑即可。&lt;/p&gt;
&lt;p&gt;注意有一些标准的目录名称会被Subversion使用。“trunk”目录用以保存项目的开发主线。“branches”目录用以保存工作时可能会用到的一些版本分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn list file:///usr/local/svn/repos
/trunk
/branches&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦完成了所需的更改，可以将工作拷贝同步到仓储。如果其他工程师同样也在该仓储上工作，保持你的工作拷贝始终为最新版本非常重要。可以使用 &lt;code&gt;svn status&lt;/code&gt; 命令查看自己所作的更改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn status
A       subdir/new.h      # file is scheduled for addition
D       subdir/old.c      # file is scheduled for deletion
M       bar.c             # the content in bar.c has local modifications&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里有许多用于控制输出的符号。如果想要查看一个被修改文件的具体变化，使用 &lt;code&gt;svn diff&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn diff bar.c
Index: bar.c
=============================================================
--- bar.c	(revision 5)
+++ bar.c	(working copy)
@@ -1,18 +1,19 @@
+#include 
+#include 
int main(void) {
- int temp_var;
+ int new_var;
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;svn update&lt;/code&gt; 命令从仓储更新自己的工作拷贝：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ svn update
U  foo.c
U  bar.c
G  subdir/foobar.h
C  subdir/new.h
Updated to revision 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意可能会发生冲突的地方。在以上的输出中，“U”表明仓储中的这些文件并未发生变化，更新成功；“G”意味着一个合并发生了，因为仓储中的文件版本已经改变，但该变化与你的更改并不冲突；“C”表明发现一个冲突，这意味着仓储中的变化将会覆盖你的更改，因此必须手动在两者之间做出选择。&lt;/p&gt;
&lt;p&gt;对于每次发生冲突的文件，Subversion将在工作拷贝中放置三个临时文件：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;file.mine: 这是在你从仓储更新工作拷贝之前，经过你更改后的文件。&lt;/li&gt;
	&lt;li&gt;file.rOLDREV: 这是在你作出更改之前，从仓储中得到的旧文件。&lt;/li&gt;
	&lt;li&gt;file.rNEWREV: 这是仓储中目前最新版本的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以选择以下三种方式之一解决冲突：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;查看源代码文件并手动进行合并。&lt;/li&gt;
	&lt;li&gt;拷贝以上三个由SVN创建的临时文件之一，覆盖你工作拷贝中的版本。&lt;/li&gt;
	&lt;li&gt;执行 &lt;code&gt;svn revert&lt;/code&gt; ，放弃你所做出的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦你解决了冲突问题，你应当执行 &lt;code&gt;svn resolved&lt;/code&gt; 命令通知SVN。这将使得SVN移除这三个临时文件，并且不再认为该文件处于冲突状态。&lt;/p&gt;
&lt;p&gt;最后一件要做的事情就是通过 &lt;code&gt;svn commit&lt;/code&gt; 命令提交你最终版本的工作拷贝到仓储！当你提交一个更改时，你应当附上一条日志信息，用以描述你所作的更改。该日志信息将附在你所创建的修订上：&lt;br /&gt;
&lt;code&gt;$ svn commit -m &quot;Update files to include new headers.&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;5. 其他早期的集中式版本控制系统&lt;/h2&gt;
&lt;h3&gt;5.1. SCCS（Source Code Control System）和RCS （Revision Control System）&lt;/h3&gt;
&lt;p&gt;早期的软件配置管理系统是面向Unix主机系统的，它们只允许在本地大型Unix主机的仓储上进行协作开发。这类典型的工具有SCCS和RCS，它们采取强行限制写访问权限的版本控制方式，即通过在用户签出文件之后立即锁定该文件的方法，控制同一时刻只允许一个用户进行写操作。&lt;/p&gt;
&lt;h3&gt;5.2. &lt;span class=&quot;caps&quot;&gt;CVS&lt;/span&gt; (Concurrent Version System)&lt;/h3&gt;
&lt;p&gt;CVS由主机系统上的RCS演变而成，它不仅像RCS一样允许锁定文件，更支持对同一文件的并发工作。CVS支持客户端-服务器模式的开发模式，中心仓储不仅限于本地，而且可以存放在远程的服务器上以供开发人员访问。CVS是面向项目的管理工具，比起RCS也更加适合多目录层次的项目管理。&lt;/p&gt;
&lt;p&gt;创建新的仓储目录，将其路径加入到环境变量$CVSROOT中（bash下）：&lt;br /&gt;
&lt;code&gt;$ export CVSROOT=/usr/local/cvsdepot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在指定目录下初始化仓储：&lt;br /&gt;
&lt;code&gt;$ cvs -d /usr/local/cvsdepot init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将目录中所有文件内容导入仓储：&lt;br /&gt;
&lt;code&gt;$ cvs import -m &quot;Imported project files.&quot; projectname vendortag releasetag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;签出一份工作拷贝到本地当前路径下的projectname目录：&lt;br /&gt;
&lt;code&gt;$ cvs checkout projectname&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提交工作拷贝到仓储：&lt;br /&gt;
&lt;code&gt;$ cvs commit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从仓储更新工作拷贝：&lt;br /&gt;
&lt;code&gt;$ cvs update&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://code.google.com/edu/tools101/scm.html&quot;&gt;Google Code University &amp;#8211; Software Configuration Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Subversion_%28software%29&quot;&gt;[Wikipedia: Subversion]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://subversion.tigris.org/&quot;&gt;[Subversion]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://svnbook.red-bean.com/en/1.7/&quot;&gt;Version Control with Subversion, For Subversion 1.7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Revision_Control_System&quot;&gt;[Wikipedia: &lt;span class=&quot;caps&quot;&gt;RCS&lt;/span&gt;]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/rcs/&quot;&gt;[&lt;span class=&quot;caps&quot;&gt;RCS&lt;/span&gt;]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Concurrent_Versions_System&quot;&gt;[Wikipedia: &lt;span class=&quot;caps&quot;&gt;CVS&lt;/span&gt;]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://savannah.nongnu.org/projects/cvs/&quot;&gt;[&lt;span class=&quot;caps&quot;&gt;CVS&lt;/span&gt;]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    </entry>
    
    
    
    
    
    <entry>
        <title>Qt编码风格约定</title>
        <link href="http://www.soimort.org/posts/102" />
        <updated>2011-12-29T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/102/qt-coding-style_zh</id>
        <content type="html">&lt;p&gt;原文地址： &lt;a href=&quot;http://wiki.qt-project.org/Coding_Style&quot;&gt;http://wiki.qt-project.org/Coding_Style&lt;/a&gt;&lt;br /&gt;
中文翻译： by &lt;a href=&quot;http://www.soimort.org&quot;&gt;Mort&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里是对编写Qt代码时编码风格约定的概述。&lt;br /&gt;
数据通过对Qt源码库、论坛和邮件列表的发掘，经开发者的协作整理而成。&lt;/p&gt;
&lt;h2&gt;缩进（Indentation）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;每一级缩进使用4个空格。&lt;/li&gt;
	&lt;li&gt;使用空格，而不是制表符tab！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;声明变量（Declaring variables）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;每个变量应分别在单独的一行声明。&lt;/li&gt;
	&lt;li&gt;尽可能避免使用过短的（如：“a”、“rbarr”、“nughdeget”）变量名。&lt;/li&gt;
	&lt;li&gt;单字符的变量名仅在作为计数器或临时变量、其用途显而易见时方可使用。&lt;/li&gt;
	&lt;li&gt;当需要用到一个变量时，再对它进行声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
int a, b;
char *c, *d;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
int height;
int width;
char *nameOfThis;
char *nameOfThat;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;变量和函数名称应以小写字母开头。名称中间的每个单词均以大写字母打头。&lt;/li&gt;
	&lt;li&gt;避免使用缩写。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
short Cntr;
char ITEM_DELIM = '\t';&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
short counter;
char itemDelimiter = '\t';&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;类的名称总是以大写字母开头。公用类以‘Q’开头（如：QRgb）。公用函数大部分以‘q’开头（如：qRgb）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;空格（Whitespace）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;使用空行在合适的位置区分代码段。&lt;/li&gt;
	&lt;li&gt;仅使用一个空行。&lt;/li&gt;
	&lt;li&gt;在关键词的后面，或花括号的前面，使用一个且仅一个空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if(foo){
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (foo) {
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;对于指针或引用，总是在类型和‘*’或‘&amp;amp;’之间使用单个空格分隔，但在‘*’或‘&amp;amp;’与变量名之间则没有任何空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;char *x;
const QString &amp;amp;myString;
const char * const y = &quot;hello&quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;在二元运算符的前后使用空格分隔。&lt;/li&gt;
	&lt;li&gt;强制类型转换（cast）后面不加空格。&lt;/li&gt;
	&lt;li&gt;尽可能避免C风格的强制类型转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
char* blockOfMemory = (char* ) malloc(data.size());&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
char *blockOfMemory = reinterpret_cast&amp;lt;char *&amp;gt;(malloc(data.size()));&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;花括号（Braces）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;作为一条基本准则，左花括号总是紧接着上一行作为代码段的开始：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (codec)
{
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (codec) {
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;特例：函数的实现和类的声明中，左花括号总是从单独的一行开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;static void foo(int g)
{
    qDebug(&quot;foo: %i&quot;, g);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;class Moo
{
};&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;当条件判断的代码段中包含一行以上语句，或只有一行语句但相当复杂时，使用花括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (address.isEmpty()) {
    return false;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 10; ++i) {
    qDebug(&quot;%i&quot;, i);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (address.isEmpty())
    return false;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 10; ++i)
    qDebug(&quot;%i&quot;, i);&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;特例1：当父代码段语句覆盖多行或存在卷起（wrap）时，应当使用花括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (address.isEmpty() || !isValid()
    || !codec) {
    return false;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;特例2：当if-then-else中的if语句块或else语句块覆盖多行时，也应当使用花括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (address.isEmpty())
    return false;
else {
    qDebug(&quot;%s&quot;, qPrintable(address));
    ++it;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (address.isEmpty()) {
    return false;
} else {
    qDebug(&quot;%s&quot;, qPrintable(address));
    ++it;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (a)
    if (b)
        ...
    else
        ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (a) {
    if (b)
        ...
    else
        ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;当一个条件判断代码段的内容为空时，应当加上花括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
while (a);&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
while (a) {}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;圆括号（Parentheses）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;使用圆括号对表达式进行分组：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (a &amp;amp;&amp;amp; b || c)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if ((a &amp;amp;&amp;amp; b) || c)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
a + b &amp;amp; c&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
(a + b) &amp;amp; c&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Switch语句（Switch statements）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;case关键词和switch出现在同一列（没有缩进）。&lt;/li&gt;
	&lt;li&gt;除非下一个case紧接其后立即出现，否则每一个case的结束必须有一个break（或return）语句，或者明确说明这里不应break的一个注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;switch (myEnum) {
case Value1:
    doSomething();
    break;
case Value2:
case Value3:
    doSomethingElse();
    // fall through
default:
    defaultHandling();
    break;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;分行（Line breaks）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;保持行的长度小于100个字符；在必要的时候应当进行分行。&lt;/li&gt;
	&lt;li&gt;分行后的逗号应当出现在上一行的结尾；运算符应当出现在下一行的开头。在行末出现的运算符很容易因为编辑器显示范围有限而被忽视。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 正确的
if (longExpression
    + otherLongExpression
    + otherOtherLongExpression) {
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 错误的
if (longExpression +
    otherLongExpression +
    otherOtherLongExpression) {
}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;继承和‘virtual’关键词（Inheritance and the `virtual` keyword）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;当重实现一个虚方法时，不要把‘virtual’关键词放在头文件当中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一般适用的特例（General exception）&lt;/h2&gt;
&lt;ul&gt;
	&lt;li&gt;如果某条规则使你的代码看上去很差劲，尽管去破坏它！&lt;/li&gt;
&lt;/ul&gt;</content>
    </entry>
    
    
    
    
    
    
    
    
    
    <entry>
        <title>像黑客一样写博客——Jekyll入门</title>
        <link href="http://www.soimort.org/posts/101" />
        <updated>2011-11-19T00:00:00+08:00</updated>
        <id>http://www.soimort.org/posts/101/introduction-to-jekyll_zh</id>
        <content type="html">&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 是一个简洁的、特别针对博客平台的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Static_site&quot;&gt;静态网站&lt;/a&gt; 生成器。它使用一个模板目录作为网站布局的基础框架，并在其上运行 &lt;a href=&quot;http://en.wikipedia.org/wiki/Textile_(markup_language)&quot;&gt;Textile&lt;/a&gt; 、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt; 或 &lt;a href=&quot;http://liquidmarkup.org/&quot;&gt;Liquid&lt;/a&gt; 标记语言的转换器，最终生成一个完整的静态Web站点，可以被放置在Apache或者你喜欢的其他任何Web服务器上。它同时也是 &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; 、一个由 &lt;a href=&quot;http://www.github.com/&quot;&gt;GitHub&lt;/a&gt; 提供的用于托管项目主页或博客的服务，在后台所运行的引擎。&lt;/p&gt;
&lt;p&gt;你可以去 &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;这里&lt;/a&gt; 围观一些现有的使用Jekyll搭建的网站。本站（ &lt;a href=&quot;http://www.soimort.org&quot;&gt;www.soimort.org&lt;/a&gt; ）同样亦是基于Jekyll构建。&lt;/p&gt;
&lt;p&gt;如果有任何问题，请加入 &lt;a href=&quot;http://groups.google.com/group/jekyll-rb&quot;&gt;官方邮件组&lt;/a&gt; 的讨论，或访问Freenode上的IRC频道 &lt;a href=&quot;irc://irc.freenode.net/jekyll&quot;&gt;#Jekyll&lt;/a&gt; （chat.freenode.net）。&lt;/p&gt;
&lt;p&gt;本中文入门教程由 &lt;a href=&quot;http://www.soimort.org/&quot;&gt;Mort&lt;/a&gt; 基于 &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;Jekyll的官方Wiki&lt;/a&gt; 等网页内容翻译整理并维护。&lt;/p&gt;
&lt;h2&gt;为何要使用静态网站生成器（Static Site Generators）？&lt;/h2&gt;
&lt;p&gt;不同于 &lt;a href=&quot;http://wordpress.com/&quot;&gt;WordPress&lt;/a&gt; 这类博客平台（以及其他众多流行的CMS内容管理系统）在服务器端执行PHP等语言的动态框架、访问SQL数据库并动态产生Web页面的工作方式，静态网站生成器的原理十分简单：将所有的页面、布局和帖子集合在一起，预先生成静态的站点。对于动态内容并非必要的站点——例如个人博客，静态网站生成器这样做有几个明显的优势：&lt;/p&gt;
&lt;h3&gt;快速访问和弱服务器需求&lt;/h3&gt;
&lt;p&gt;静态HTML页面的载入速度理所当然地更快——因为它无需在服务器端执行任何代码。同时，这还大大地减轻了服务器的压力。&lt;/p&gt;
&lt;h3&gt;高安全性&lt;/h3&gt;
&lt;p&gt;基于与上述相同的理由，静态页面有着与生俱来的安全性。不像WordPress或者其他任何动态的框架，静态站点本身并不存在安全漏洞的问题。&lt;/p&gt;
&lt;h3&gt;版本控制&lt;/h3&gt;
&lt;p&gt;你无需通过WordPress来维护一整个复杂的数据库——静态站点的内容完全仅由文件系统中独立的目录和文件构成，这意味着你不但可以使用Shell、grep、sed、awk这些传统的Unix工具对它们执行操作和维护，更可以使用 &lt;a href=&quot;http://git-scm.com/&quot;&gt;Git&lt;/a&gt; 这样的分布式版本控制系统来管理它们，并且享受版本控制所带来的一切好处，如同维护任何软件项目的源代码库一样。你甚至可以重新生成以前任意时间点的整个网站！&lt;/p&gt;
&lt;h3&gt;简单部署&lt;/h3&gt;
&lt;p&gt;一旦静态网站生成以后，任何Web服务器都能够轻易地部署静态站点，而无须在服务器端安装配置其他任何多余的东西。你所需要做的仅仅是通过git、rsync甚至ftp简单地上传文件到你的托管服务器。相比之下，WordPress博客的维护显得复杂得多，你可能需要在你的开发服务器和托管服务器上安装、配置一整套LAMP+WordPress平台，并经常性地升级版本和维护。这是个繁重的技术活。&lt;/p&gt;
&lt;h3&gt;文本编辑器和自由格式书写&lt;/h3&gt;
&lt;p&gt;也许你不这么认为，但是作为一个hacker而言，在浏览器中一个300x300的文本区里码字写博客并非一件很酷的事情——如果你使用Jekyll这样的静态网站生成器，你就可以用你喜欢的任何文本编辑器（vi、emacs……），用你习惯的标记语言以书写文本文件的方式来直接写博客文章（就好像你平常写代码一样），避免了使用那些简陋和功能有限的Web界面。&lt;/p&gt;
&lt;h2&gt;1. 安装&lt;/h2&gt;
&lt;p&gt;Jekyll使用动态脚本语言 &lt;a href=&quot;http://zh.wikipedia.org/wiki/Ruby&quot;&gt;Ruby&lt;/a&gt; 写成。请首先 &lt;a href=&quot;http://www.ruby-lang.org/zh_cn/downloads/&quot;&gt;下载并安装Ruby（中文）&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在使用Jekyll之前，你可能想要对Ruby语言有一些初步了解（非必需）。推荐阅读官方网站上的 &lt;a href=&quot;http://www.ruby-lang.org/zh_cn/documentation/quickstart/&quot;&gt;20分钟体验Ruby（中文）&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;安装Jekyll的最好方式是通过RubyGems：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gem install jekyll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Jekyll依赖以下的gems模块： &lt;code&gt;liquid&lt;/code&gt; 、 &lt;code&gt;fast-stemmer&lt;/code&gt; 、 &lt;code&gt;classifier&lt;/code&gt; 、 &lt;code&gt;directory_watcher&lt;/code&gt; 、 &lt;code&gt;syntax&lt;/code&gt; 、 &lt;code&gt;maruku&lt;/code&gt; 、 &lt;code&gt;kramdown&lt;/code&gt; 、 &lt;code&gt;posix-spawn&lt;/code&gt; 和 &lt;code&gt;albino&lt;/code&gt; 。它们会被gem install命令自动安装。&lt;/p&gt;
&lt;p&gt;如果你在gem的安装过程中遇到了问题，你可能需要安装用于在Ruby 1.8上编译扩展模块的头文件。在Debian系统上使用如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo apt-get install ruby1.8-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Red Hat / CentOS / Fedora平台上则是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo yum install ruby-devel&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;http://nearlyfreespeech.net/&quot;&gt;NearlyFreeSpeech&lt;/a&gt; 上你需要：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ RB_USER_INSTALL=true gem install jekyll&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你在Windows平台上看到如下错误提示信息： &lt;code&gt;Failed to build gem native extension&lt;/code&gt; ，你可能需要安装 &lt;a href=&quot;http://wiki.github.com/oneclick/rubyinstaller/development-kit&quot;&gt;RubyInstaller DevKit&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在OS X上，你可能需要升级你的RubyGems：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gem update --system&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;LaTeX转换到PNG&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://maruku.rubyforge.org/&quot;&gt;Maruku&lt;/a&gt; 内置可选的转换LaTeX格式到PNG图片的支持。它通过0.6版的blahtex进行渲染，这和 &lt;code&gt;dvips&lt;/code&gt; 同样都必须存在于你的$PATH环境变量中。&lt;/p&gt;
&lt;p&gt;（注意： &lt;a href=&quot;http://github.com/remi/maruku/tree/master&quot;&gt;remi的Maruku分支&lt;/a&gt; 并不使用修正的 &lt;code&gt;dvips&lt;/code&gt; 路径，如果你需要修改它的话。）&lt;/p&gt;
&lt;h3&gt;RDiscount&lt;/h3&gt;
&lt;p&gt;如果你想用 &lt;a href=&quot;http://github.com/rtomayko/rdiscount/tree/master&quot;&gt;RDiscount&lt;/a&gt; 取代 &lt;a href=&quot;http://maruku.rubyforge.org/&quot;&gt;Maruku&lt;/a&gt; 作为你的Markdown标记语言转换引擎，只需确认安装：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gem install rdiscount&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并通过以下命令行参数执行Jekyll：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ jekyll --rdiscount&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者也可以在你站点下的 &lt;code&gt;_config.yml&lt;/code&gt; 文件中加入以下配置，以便以后每次执行时不必再指定命令行参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;markdown: rdiscount&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;RedCloth&lt;/h3&gt;
&lt;p&gt;若要使用Textile标记语言，需要安装相应的转换引擎 &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gem install RedCloth&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Pygments&lt;/h3&gt;
&lt;p&gt;若要通过 {&amp;#37; highlight &amp;#37;} 标签在帖子中嵌入语法高亮的代码，那么需要安装 &lt;a href=&quot;http://pygments.org/&quot;&gt;Pygments&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在OS X Leopard和Snow Leopard平台上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它已经包含在了Python 2.6的预安装包当中：&lt;br /&gt;
&lt;code&gt;$ sudo easy_install Pygments&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在OS X平台上（使用MacPorts）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo port install python25 py25-pygments&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在OS X平台上（使用Homebrew）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
$ brew install python
# export PATH=&quot;/usr/local/Cellar/python:${PATH}&quot;
$ easy_install pip
$ pip install --upgrade distribute
$ pip install pygments
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意：Homebrew并不会为你自动创建可执行文件的符号链接。如果使用Homebrew默认的Cellar目录位置和Python 2.7，请确保你已添加 &lt;code&gt;/usr/local/Cellar/python&lt;/code&gt; 到你的 &lt;code&gt;PATH&lt;/code&gt; 变量中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Arch Linux平台上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo pacman -S python-pygments&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ sudo easy_install-3.2 Pygments&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或选择使用python2版本的pygments：（不推荐）&lt;br /&gt;
&lt;code&gt;$ sudo pacman -S python2-pygments&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$ sudo easy_install-2.7 Pygments&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;注意：&lt;/strong&gt; python2版本的pygments可执行文件名为 &lt;code&gt;pygmentize2&lt;/code&gt; ，而Jekyll所调用的可执行文件是 &lt;code&gt;pygmentize&lt;/code&gt; 。你应当创建一个指向pygmentize的符号链接 &lt;code&gt;# ln -s /usr/bin/pygmentize2 /usr/bin/pygmentize&lt;/code&gt; ，或者直接选择使用Python 3版本的pygments。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Ubuntu和Debian平台上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo apt-get install python-pygments&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Fedora平台上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo yum install python-pygments&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Gentoo平台上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo emerge -av dev-python/pygments&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;2. 使用&lt;/h2&gt;
&lt;p&gt;一旦Jekyll安装成功后，搭建一个Jekyll站点通常包括下面几步：&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;设定站点的基本结构，使用HTML和Liquid模板语言创建网页布局。&lt;/li&gt;
	&lt;li&gt;创建一些帖子，或者从你以前的博客平台导入。&lt;/li&gt;
	&lt;li&gt;在本地测试站点，查看效果。&lt;/li&gt;
	&lt;li&gt;部署你的网站。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;基本结构&lt;/h3&gt;
&lt;p&gt;Jekyll从核心上来说是一个文本转换引擎。该系统内部的工作原理是：你输入一些用自己喜爱的标记语言格式书写的文本，可以是Markdown、Textile或纯粹的HTML，它将这些文本混合后放入一个或一整套页面布局当中。在整个过程中，你可以自行决定你的站点URL的模式、以及哪些数据将被显示在页面中，等等。这一切都将通过严格的文本编辑完成，而生成的Web界面则是最终的产品。&lt;/p&gt;
&lt;p&gt;一个典型的Jekyll站点通常具有如下结构：&lt;/p&gt;
&lt;pre&gt;
.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/pre&gt;
&lt;p&gt;以下是每部分功能的简述：&lt;/p&gt;
&lt;h4&gt;_config.yml&lt;/h4&gt;
&lt;p&gt;保存Jekyll配置的文件。虽然绝大部分选项可以通过命令行参数指定，但将它们写入配置文件可以使你在每次执行时不必记住它们。&lt;/p&gt;
&lt;h4&gt;_includes/&lt;/h4&gt;
&lt;p&gt;该目录存放可以与_layouts和_posts混合、匹配并重用的文件。Liquid标签{&amp;#37; include file.ext &amp;#37;}可以用于嵌入文件_includes/file.ext。&lt;/p&gt;
&lt;h4&gt;_layouts/&lt;/h4&gt;
&lt;p&gt;该目录存放用来插入帖子的网页布局模板。页面布局基于类似博客平台的“一个帖子接一个帖子”的原则，通过YAML前置数据定义。Liquid标签用于在页面上插入帖子的文本内容。&lt;/p&gt;
&lt;h4&gt;_posts/&lt;/h4&gt;
&lt;p&gt;该目录下存放的可以说成是你的“动态内容”。这些文件的格式很重要，它们的命名模式必须遵循 &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; 。每一个帖子的固定链接URL可以作弹性的调整，但帖子的发布日期和转换所使用的标记语言会根据且仅根据文件名中的相应部分来识别。&lt;/p&gt;
&lt;h4&gt;_site/&lt;/h4&gt;
&lt;p&gt;这里是Jekyll用以存放最终生成站点的根路径位置。也许把它加到你的 &lt;code&gt;.gitignore&lt;/code&gt; 列表中会是个不错的主意。&lt;/p&gt;
&lt;h4&gt;index.html和其他HTML/Markdown/Textile文件&lt;/h4&gt;
&lt;p&gt;如果一个文件的头部存在YAML前置数据的部分，那么Jekyll将会自动处理转换该文件并传送到站点路径下。这对于站点的根目录或其他任意子目录下的所有 &lt;code&gt;.html&lt;/code&gt; 、 &lt;code&gt;.markdown&lt;/code&gt; 、 &lt;code&gt;.textile&lt;/code&gt; 文件都适用。&lt;/p&gt;
&lt;h4&gt;其他文件/目录&lt;/h4&gt;
&lt;p&gt;除了以上提到的文件之外，每一个其他的、不以下划线_开头的目录和文件都会被照原样传送到站点路径下。例如，你可以在网站根目录下面添加一个 &lt;code&gt;css&lt;/code&gt; 目录，一个 &lt;code&gt;favicon.ico&lt;/code&gt; ，等等等等。假如你对于怎样实现静态站点布局仍然感到困惑的话，那么这里有不少 &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;基于Jekyll的站点&lt;/a&gt; 可供参考。&lt;/p&gt;
&lt;p&gt;在这些目录下的文件同样会被解析转换和传送，依据处理根目录下文件时的相同规则。&lt;/p&gt;
&lt;h3&gt;运行Jekyll&lt;/h3&gt;
&lt;p&gt;通常直接在命令行下使用可执行的Ruby脚本 &lt;code&gt;jekyll&lt;/code&gt; ，它可以从gem安装。如果要启动一个临时的Web服务器并测试你的Jekyll站点，执行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ jekyll --server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在浏览器中访问 &lt;a href=&quot;http://localhost:4000&quot;&gt;http://localhost:4000&lt;/a&gt; 或 &lt;a href=&quot;http://0.0.0.0:4000&quot;&gt;http://0.0.0.0:4000&lt;/a&gt; 。当然这里还有其他许多参数选项可以使用。&lt;/p&gt;
&lt;p&gt;在Debian或Ubuntu下，你可能需要将 &lt;code&gt;/var/lib/gems/1.8/bin/&lt;/code&gt; 加到你的PATH环境变量中。&lt;/p&gt;
&lt;h3&gt;base-url选项&lt;/h3&gt;
&lt;p&gt;如果你使用了如下的base-url选项&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ jekyll --server --base-url '/blog'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么确保你所访问的站点地址是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:4000/blog/index.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;仅仅访问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:4000/blog&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是不行的。&lt;/p&gt;
&lt;h3&gt;部署&lt;/h3&gt;
&lt;p&gt;由于Jekyll所做的仅仅是生成一个包含HTML等静态网站文件的目录（_site），它可以通过简单的拷贝（scp）、远程同步（rsync）、ftp上传或git等方式部署到任何Web服务器上。&lt;/p&gt;
&lt;h2&gt;3. 配置&lt;/h2&gt;
&lt;p&gt;Jekyll允许你以任何可能的方式配置你的站点。以下是目前支持的配置选项的列表。它们均可通过站点根目录下的配置文件 &lt;code&gt;_config.yml&lt;/code&gt; 指定。 &lt;code&gt;jekyll&lt;/code&gt; 可执行文件同样有一些命令行参数对应于这些配置选项。当配置出现冲突时的优先级顺序是：&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;命令行参数&lt;/li&gt;
	&lt;li&gt;配置文件中的选项&lt;/li&gt;
	&lt;li&gt;默认值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;配置选项和命令行参数&lt;/h3&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;strong&gt;设定&lt;/strong&gt; &lt;/td&gt;
		&lt;td&gt; &lt;strong&gt;配置文件&lt;/strong&gt; &lt;/td&gt;
		&lt;td&gt; &lt;strong&gt;命令行参数&lt;/strong&gt; &lt;/td&gt;
		&lt;td&gt; &lt;strong&gt;简述&lt;/strong&gt; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 重新生成 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;auto: [boolean]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--no-auto --auto&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 允许或禁止Jekyll在文件被修改后重新生成整个站点 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 本地服务器 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;server: [boolean]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--server&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 自动开启一个用于托管_site目录的本地Web服务器 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 本地服务器端口 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;server_port: [integer]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--server [port]&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 更改Jekyll所使用的服务器端口 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; Base &lt;span class=&quot;caps&quot;&gt;URL&lt;/span&gt; &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;baseurl: [BASE_URL]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--base-url [url]&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 使用指定的Base URL在服务器上运行站点 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 站点目的路径 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;destination: [dir]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;jekyll [dest]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; 更改Jekyll存放生成文件的路径 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 站点源路径 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;source: [dir]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;jekyll [source] [dest]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; 更改Jekyll所处理文件的路径 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; Markdown &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;markdown: [engine]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--rdiscount&lt;/code&gt; or &lt;code&gt;--kramdown&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 使用RDiscount或[engine]以取代Maruku &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; Pygments &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;pygments: [boolean]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--pygments&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 允许Pygments处理代码语法高亮 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;span class=&quot;caps&quot;&gt;LSI&lt;/span&gt; &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;lsi: [boolean]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--lsi&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 产生相关帖子的索引 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 固定链接 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;permalink: [style]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--permalink=[style]&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 控制生成帖子的URL &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 分页 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;paginate: [per_page]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;code&gt;--paginate [per_page]&lt;/code&gt; &lt;/td&gt;
		&lt;td&gt; 将你的帖子分成多个子目录：&amp;quot;page2&amp;quot;、&amp;quot;page3&amp;quot;、……&amp;quot;pageN&amp;quot; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 排除 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;exclude: [dir1, file1, dir2]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;/td&gt;
		&lt;td&gt; 不需要进行转换的目录和文件列表 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; 帖子限制 &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt;limit_posts: [max_posts]&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; &lt;pre&gt; &lt;code&gt;--limit_posts=[max_posts]&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
		&lt;td&gt; 限制被转换与发布的帖子数量 &lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 请不要在配置文件中使用Tab制表符。这会导致解析错误，或使Jekyll意外地回退到配置的默认值。&lt;/p&gt;
&lt;h3&gt;配置的默认值&lt;/h3&gt;
&lt;pre&gt;
safe:        false
auto:        false
server:      false
server_port: 4000
baseurl:    /

source:      .
destination: ./_site
plugins:     ./_plugins

future:      true
lsi:         false
pygments:    false
markdown:    maruku
permalink:   date

maruku:
  use_tex:    false
  use_divs:   false
  png_engine: blahtex
  png_dir:    images/latex
  png_url:    /images/latex

rdiscount:
  extensions: []

kramdown:
  auto_ids: true,
  footnote_nr: 1
  entity_output: as_char
  toc_levels: 1..6
  use_coderay: false
  
  coderay:
    coderay_wrap: div
    coderay_line_numbers: inline
    coderay_line_numbers_start: 1
    coderay_tab_width: 4
    coderay_bold_every: 10
    coderay_css: style

&lt;/pre&gt;
&lt;h2&gt;补充：Windows平台上的中文支持&lt;/h2&gt;
&lt;p&gt;在Windows平台上，如果出现类似如下的错误信息：&lt;/p&gt;
&lt;p&gt;c:/Ruby192/lib/ruby/gems/1.9.1/gems/jekyll-0.11.0/lib/jekyll/convertible.rb:29:in `read_yaml&amp;#8217;: invalid byte sequence in &lt;span class=&quot;caps&quot;&gt;GBK&lt;/span&gt; (ArgumentError)&lt;/p&gt;
&lt;p&gt;&amp;#8230;&lt;/p&gt;
&lt;p&gt;你可能需要在命令行下改变当前代码页到UTF-8：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chcp.com 65001&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;p&gt;了解Jekyll静态网站生成器的起源。Jekyll作者（也是GitHub的共同创始人） Tom Preston-Werner的博文 &lt;a href=&quot;http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html&quot;&gt;Blogging like a hacker&lt;/a&gt; （中文翻译《 &lt;a href=&quot;http://kyle.xlau.org/posts/blogging-like-a-hacker.html&quot;&gt;像黑客一样写博客&lt;/a&gt; 》 by Kylexlau）。&lt;/p&gt;
&lt;p&gt;提供Web托管的 &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; 和GitHub的项目托管同样使用Git访问。如果你对分布式版本控制系统不熟悉， &lt;a href=&quot;http://progit.org/book/zh/&quot;&gt;Pro Git（中文）&lt;/a&gt; 是一个极好的起点。&lt;/p&gt;
&lt;p&gt;值得推荐的几款文本编辑器（它们都存在对Markdown和Textile的原生或第三方的语法高亮支持）：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.vim.org/&quot;&gt;Vim&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/s/emacs/&quot;&gt;&lt;span class=&quot;caps&quot;&gt;GNU&lt;/span&gt; Emacs&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://macromates.com/&quot;&gt;TextMate&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.scintilla.org/SciTE.html&quot;&gt;SciTE&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://live.gnome.org/Gedit/&quot;&gt;gedit&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://kate-editor.org/&quot;&gt;Kate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可能会用到的标记语言和模板引擎：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Textile_(markup_language)&quot;&gt;Textile&lt;/a&gt; 可读性好的轻量级标记语言，可以被转换成XHTML格式。
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;http://www.textism.com/tools/textile/&quot;&gt;Textile Home Page&lt;/a&gt;&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://redcloth.org/hobix.com/textile/&quot;&gt;A Textile Reference&lt;/a&gt;&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; Ruby的Textile实现引擎。&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt; 另一种Jekyll所支持的轻量级标记语言。
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown Home Page&lt;/a&gt;&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://deveiate.org/projects/BlueCloth&quot;&gt;BlueCloth&lt;/a&gt; Ruby的Markdown实现引擎。&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://maruku.rubyforge.org/&quot;&gt;Maruku&lt;/a&gt; Ruby的另一个Markdown实现引擎，效率较高。&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://github.com/rtomayko/rdiscount/&quot;&gt;RDiscount&lt;/a&gt; Ruby的另一个Markdown实现引擎，效率比Maruku更高。&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://liquidmarkup.org/&quot;&gt;Liquid&lt;/a&gt; Ruby的模板渲染引擎。它也是Jekyll所使用的模板引擎。
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;Liquid for Designers&lt;/a&gt;&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Programmers&quot;&gt;Liquid for Programmers&lt;/a&gt;&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他关于静态网站生成器的介绍和比较（英文）：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.mickgardner.com/2011/04/27/An-Introduction-To-Static-Site-Generators.html&quot;&gt;An Introduction to Static Site Generators&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://blog.guestlistapp.com/post/2304152860/five-reasons-to-use-a-static-site-generator-instead-of&quot;&gt;Five reasons to use a static site generator instead of Wordpress&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://philipm.at/2011/0507/&quot;&gt;jekyll vs. hyde &amp;#8211; a comparison of two static site generators&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.distractable.net/tech/static-site-generators-jekyll-vs-hyde&quot;&gt;Static Website Generators &amp;#8211; Jekyll vs Hyde&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想要尝试一些其他的静态网页生成器，这里是一个简略的列表：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Ruby
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://tinytree.info/&quot;&gt;Bonsai&lt;/a&gt; 一个非常简单（但实用）的小脚本&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://webgen.rubyforge.org/&quot;&gt;Webgen&lt;/a&gt; 一个较复杂的生成器&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Python
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;http://ringce.com/hyde&quot;&gt;Hyde&lt;/a&gt; Jekyll的Python语言实现版本&lt;/li&gt;
		&lt;li&gt;&lt;a href=&quot;http://pypi.python.org/pypi/cyrax&quot;&gt;Cyrax&lt;/a&gt; 使用Jinja2模板引擎的生成器&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;span class=&quot;caps&quot;&gt;PHP&lt;/span&gt;
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;http://www.phrozn.info/&quot;&gt;Phrozn&lt;/a&gt; PHP语言实现的静态网站生成器&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更详细的列表和介绍请参见：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.subspacefield.org/~travis/static_blog_generators.html&quot;&gt;Static Blog Generators&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://iwantmyname.com/blog/2011/02/list-static-website-generators.html&quot;&gt;32 Static Website Generators For Your Site, Blog Or Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
    </entry>
    
    
    
    
    
    
</feed>
